/**
 * Authentication helpers for Clerk token verification and OAuth
 */

import * as jose from 'jose';
import type { Bindings } from '../types';
import { authLogger } from './logger';
import { Provider } from '@zine/shared';

/**
 * Clerk JWT payload structure
 */
export interface ClerkJWTPayload extends jose.JWTPayload {
  /** Clerk user ID */
  sub: string;
  /** Authorized parties */
  azp?: string;
  /** Session ID */
  sid?: string;
}

/**
 * Result of token verification
 */
export interface VerifyTokenResult {
  success: true;
  userId: string;
  payload: ClerkJWTPayload;
}

/**
 * Error result from token verification
 */
export interface VerifyTokenError {
  success: false;
  error: string;
  code: 'MISSING_TOKEN' | 'INVALID_TOKEN' | 'EXPIRED_TOKEN' | 'JWKS_ERROR';
}

export type VerifyTokenResponse = VerifyTokenResult | VerifyTokenError;

/** JWKS cache for performance */
let jwksCache: jose.JWTVerifyGetKey | null = null;

/**
 * Get or create JWKS remote key set
 */
function getJWKS(jwksUrl: string): jose.JWTVerifyGetKey {
  if (!jwksCache) {
    jwksCache = jose.createRemoteJWKSet(new URL(jwksUrl));
  }
  return jwksCache;
}

/**
 * Clear JWKS cache (useful for testing or key rotation)
 */
export function clearJWKSCache(): void {
  jwksCache = null;
}

/**
 * Verify a Clerk JWT token
 *
 * @param token - The JWT token to verify (without "Bearer " prefix)
 * @param jwksUrl - The Clerk JWKS URL for key verification
 * @returns Verification result with user ID or error details
 */
export async function verifyClerkToken(
  token: string | undefined,
  jwksUrl: string
): Promise<VerifyTokenResponse> {
  if (!token) {
    return {
      success: false,
      error: 'No authentication token provided',
      code: 'MISSING_TOKEN',
    };
  }

  try {
    const JWKS = getJWKS(jwksUrl);

    const { payload } = await jose.jwtVerify(token, JWKS, {
      // Clerk tokens have specific requirements
      clockTolerance: 5, // 5 seconds clock tolerance
    });

    const clerkPayload = payload as ClerkJWTPayload;

    if (!clerkPayload.sub) {
      return {
        success: false,
        error: 'Token missing subject claim',
        code: 'INVALID_TOKEN',
      };
    }

    return {
      success: true,
      userId: clerkPayload.sub,
      payload: clerkPayload,
    };
  } catch (error) {
    if (error instanceof jose.errors.JWTExpired) {
      return {
        success: false,
        error: 'Token has expired',
        code: 'EXPIRED_TOKEN',
      };
    }

    if (error instanceof jose.errors.JWKSNoMatchingKey) {
      return {
        success: false,
        error: 'No matching key found in JWKS',
        code: 'JWKS_ERROR',
      };
    }

    // Generic JWT verification error
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Token verification failed',
      code: 'INVALID_TOKEN',
    };
  }
}

// ============================================================================
// OAuth Token Exchange
// ============================================================================

/**
 * OAuth token response from providers
 */
export interface OAuthTokens {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  token_type: string;
  scope?: string;
}

/**
 * Provider user info
 */
export interface ProviderUserInfo {
  id: string;
  email?: string;
  name?: string;
}

/**
 * OAuth configuration per provider
 */
const OAUTH_CONFIG = {
  YOUTUBE: {
    tokenUrl: 'https://oauth2.googleapis.com/token',
    userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
  },
  GMAIL: {
    tokenUrl: 'https://oauth2.googleapis.com/token',
    userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
  },
  SPOTIFY: {
    tokenUrl: 'https://accounts.spotify.com/api/token',
    userInfoUrl: 'https://api.spotify.com/v1/me',
  },
} as const;

/**
 * OAuth-enabled providers (subset of all providers)
 */
type OAuthProvider = Provider.YOUTUBE | Provider.SPOTIFY | Provider.GMAIL;

/**
 * Check if a provider supports OAuth
 */
function isOAuthProvider(provider: Provider): provider is OAuthProvider {
  return (
    provider === Provider.YOUTUBE || provider === Provider.SPOTIFY || provider === Provider.GMAIL
  );
}

/**
 * Exchange OAuth authorization code for tokens using PKCE
 *
 * @param provider - The OAuth provider (YOUTUBE or SPOTIFY)
 * @param code - The authorization code from the OAuth callback
 * @param codeVerifier - The PKCE code verifier generated by the client
 * @param env - Environment bindings with OAuth credentials
 * @param overrideRedirectUri - Optional redirect URI to use (must match the one used in auth request)
 * @returns OAuth tokens (access_token, refresh_token, expires_in)
 */
export async function exchangeCodeForTokens(
  provider: Provider,
  code: string,
  codeVerifier: string,
  env: Bindings,
  overrideRedirectUri?: string
): Promise<OAuthTokens> {
  if (!isOAuthProvider(provider)) {
    throw new Error(`Provider ${provider} does not support OAuth`);
  }
  const config = OAUTH_CONFIG[provider];

  // Get client credentials from environment
  const isGoogleProvider = provider === 'YOUTUBE' || provider === 'GMAIL';
  const clientId = isGoogleProvider ? env.GOOGLE_CLIENT_ID : env.SPOTIFY_CLIENT_ID;
  const clientSecret = isGoogleProvider ? env.GOOGLE_CLIENT_SECRET : env.SPOTIFY_CLIENT_SECRET;
  const redirectUri = overrideRedirectUri || env.OAUTH_REDIRECT_URI || 'zine://oauth/callback';

  if (!clientId) {
    throw new Error(`${provider} OAuth credentials not configured`);
  }

  // Build token request body
  // For Google/YouTube with PKCE, client_secret is optional (mobile apps don't have one)
  // For Spotify, client_secret is still required
  const body = new URLSearchParams({
    grant_type: 'authorization_code',
    code,
    redirect_uri: redirectUri,
    client_id: clientId,
    code_verifier: codeVerifier,
  });

  // Only add client_secret if available (required for Spotify, optional for Google with PKCE)
  if (clientSecret) {
    body.set('client_secret', clientSecret);
  }

  const response = await fetch(config.tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body,
  });

  if (!response.ok) {
    const errorText = await response.text();
    let errorMessage: string;
    try {
      const errorJson = JSON.parse(errorText);
      errorMessage = errorJson.error_description || errorJson.error || errorText;
    } catch {
      errorMessage = errorText;
    }
    throw new Error(`Token exchange failed: ${errorMessage}`);
  }

  const tokens = (await response.json()) as OAuthTokens;
  authLogger.debug('Token exchange response', { provider, hasAccessToken: !!tokens.access_token });

  if (!tokens.access_token) {
    throw new Error('No access token in response');
  }

  // Spotify doesn't always return refresh_token on PKCE flow if already granted
  // For now, use access_token as refresh_token placeholder if missing
  if (!tokens.refresh_token) {
    authLogger.warn('Provider did not return refresh_token', { provider });
    tokens.refresh_token = tokens.access_token;
  }

  return tokens;
}

/**
 * Get user info from the OAuth provider
 *
 * @param provider - The OAuth provider
 * @param accessToken - The access token to use for the request
 * @returns Provider user info (id, email, name)
 */
export async function getProviderUserInfo(
  provider: Provider,
  accessToken: string
): Promise<ProviderUserInfo> {
  if (!isOAuthProvider(provider)) {
    throw new Error(`Provider ${provider} does not support OAuth`);
  }
  const config = OAUTH_CONFIG[provider];

  const response = await fetch(config.userInfoUrl, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to get user info: ${errorText}`);
  }

  const data = (await response.json()) as Record<string, unknown>;

  // Map provider-specific response to common format
  if (provider === 'YOUTUBE' || provider === 'GMAIL') {
    return {
      id: data.id as string,
      email: data.email as string | undefined,
      name: data.name as string | undefined,
    };
  } else {
    // Spotify
    return {
      id: data.id as string,
      email: data.email as string | undefined,
      name: data.display_name as string | undefined,
    };
  }
}
