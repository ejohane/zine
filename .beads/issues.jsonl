{"id":"zine-lfp","title":"Frontend Spec Review: Gaps, Inconsistencies, and Refinements","description":"Comprehensive review of features/subscriptions/frontend-spec.md identifying gaps, inconsistencies, missing context, and areas needing refinement. This epic tracks all findings from the spec proofreading and polish session.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-16T22:03:05.293187-06:00","updated_at":"2025-12-16T22:03:05.293187-06:00"}
{"id":"zine-lfp.1","title":"Missing hook implementations referenced in Settings screen","description":"**Issue**: The Settings screen (Section 3) references hooks that are not defined anywhere in the spec:\n- `useConnections()` - returns `{ data: connections }`\n- `useSubscriptions()` - returns `{ data: subscriptions }`\n\n**Location**: Lines 281-286 in frontend-spec.md\n\n**Problem**: These hooks are used to fetch provider connections and subscriptions, but there's no definition of:\n1. The hook implementation\n2. The tRPC endpoints they call\n3. The return type shape\n\n**Fix Required**: Add a dedicated \"Data Hooks\" section defining:\n```typescript\n// apps/mobile/hooks/use-connections.ts\nexport function useConnections() {\n  return trpc.subscriptions.connections.list.useQuery();\n}\n```\n\nAnd document the expected return types from the backend.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.366678-06:00","updated_at":"2025-12-16T22:03:14.592406-06:00","dependencies":[{"issue_id":"zine-lfp.1","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.367044-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.10","title":"Navigation structure missing settings layout file","description":"**Issue**: The navigation structure (Section 2) shows `settings/` as a route group but Expo Router requires a `_layout.tsx` file for navigation configuration.\n\n**Current structure** (lines 191-205):\n```\nsettings/\n├── index.tsx        # Settings main screen\n├── connections.tsx  # Manage connected providers\n├── account.tsx      # Account settings\n└── about.tsx        # App info, version, etc.\n```\n\n**Missing**:\n- `settings/_layout.tsx` - Required for:\n  - Stack navigator configuration\n  - Header styling\n  - Back navigation behavior\n  - Screen transition animations\n\n**Fix Required**: Add layout file specification:\n```typescript\n// apps/mobile/app/settings/_layout.tsx\nimport { Stack } from 'expo-router';\n\nexport default function SettingsLayout() {\n  return (\n    \u003cStack\n      screenOptions={{\n        headerBackTitle: 'Settings',\n        headerStyle: { backgroundColor: colors.background },\n        headerTintColor: colors.text,\n      }}\n    \u003e\n      \u003cStack.Screen name=\"index\" options={{ title: 'Settings' }} /\u003e\n      \u003cStack.Screen name=\"connections\" options={{ title: 'Connected Accounts' }} /\u003e\n      \u003cStack.Screen name=\"account\" options={{ title: 'Account' }} /\u003e\n      \u003cStack.Screen name=\"about\" options={{ title: 'About' }} /\u003e\n    \u003c/Stack\u003e\n  );\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.008989-06:00","updated_at":"2025-12-16T22:04:09.809088-06:00","dependencies":[{"issue_id":"zine-lfp.10","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.009344-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.11","title":"Error boundary examples mix Tailwind classes with StyleSheet","description":"**Issue**: Error boundary components (Section 8) mix Tailwind/NativeWind className syntax with React Native's StyleSheet approach, creating inconsistent and potentially non-functional code.\n\n**Examples**:\n- Line 1147: `\u003cView className=\"flex-1 items-center justify-center p-6\"\u003e`\n- Line 1149: `\u003cText className=\"text-xl font-semibold mb-2 text-gray-900 dark:text-white\"\u003e`\n- Line 1155: `\u003cPressable onPress={this.handleReset} className=\"bg-blue-500 px-6 py-3 rounded-lg\"\u003e`\n\n**Problem**: \n1. The codebase doesn't appear to use NativeWind (not in package.json, no nativewind config visible)\n2. Even if using NativeWind, dark mode classes (`dark:text-white`) require additional configuration\n3. Mixing approaches makes code harder to maintain\n\n**The Settings screen example** (Section 3) correctly uses StyleSheet:\n```typescript\nconst styles = StyleSheet.create({\n  sectionTitle: { fontSize: 12, fontWeight: '600', ... },\n});\n```\n\n**Fix Required**: Convert all className usage to StyleSheet, using the design system tokens:\n```typescript\n\u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n  \u003cText style={[styles.heading, { color: colors.text }]}\u003eSomething went wrong\u003c/Text\u003e\n\u003c/View\u003e\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.07911-06:00","updated_at":"2025-12-16T22:04:16.173998-06:00","dependencies":[{"issue_id":"zine-lfp.11","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.079441-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.12","title":"Missing TypeScript interface for InboxItem used in renderItem","description":"**Issue**: The inbox screen example (Section 6.2) uses `InboxItem` type in `renderItem` (line 606) but this type is never defined.\n\n**Code reference**:\n```typescript\nrenderItem={renderItem}\n// ...\n\u003cFlatList\n  data={data.items as InboxItem[]}\n```\n\n**The existing codebase** defines `ItemWithUserState` in `apps/mobile/hooks/use-items.ts`:\n```typescript\nexport interface ItemWithUserState {\n  item: { id, title, summary, creator, ... };\n  userItem: { id, itemId, state, ingestedAt, ... };\n}\n```\n\n**Missing**:\n1. `InboxItem` interface definition\n2. How it differs from `ItemWithUserState` (if at all)\n3. Whether it includes subscription-specific fields (source attribution, sync status)\n\n**Fix Required**: Either:\n1. Define `InboxItem` interface with subscription source info:\n```typescript\ninterface InboxItem extends ItemWithUserState {\n  subscription?: {\n    id: string;\n    name: string;\n    provider: 'YOUTUBE' | 'SPOTIFY';\n    imageUrl?: string;\n  };\n}\n```\n2. Or clarify that `InboxItem` is just an alias for `ItemWithUserState`","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.148812-06:00","updated_at":"2025-12-16T22:04:21.403728-06:00","dependencies":[{"issue_id":"zine-lfp.12","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.149133-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.13","title":"Offline queue retry logic lacks error type discrimination","description":"**Issue**: The offline queue's `executeAction` method (Section 9.3, lines 1519-1535) catches all errors uniformly but should discriminate between error types for proper retry behavior.\n\n**Current code**:\n```typescript\nfor (const action of queue) {\n  try {\n    await this.executeAction(action);\n  } catch (error) {\n    if (action.retryCount \u003c 3) {\n      remainingActions.push({\n        ...action,\n        retryCount: action.retryCount + 1,\n        lastError: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n}\n```\n\n**Problem**: All errors are treated the same, but:\n1. **Network errors** - Should retry (temporary failure)\n2. **4xx client errors** - Should NOT retry (permanent failure)\n3. **401 Unauthorized** - Should refresh auth and retry once\n4. **409 Conflict** - Subscription already exists, resolve differently\n\n**Fix Required**: Add error type discrimination:\n```typescript\ncatch (error) {\n  const shouldRetry = isRetryableError(error);\n  const isAuthError = error.data?.code === 'UNAUTHORIZED';\n  \n  if (isAuthError) {\n    await refreshAuthAndRetry(action);\n  } else if (shouldRetry \u0026\u0026 action.retryCount \u003c 3) {\n    remainingActions.push({ ...action, retryCount: action.retryCount + 1 });\n  } else {\n    // Permanent failure - notify user, remove from queue\n    await notifyActionFailed(action, error);\n  }\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.22131-06:00","updated_at":"2025-12-16T22:04:27.663581-06:00","dependencies":[{"issue_id":"zine-lfp.13","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.221636-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.14","title":"Deep linking configuration references incorrect plugin syntax","description":"**Issue**: The app.json deep linking configuration (Section 7.1, line 823) uses incorrect Expo plugin syntax.\n\n**Current** (line 823):\n```json\n\"plugins\": [\"expo-router\", \"expo-secure-store\", [\"expo-linking\", { \"scheme\": \"zine\" }]]\n```\n\n**Problems**:\n1. `expo-linking` is not a valid Expo plugin - it's a core Expo module\n2. The `scheme` should be defined at the root level of app.json, not as a plugin config\n3. For Expo SDK 50+, scheme handling is automatic when `scheme` is set at root\n\n**Correct configuration**:\n```json\n{\n  \"expo\": {\n    \"name\": \"zine\",\n    \"slug\": \"zine\",\n    \"scheme\": \"zine\",\n    // ...\n    \"plugins\": [\n      \"expo-router\",\n      \"expo-secure-store\"\n    ]\n  }\n}\n```\n\n**Additional notes**:\n- `expo-web-browser` may need to be added to plugins if using `openAuthSessionAsync`\n- For production, may need `expo-linking` plugin only if customizing URL handling beyond the scheme","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:06.291247-06:00","updated_at":"2025-12-16T22:04:32.972774-06:00","dependencies":[{"issue_id":"zine-lfp.14","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.291614-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.15","title":"Missing Replicache integration context from local-first architecture","description":"**Issue**: The frontend spec's offline handling (Section 9) doesn't integrate with the local-first architecture documented in `docs/zine-sync-local-first.md`.\n\n**Architecture doc states**:\n- Replicache is the sync protocol\n- Client data is denormalized KV store\n- Server-authoritative truth via Durable Objects\n- Index strategy: `item/{id}`, `state/{id}`, `idx/list/{state}/{timeKey}/{id}`\n\n**Frontend spec states**:\n- Uses `AsyncStorage` for offline queue (line 1425)\n- Uses React Query for caching (`staleTime`, `gcTime`)\n- Uses tRPC directly with `fetch` under the hood\n\n**Disconnect**:\n1. If using Replicache, mutations should go through Replicache mutators, not tRPC directly\n2. Offline queue duplicates what Replicache provides natively\n3. React Query caching conflicts with Replicache's local KV store\n\n**Fix Required**: Clarify the architecture choice:\n- **Option A**: Remove offline queue, use Replicache for all data sync (aligns with local-first doc)\n- **Option B**: Clarify that subscriptions feature uses tRPC directly (not Replicache) and update local-first doc\n- **Option C**: Document hybrid approach where subscription metadata uses tRPC but inbox items use Replicache\n\nAdd a \"Data Architecture\" section to frontend spec explaining the relationship.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:06.36168-06:00","updated_at":"2025-12-16T22:04:40.962994-06:00","dependencies":[{"issue_id":"zine-lfp.15","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.36203-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.16","title":"SyncStatusIndicator animation may cause memory leak","description":"**Issue**: The `SyncStatusIndicator` component (Section 9.7, lines 1787-1834) has a potential memory leak in its animation effect.\n\n**Current code**:\n```typescript\nuseEffect(() =\u003e {\n  if (pendingCount \u003e 0) {\n    const pulse = Animated.loop(\n      Animated.sequence([\n        Animated.timing(pulseAnim, { toValue: 0.5, duration: 500, useNativeDriver: true }),\n        Animated.timing(pulseAnim, { toValue: 1, duration: 500, useNativeDriver: true }),\n      ])\n    );\n    pulse.start();\n    return () =\u003e pulse.stop();\n  } else {\n    pulseAnim.setValue(1);\n  }\n}, [pendingCount, pulseAnim]);\n```\n\n**Problems**:\n1. `pulseAnim` is a `useRef` value but is in the dependency array - this is unusual and may cause issues\n2. The cleanup only runs when `pendingCount` changes, not on unmount\n3. Missing cleanup for the case when component unmounts while `pendingCount === 0`\n\n**Fix Required**:\n```typescript\nconst pulseAnim = useRef(new Animated.Value(1)).current;\nconst animationRef = useRef\u003cAnimated.CompositeAnimation | null\u003e(null);\n\nuseEffect(() =\u003e {\n  if (pendingCount \u003e 0) {\n    animationRef.current = Animated.loop(\n      Animated.sequence([\n        Animated.timing(pulseAnim, { toValue: 0.5, duration: 500, useNativeDriver: true }),\n        Animated.timing(pulseAnim, { toValue: 1, duration: 500, useNativeDriver: true }),\n      ])\n    );\n    animationRef.current.start();\n  } else {\n    pulseAnim.setValue(1);\n  }\n\n  return () =\u003e {\n    animationRef.current?.stop();\n  };\n}, [pendingCount]); // Remove pulseAnim from deps\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.432299-06:00","updated_at":"2025-12-16T22:04:46.940703-06:00","dependencies":[{"issue_id":"zine-lfp.16","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.432672-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.17","title":"OAuth error handler completeOAuthFlow function not defined","description":"**Issue**: The `OAuthCallbackHandler` component (Section 7.6) calls `completeOAuthFlow` (line 943) which is dynamically imported but never defined anywhere in the spec.\n\n**Code reference**:\n```typescript\nconst { completeOAuthFlow } = await import('../lib/oauth');\nconst result = await completeOAuthFlow(params.code, params.state);\n```\n\n**Expected function signature**:\n```typescript\ninterface OAuthFlowResult {\n  success: boolean;\n  provider?: 'YOUTUBE' | 'SPOTIFY';\n  error?: string;\n}\n\nasync function completeOAuthFlow(code: string, state: string): Promise\u003cOAuthFlowResult\u003e\n```\n\n**Required implementation**:\n1. Parse provider from state (see bead zine-lfp.7)\n2. Retrieve PKCE verifier from SecureStore\n3. Call `trpc.subscriptions.connections.callback.mutate()`\n4. Clean up SecureStore entries\n5. Return success/failure with provider info\n\n**Fix Required**: Add complete function definition to Section 1 (OAuth Configuration):\n```typescript\nexport async function completeOAuthFlow(code: string, state: string): Promise\u003cOAuthFlowResult\u003e {\n  const [provider, stateId] = state.split(':') as ['YOUTUBE' | 'SPOTIFY', string];\n  \n  const storedState = await SecureStore.getItemAsync(`${provider.toLowerCase()}_oauth_state`);\n  if (storedState !== state) {\n    return { success: false, error: 'State mismatch' };\n  }\n  \n  const verifier = await SecureStore.getItemAsync(`${provider.toLowerCase()}_code_verifier`);\n  if (!verifier) {\n    return { success: false, error: 'Verifier not found' };\n  }\n  \n  try {\n    await trpc.subscriptions.connections.callback.mutate({ provider, code, state: stateId, codeVerifier: verifier });\n    await SecureStore.deleteItemAsync(`${provider.toLowerCase()}_code_verifier`);\n    await SecureStore.deleteItemAsync(`${provider.toLowerCase()}_oauth_state`);\n    return { success: true, provider };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:06.504364-06:00","updated_at":"2025-12-16T22:04:55.331573-06:00","dependencies":[{"issue_id":"zine-lfp.17","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.504695-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.18","title":"Missing Surface component import in inbox screen example","description":"**Issue**: The inbox screen example (Section 6.2) uses a `Surface` component as its root container but never imports or defines it.\n\n**Code reference** (line 576):\n```typescript\nreturn (\n  \u003cSurface style={[styles.container, { backgroundColor: colors.background }]}\u003e\n    \u003cSafeAreaView style={styles.safeArea} edges={['top']}\u003e\n```\n\n**Problem**: `Surface` is not a standard React Native component. It could be:\n1. A custom component from a UI library (e.g., react-native-paper)\n2. A custom component from the codebase\n3. A typo/mistake (should be `View`)\n\n**Looking at the codebase**: There's no `Surface` component in `apps/mobile/components/`\n\n**Fix Required**: Either:\n1. Define `Surface` component (if it's meant to provide elevation/shadow):\n```typescript\n// apps/mobile/components/surface.tsx\nexport function Surface({ style, children, ...props }) {\n  return (\n    \u003cView style={[Shadows.sm, style]} {...props}\u003e\n      {children}\n    \u003c/View\u003e\n  );\n}\n```\n\n2. Or replace with `View` if `Surface` provides no additional functionality:\n```typescript\nreturn (\n  \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.579381-06:00","updated_at":"2025-12-16T22:05:00.045399-06:00","dependencies":[{"issue_id":"zine-lfp.18","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.579749-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.19","title":"Inconsistent RefreshControl props between empty and populated states","description":"**Issue**: The inbox screen's RefreshControl props differ between the empty state ScrollView and the populated FlatList, leading to inconsistent behavior.\n\n**Empty state** (lines 595-600):\n```typescript\n\u003cRefreshControl\n  refreshing={isRefreshing}\n  onRefresh={handleRefresh}\n  tintColor={colors.primary}\n/\u003e\n```\n\n**Populated state** (lines 611-618):\n```typescript\n\u003cRefreshControl\n  refreshing={isRefreshing}\n  onRefresh={handleRefresh}\n  tintColor={colors.primary}\n  colors={[colors.primary]}  // Android-specific, missing from empty state\n  progressBackgroundColor={colors.background}  // Android-specific, missing from empty state\n/\u003e\n```\n\n**Problems**:\n1. Android users will see different refresh indicator styling between empty and populated states\n2. The `colors` prop is an array (Android uses multiple colors in sequence)\n3. Missing `progressViewOffset` for consistent positioning\n\n**Fix Required**: Create a shared RefreshControl configuration:\n```typescript\nconst refreshControlProps = {\n  refreshing: isRefreshing,\n  onRefresh: handleRefresh,\n  tintColor: colors.primary,\n  colors: [colors.primary],\n  progressBackgroundColor: colors.background,\n  progressViewOffset: 0,\n};\n\n// Usage:\n\u003cRefreshControl {...refreshControlProps} /\u003e\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.650037-06:00","updated_at":"2025-12-16T22:05:05.048222-06:00","dependencies":[{"issue_id":"zine-lfp.19","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.650378-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.2","title":"Inconsistent theme token usage across code examples","description":"**Issue**: Code examples inconsistently use theme tokens. Some use the design system (Colors, Spacing, Radius from @/constants/theme), while others use hardcoded values or Tailwind-style classes.\n\n**Examples of inconsistency**:\n1. Settings screen (line 296): Uses `{ backgroundColor: colors.card }` - correct\n2. Error boundaries (line 1147): Uses `className=\"flex-1 items-center justify-center p-6\"` - Tailwind\n3. SyncNowButton (line 698): Uses `className=\"px-3 py-1.5 rounded-full\"` - Tailwind\n4. OfflineBanner (line 1410): Uses `className=\"absolute top-0...\"` - Tailwind\n\n**Problem**: The actual codebase uses React Native StyleSheet (see apps/mobile/constants/theme.ts), not Tailwind/NativeWind class-based styling. The spec should be consistent with the existing architecture.\n\n**Fix Required**: Decide on styling approach and update all examples to match. If using NativeWind, add it to the tech stack section. If using StyleSheet, convert all Tailwind classes to proper RN styles.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:05.437392-06:00","updated_at":"2025-12-16T22:03:20.770569-06:00","dependencies":[{"issue_id":"zine-lfp.2","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.437755-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.20","title":"Settings screen missing imports section and hook definitions","description":"**Issue**: The Settings screen code (Section 3) jumps directly into the component without showing necessary imports, making it incomplete as a reference implementation.\n\n**Missing imports**:\n```typescript\n// Required imports not shown:\nimport { View, Text, ScrollView, Pressable, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Colors, Typography, Spacing, Radius } from '@/constants/theme';\nimport { useColorScheme } from '@/hooks/use-color-scheme';\nimport { useAuth } from '@/providers/auth-provider';\n\n// These hooks are used but not defined:\nimport { useConnections } from '@/hooks/use-connections';\nimport { useSubscriptions } from '@/hooks/use-subscriptions';\n```\n\n**Missing hook definitions**:\n1. `useConnections()` - Should return provider connection status\n2. `useSubscriptions()` - Should return subscription list with count\n\n**Fix Required**: \n1. Add imports section at top of code block\n2. Add \"Prerequisites\" callout noting dependent hooks\n3. Either inline simple hook implementations or reference a \"Data Hooks\" section:\n\n```typescript\n// apps/mobile/hooks/use-connections.ts\nexport function useConnections() {\n  return trpc.subscriptions.connections.list.useQuery();\n}\n\n// apps/mobile/hooks/use-subscriptions.ts  \nexport function useSubscriptions() {\n  return trpc.subscriptions.list.useQuery({});\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.720179-06:00","updated_at":"2025-12-16T22:05:12.014927-06:00","dependencies":[{"issue_id":"zine-lfp.20","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.720517-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.3","title":"PKCE generatePKCE function has incorrect base64URLEncode logic","description":"**Issue**: The PKCE `base64URLEncode` function (lines 163-166) has incorrect logic that will produce invalid challenges.\n\n**Current code**:\n```typescript\nfunction base64URLEncode(input: Uint8Array | string): string {\n  const base64 = typeof input === 'string' ? input : btoa(String.fromCharCode(...input));\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n```\n\n**Problems**:\n1. When `input` is already a base64 string (from `Crypto.digestStringAsync`), the function doesn't re-encode it - it just does URL-safe replacement. But the digest result needs different handling.\n2. `Crypto.digestStringAsync` with `BASE64` encoding returns standard base64, but the verifier encoding from `Uint8Array` uses a different path.\n3. The verifier should be base64url-encoded from raw bytes, but the challenge is SHA256(verifier) encoded to base64url.\n\n**Correct implementation**:\n```typescript\nfunction base64URLEncode(buffer: Uint8Array): string {\n  return btoa(String.fromCharCode(...buffer))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nasync function generatePKCE() {\n  const randomBytes = await Crypto.getRandomBytesAsync(32);\n  const verifier = base64URLEncode(randomBytes);\n  \n  const digestBuffer = await Crypto.digest(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    new TextEncoder().encode(verifier)\n  );\n  const challenge = base64URLEncode(new Uint8Array(digestBuffer));\n  \n  return { verifier, challenge };\n}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.510528-06:00","updated_at":"2025-12-16T22:03:28.104619-06:00","dependencies":[{"issue_id":"zine-lfp.3","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.510895-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.4","title":"Missing tRPC procedure definitions referenced in frontend","description":"**Issue**: The frontend spec references tRPC procedures that aren't fully aligned with the backend spec's API design.\n\n**Frontend references**:\n- `trpc.subscriptions.connections.registerState.mutate()` (line 74)\n- `trpc.subscriptions.connections.callback.mutate()` (line 128)\n- `trpc.subscriptions.add.mutate()` (line 1524)\n- `trpc.subscriptions.remove.mutate()` (line 1526)\n- `trpc.subscriptions.pause.mutate()` (line 1528)\n- `trpc.subscriptions.resume.mutate()` (line 1534)\n\n**Backend spec defines** (Section 5.1):\n- `subscriptions.connections.list` - Query\n- `subscriptions.connections.registerState` - Mutation\n- `subscriptions.connections.callback` - Mutation\n- `subscriptions.connections.disconnect` - Mutation\n- `subscriptions.add` - Mutation\n- `subscriptions.remove` - Mutation\n- `subscriptions.pause` - Mutation\n- `subscriptions.resume` - Mutation\n- `subscriptions.syncNow` - Mutation\n\n**Missing from backend spec**:\n- Input/output type definitions for each procedure\n- Full procedure signatures with Zod schemas\n\n**Fix Required**: Add a \"tRPC Contract\" section to frontend spec that explicitly lists all procedures with their input/output types, OR add these to backend spec and cross-reference.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.580958-06:00","updated_at":"2025-12-16T22:03:33.742606-06:00","dependencies":[{"issue_id":"zine-lfp.4","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.58132-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.5","title":"Inbox screen code example imports non-existent components","description":"**Issue**: The Inbox screen code example (Section 6.2, lines 553-625) imports/uses components that aren't defined anywhere:\n- `Surface` - used as root container, never imported or defined\n- `LoadingState` - referenced but not defined\n- `ErrorState` - referenced but not defined  \n- `EmptyState` - referenced but not defined\n- `useInboxItems` - different signature than the one in apps/mobile/hooks/use-items.ts\n\n**The actual codebase** (apps/mobile/hooks/use-items.ts) shows `useInboxItems()` returns `ItemWithUserState[]`, not `{ data, isLoading, error, refetch }`.\n\n**Fix Required**:\n1. Define or import `Surface`, `LoadingState`, `ErrorState`, `EmptyState` components\n2. Align the hook signature - either update the spec to match existing code, or document that this is a new API\n3. Add imports section to the code example","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:05.653456-06:00","updated_at":"2025-12-16T22:03:38.514682-06:00","dependencies":[{"issue_id":"zine-lfp.5","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.653815-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.6","title":"useSyncNow hook referenced but not defined in spec","description":"**Issue**: The `useSyncNow` hook is used in `SyncNowButton` component (line 645) but never defined in the spec.\n\n**Usage**:\n```typescript\nconst { syncNow, isLoading, cooldownSeconds, lastResult } = useSyncNow(subscriptionId);\n```\n\n**Expected behavior** (from context):\n- Calls `trpc.subscriptions.syncNow.mutate({ subscriptionId })`\n- Handles 5-minute cooldown per subscription (backend rate limit)\n- Tracks last result for success/error feedback\n\n**Missing definition should include**:\n1. Hook implementation with tRPC mutation\n2. Cooldown state management\n3. Result caching for UI feedback\n4. Error handling for `TOO_MANY_REQUESTS` response\n\n**Fix Required**: Add complete hook implementation:\n```typescript\n// apps/mobile/hooks/use-sync-now.ts\nexport function useSyncNow(subscriptionId: string) {\n  const [cooldownSeconds, setCooldownSeconds] = useState(0);\n  const [lastResult, setLastResult] = useState\u003cSyncResult | null\u003e(null);\n  \n  const mutation = trpc.subscriptions.syncNow.useMutation({\n    onSuccess: (data) =\u003e {\n      setLastResult({ success: true, itemsFound: data.itemsFound });\n      setCooldownSeconds(300); // 5 minutes\n    },\n    onError: (error) =\u003e {\n      if (error.data?.code === 'TOO_MANY_REQUESTS') {\n        // Parse cooldown from error\n      }\n      setLastResult({ success: false, message: error.message });\n    },\n  });\n  \n  return { syncNow: mutation.mutate, isLoading: mutation.isPending, cooldownSeconds, lastResult };\n}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.724523-06:00","updated_at":"2025-12-16T22:03:45.315849-06:00","dependencies":[{"issue_id":"zine-lfp.6","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.724888-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.7","title":"OAuth callback handler lacks provider identification logic","description":"**Issue**: The OAuth callback handler (Section 7.6, lines 896-976) parses the callback URL but doesn't determine which provider the callback is for.\n\n**Current code** (line 943):\n```typescript\nconst result = await completeOAuthFlow(params.code, params.state);\n```\n\n**Problem**: The `completeOAuthFlow` function needs to know the provider to:\n1. Retrieve the correct PKCE verifier from SecureStore (`${provider}_code_verifier`)\n2. Retrieve the correct state from SecureStore (`${provider}_oauth_state`)\n3. Call the correct tRPC procedure\n\nBut the callback URL `zine://oauth/callback?code=xxx\u0026state=yyy` doesn't include the provider.\n\n**Solutions**:\n1. **Encode provider in state**: Make state = `${provider}:${uuid}` and parse it\n2. **Use provider-specific callback URLs**: `zine://oauth/youtube/callback` vs `zine://oauth/spotify/callback`\n3. **Lookup state in SecureStore**: Try both providers' stored states to find a match\n\n**Fix Required**: Implement provider identification. Recommended approach is option 1 (encode in state) as it's simplest and aligns with common OAuth patterns:\n```typescript\nconst state = `${provider}:${crypto.randomUUID()}`;\n// Later: const [provider, stateId] = returnedState.split(':');\n```","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.796803-06:00","updated_at":"2025-12-16T22:03:51.357893-06:00","dependencies":[{"issue_id":"zine-lfp.7","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.797124-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.8","title":"Missing connection between offline queue and tRPC client","description":"**Issue**: The offline queue (Section 9.3) stores actions but the tRPC client isn't configured to use it. There's a disconnect between the queue and actual mutation execution.\n\n**Current architecture**:\n1. `useOfflineMutation` checks `isOnline` and queues if offline\n2. `offlineQueue.processQueue()` calls tRPC endpoints directly via dynamic import\n\n**Problems**:\n1. The queue imports tRPC client dynamically (line 1520): `const { trpc } = await import('./trpc')` - this creates a new client instance\n2. No integration with React Query's mutation cache\n3. Optimistic updates in `useOfflineMutation` won't sync with the actual tRPC query cache when queue processes\n\n**Missing integration points**:\n1. Configure `trpc.subscriptions.add` to automatically queue when offline instead of requiring a wrapper hook\n2. Sync queue processing results back to React Query cache\n3. Handle conflicts when queue processes (e.g., subscription was already added on another device)\n\n**Fix Required**: Document integration pattern between offline queue and tRPC client, potentially using tRPC's `links` feature for offline-first behavior:\n```typescript\n// trpc.ts\nconst offlineLink = () =\u003e {\n  return ({ op, next }) =\u003e {\n    if (!isOnline() \u0026\u0026 op.type === 'mutation') {\n      return offlineQueue.enqueue(op);\n    }\n    return next(op);\n  };\n};\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:05.869323-06:00","updated_at":"2025-12-16T22:03:58.591155-06:00","dependencies":[{"issue_id":"zine-lfp.8","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.869673-06:00","created_by":"daemon"}]}
{"id":"zine-lfp.9","title":"useSubscriptions hook references non-existent tRPC endpoints","description":"**Issue**: The `useSubscriptions` hook (Section 9.5, lines 1637-1718) references tRPC endpoints that don't match the backend spec's router structure.\n\n**Frontend hook uses**:\n- `trpc.subscriptions.list.useQuery({})` \n- `utils.client.subscriptions.add.mutate(payload)`\n- `utils.client.subscriptions.remove.mutate(payload)`\n\n**Backend spec defines** (Section 5.1):\n- `subscriptions.list` with input `{ provider?, status?, limit, cursor }`\n- `subscriptions.add` with input `{ provider, providerChannelId, name?, imageUrl? }`\n- `subscriptions.remove` with input `{ subscriptionId }`\n\n**Mismatches**:\n1. Frontend passes empty object `{}` to list, but backend expects optional pagination params\n2. Frontend `add` payload includes `{ provider, providerChannelId, name, imageUrl }` which matches\n3. Frontend `remove` payload uses `{ subscriptionId }` which matches\n4. Missing: Frontend doesn't handle cursor-based pagination from list response\n\n**Fix Required**: \n1. Update hook to handle pagination: `{ items, nextCursor, hasMore }`\n2. Add infinite query support for subscription list\n3. Align input types with Zod schemas from backend","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.938273-06:00","updated_at":"2025-12-16T22:04:04.555822-06:00","dependencies":[{"issue_id":"zine-lfp.9","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.938617-06:00","created_by":"daemon"}]}
