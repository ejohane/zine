{"id":"zine-rfy","title":"Subscriptions Feature Implementation","description":"Implement the full subscriptions feature allowing users to subscribe to YouTube channels and Spotify podcasts, with automatic polling for new content that lands in their inbox. Based on features/subscriptions/spec.md.\n\n## Phases\n- **Phase 1 (Week 1-2)**: Foundation - Database schema, types, encryption, OAuth flow\n- **Phase 2 (Week 3-4)**: Core Features - tRPC endpoints, provider SDKs, polling, ingestion\n- **Phase 3 (Week 5-6)**: Mobile UI - Connection screens, subscription management, deep linking\n- **Phase 4 (Week 7-8)**: Polish - Adaptive polling, health monitoring, notifications, error boundaries\n\n## Key Files\n- `apps/worker/src/db/schema.ts` - Database schema additions\n- `apps/worker/src/trpc/routers/` - New routers (connections, subscriptions)\n- `apps/worker/src/lib/` - OAuth, encryption, polling utilities\n- `apps/mobile/app/` - New screens for connections and subscriptions\n- `packages/shared/src/types/domain.ts` - New enums and types\n\n## Dependencies\n- googleapis npm package for YouTube API\n- @spotify/web-api-ts-sdk for Spotify API\n- Cloudflare KV for OAuth state and rate limiting\n- Existing auth infrastructure (Clerk)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T20:41:30.677079-06:00","updated_at":"2025-12-16T21:48:00.162317-06:00","closed_at":"2025-12-16T21:48:00.162317-06:00"}
{"id":"zine-rfy.11","title":"Phase 2.6: Implement cron-based polling scheduler","description":"## Task\nImplement cron-based polling scheduler for subscriptions.\n\n## Cron Configuration\n\nAdd to `wrangler.toml`:\n```toml\n[triggers]\ncrons = [\"*/15 * * * *\"]  # Every 15 minutes\n```\n\n## Polling Logic\n\n### `apps/worker/src/jobs/poll-subscriptions.ts`\n\n```typescript\nexport async function pollSubscriptions(env: Env) {\n  // 1. Collision prevention\n  const lockKey = 'cron:poll-subscriptions:lock';\n  const existingLock = await env.KV.get(lockKey);\n  if (existingLock) {\n    const elapsed = Date.now() - parseInt(existingLock);\n    if (elapsed \u003c 900_000) return; // Skip if \u003c 15 min\n  }\n  await env.KV.put(lockKey, Date.now().toString(), { expirationTtl: 900 });\n  \n  try {\n    // 2. Query due subscriptions\n    const dueSubscriptions = await getDueSubscriptions(env.db);\n    \n    // 3. Process in batches of 50\n    for (const batch of chunk(dueSubscriptions, 50)) {\n      await Promise.all(batch.map(sub =\u003e pollSubscription(sub, env)));\n    }\n  } finally {\n    await env.KV.delete(lockKey);\n  }\n}\n```\n\n### Query Due Subscriptions\n```typescript\nasync function getDueSubscriptions(db: DrizzleDB) {\n  const now = Date.now();\n  return db.query.subscriptions.findMany({\n    where: and(\n      eq(subscriptions.status, 'ACTIVE'),\n      or(\n        isNull(subscriptions.lastPolledAt),\n        sql`${subscriptions.lastPolledAt} + (${subscriptions.pollIntervalSeconds} * 1000) \u003c ${now}`\n      )\n    ),\n    limit: 200, // Safety limit\n  });\n}\n```\n\n### Poll Single Subscription\n```typescript\nasync function pollSubscription(subscription: Subscription, env: Env) {\n  const connection = await getConnection(subscription.userId, subscription.provider, env);\n  if (!connection || connection.status !== 'ACTIVE') {\n    await markSubscriptionDisconnected(subscription.id, env.db);\n    return;\n  }\n  \n  const accessToken = await getValidTokenWithLock(connection, env);\n  const items = await fetchNewItems(subscription, accessToken, env);\n  \n  for (const item of items) {\n    await ingestItem(subscription.userId, subscription.id, item, subscription.provider, env.db);\n  }\n  \n  await updateLastPolled(subscription.id, env.db);\n}\n```\n\n## Worker Entry Point\n```typescript\nexport default {\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    ctx.waitUntil(pollSubscriptions(env));\n  },\n  // ... fetch handler for HTTP\n};\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §3.2, §3.2.1","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.373844-06:00","updated_at":"2025-12-16T21:47:56.672044-06:00","closed_at":"2025-12-16T21:47:56.672044-06:00","dependencies":[{"issue_id":"zine-rfy.11","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.374136-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.12","title":"Phase 2.7: Add syncNow manual sync endpoint","description":"## Task\nAdd manual \"Sync Now\" endpoint for on-demand subscription polling.\n\n## Endpoint\n\n### `subscriptions.syncNow`\n\n```typescript\nsyncNow: protectedProcedure\n  .input(z.object({ subscriptionId: z.string() }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Verify ownership\n    const subscription = await ctx.db.query.subscriptions.findFirst({\n      where: and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!subscription) {\n      throw new TRPCError({ code: 'NOT_FOUND' });\n    }\n    \n    // 2. Rate limit (max 1 per 5 minutes per subscription)\n    const rateLimitKey = `manual-sync:${input.subscriptionId}`;\n    const lastSync = await ctx.env.KV.get(rateLimitKey);\n    if (lastSync \u0026\u0026 Date.now() - parseInt(lastSync) \u003c 5 * 60 * 1000) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: 'Please wait 5 minutes between manual syncs',\n      });\n    }\n    \n    // 3. Perform sync\n    const connection = await getConnection(ctx.userId, subscription.provider, ctx.env);\n    const result = await pollSubscriptionWithRetry(subscription, connection, ctx.env);\n    \n    // 4. Update rate limit\n    await ctx.env.KV.put(rateLimitKey, Date.now().toString(), { expirationTtl: 300 });\n    \n    return { \n      success: result.success, \n      itemsFound: result.itemsFound,\n      itemsIngested: result.itemsIngested,\n    };\n  }),\n```\n\n## Mobile Integration\nAdd \"Sync Now\" button to subscription detail/list screens.\n\n## Spec Reference\nfeatures/subscriptions/spec.md §5.1","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.436324-06:00","updated_at":"2025-12-16T21:47:59.261508-06:00","closed_at":"2025-12-16T21:47:59.261508-06:00","dependencies":[{"issue_id":"zine-rfy.12","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.436638-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.13","title":"Phase 3.1: Implement mobile PKCE OAuth utilities","description":"## Task\nImplement PKCE OAuth utilities for mobile app.\n\n## Why Client-Side PKCE\nPKCE protects against authorization code interception. The verifier MUST be generated on the client - server-generated PKCE defeats the security purpose.\n\n## Files to Create\n\n### `apps/mobile/lib/pkce.ts`\n\n```typescript\nimport * as Crypto from 'expo-crypto';\n\n/**\n * Generate cryptographically random code verifier (43-128 chars)\n */\nexport async function generateCodeVerifier(): Promise\u003cstring\u003e {\n  const randomBytes = await Crypto.getRandomBytesAsync(32);\n  return base64UrlEncode(randomBytes);\n}\n\n/**\n * Generate code challenge from verifier (SHA256, base64url encoded)\n */\nexport async function generateCodeChallenge(verifier: string): Promise\u003cstring\u003e {\n  const hash = await Crypto.digestStringAsync(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    verifier,\n    { encoding: Crypto.CryptoEncoding.BASE64 }\n  );\n  return base64ToBase64Url(hash);\n}\n\nfunction base64UrlEncode(bytes: Uint8Array): string {\n  return btoa(String.fromCharCode(...bytes))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '');\n}\n```\n\n### `apps/mobile/lib/oauth.ts`\n\n```typescript\nimport * as WebBrowser from 'expo-web-browser';\nimport * as Linking from 'expo-linking';\n\nexport async function initiateOAuthFlow(provider: 'YOUTUBE' | 'SPOTIFY') {\n  // 1. Generate PKCE\n  const codeVerifier = await generateCodeVerifier();\n  const codeChallenge = await generateCodeChallenge(codeVerifier);\n  const state = crypto.randomUUID();\n  \n  // 2. Register state with server\n  await trpc.connections.registerState.mutate({ provider, state });\n  \n  // 3. Build auth URL\n  const authUrl = buildAuthUrl(provider, {\n    codeChallenge,\n    state,\n    redirectUri: Linking.createURL('oauth/callback'),\n  });\n  \n  // 4. Open browser\n  const result = await WebBrowser.openAuthSessionAsync(authUrl, redirectUri);\n  \n  // 5. Handle result\n  if (result.type === 'success') {\n    const { code, state: returnedState } = parseRedirectUrl(result.url);\n    \n    // 6. Exchange code for tokens\n    await trpc.connections.callback.mutate({\n      provider,\n      code,\n      state: returnedState,\n      codeVerifier,\n    });\n  }\n}\n```\n\n## Auth URLs\n- YouTube: `https://accounts.google.com/o/oauth2/v2/auth`\n- Spotify: `https://accounts.spotify.com/authorize`\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.2, §6.3","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.498433-06:00","updated_at":"2025-12-16T21:47:56.575225-06:00","closed_at":"2025-12-16T21:47:56.575225-06:00","dependencies":[{"issue_id":"zine-rfy.13","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.498734-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.14","title":"Phase 3.2: Create provider connection screens (YouTube, Spotify)","description":"## Task\nCreate provider connection screens for YouTube and Spotify OAuth.\n\n## Screens\n\n### `apps/mobile/app/(tabs)/connections.tsx`\n\nMain connections management screen:\n- List connected providers with status\n- \"Connect\" buttons for disconnected providers\n- \"Disconnect\" option for connected providers\n- Connection health indicators\n\n```typescript\nexport default function ConnectionsScreen() {\n  const { data: connections } = trpc.connections.list.useQuery();\n  \n  return (\n    \u003cScrollView\u003e\n      \u003cProviderConnectionCard\n        provider=\"YOUTUBE\"\n        connection={connections?.find(c =\u003e c.provider === 'YOUTUBE')}\n        onConnect={() =\u003e initiateOAuthFlow('YOUTUBE')}\n        onDisconnect={() =\u003e handleDisconnect('YOUTUBE')}\n      /\u003e\n      \u003cProviderConnectionCard\n        provider=\"SPOTIFY\"\n        connection={connections?.find(c =\u003e c.provider === 'SPOTIFY')}\n        onConnect={() =\u003e initiateOAuthFlow('SPOTIFY')}\n        onDisconnect={() =\u003e handleDisconnect('SPOTIFY')}\n      /\u003e\n    \u003c/ScrollView\u003e\n  );\n}\n```\n\n### `apps/mobile/components/provider-connection-card.tsx`\n\nReusable card component:\n- Provider logo and name\n- Connection status (Connected/Disconnected/Expired)\n- Connected timestamp\n- Scopes granted\n- Action button (Connect/Reconnect/Disconnect)\n\n```typescript\ninterface Props {\n  provider: 'YOUTUBE' | 'SPOTIFY';\n  connection?: ProviderConnection;\n  onConnect: () =\u003e void;\n  onDisconnect: () =\u003e void;\n}\n\nexport function ProviderConnectionCard({ provider, connection, onConnect, onDisconnect }: Props) {\n  const isConnected = connection?.status === 'ACTIVE';\n  const isExpired = connection?.status === 'EXPIRED';\n  \n  return (\n    \u003cView className=\"p-4 rounded-lg border\"\u003e\n      \u003cView className=\"flex-row items-center\"\u003e\n        \u003cProviderLogo provider={provider} /\u003e\n        \u003cText className=\"ml-3 font-semibold\"\u003e{provider}\u003c/Text\u003e\n        \u003cStatusBadge status={connection?.status} /\u003e\n      \u003c/View\u003e\n      \n      {isConnected \u0026\u0026 (\n        \u003cText className=\"text-gray-500 text-sm mt-2\"\u003e\n          Connected {formatRelative(connection.connectedAt)}\n        \u003c/Text\u003e\n      )}\n      \n      \u003cPressable\n        onPress={isConnected ? onDisconnect : onConnect}\n        className={isConnected ? \"bg-red-500\" : \"bg-blue-500\"}\n      \u003e\n        \u003cText\u003e{isExpired ? 'Reconnect' : isConnected ? 'Disconnect' : 'Connect'}\u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.1, §6.2","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.561841-06:00","updated_at":"2025-12-16T21:47:55.649753-06:00","closed_at":"2025-12-16T21:47:55.649753-06:00","dependencies":[{"issue_id":"zine-rfy.14","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.562163-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.15","title":"Phase 3.3: Create subscription management screens","description":"## Task\nCreate subscription management screens.\n\n## Screens\n\n### `apps/mobile/app/(tabs)/subscriptions.tsx`\n\nList all user subscriptions:\n- Grouped by provider\n- Shows subscription status, last updated\n- Pull-to-refresh\n- Search/filter\n- Add subscription FAB\n\n```typescript\nexport default function SubscriptionsScreen() {\n  const { data, isLoading, refetch } = trpc.subscriptions.list.useQuery();\n  \n  return (\n    \u003cView className=\"flex-1\"\u003e\n      \u003cFlatList\n        data={data?.items}\n        renderItem={({ item }) =\u003e (\n          \u003cSubscriptionListItem\n            subscription={item}\n            onPress={() =\u003e router.push(`/subscription/${item.id}`)}\n          /\u003e\n        )}\n        refreshControl={\u003cRefreshControl refreshing={isLoading} onRefresh={refetch} /\u003e}\n        ListEmptyComponent={\u003cEmptySubscriptions /\u003e}\n      /\u003e\n      \u003cFAB icon=\"plus\" onPress={() =\u003e router.push('/discover')} /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### `apps/mobile/components/subscription-list.tsx`\n\nReusable list item:\n```typescript\ninterface Props {\n  subscription: Subscription;\n  onPress: () =\u003e void;\n}\n\nexport function SubscriptionListItem({ subscription, onPress }: Props) {\n  return (\n    \u003cPressable onPress={onPress} className=\"flex-row p-4 border-b\"\u003e\n      \u003cImage source={{ uri: subscription.imageUrl }} className=\"w-12 h-12 rounded\" /\u003e\n      \u003cView className=\"ml-3 flex-1\"\u003e\n        \u003cText className=\"font-semibold\"\u003e{subscription.name}\u003c/Text\u003e\n        \u003cText className=\"text-gray-500 text-sm\"\u003e\n          {subscription.provider} • {formatStatus(subscription.status)}\n        \u003c/Text\u003e\n      \u003c/View\u003e\n      \u003cProviderIcon provider={subscription.provider} /\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Subscription Detail Screen\n- Full metadata\n- Sync Now button\n- Pause/Resume toggle\n- Unsubscribe (with confirmation)\n- Recent items from this subscription\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.4","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.622098-06:00","updated_at":"2025-12-16T21:47:55.254925-06:00","closed_at":"2025-12-16T21:47:55.254925-06:00","dependencies":[{"issue_id":"zine-rfy.15","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.62242-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.16","title":"Phase 3.4: Implement channel/show discovery and search","description":"## Task\nImplement channel/show discovery and search functionality.\n\n## Server-Side Search Endpoints\n\n### `subscriptions.searchChannels`\n```typescript\nsearchChannels: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n    query: z.string().min(2).max(100),\n    limit: z.number().min(1).max(20).default(10),\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    const connection = await requireConnection(ctx.userId, input.provider, ctx.env);\n    \n    if (input.provider === 'YOUTUBE') {\n      // Note: search.list costs 100 quota units - use sparingly!\n      return searchYouTubeChannels(connection, input.query, input.limit, ctx.env);\n    } else {\n      return searchSpotifyShows(connection, input.query, input.limit, ctx.env);\n    }\n  }),\n```\n\n## Mobile Discovery Screen\n\n### `apps/mobile/app/discover.tsx`\n\n```typescript\nexport default function DiscoverScreen() {\n  const [provider, setProvider] = useState\u003c'YOUTUBE' | 'SPOTIFY'\u003e('YOUTUBE');\n  const [searchQuery, setSearchQuery] = useState('');\n  const debouncedQuery = useDebounce(searchQuery, 300);\n  \n  const { data: results, isLoading } = trpc.subscriptions.searchChannels.useQuery(\n    { provider, query: debouncedQuery },\n    { enabled: debouncedQuery.length \u003e= 2 }\n  );\n  \n  return (\n    \u003cView className=\"flex-1\"\u003e\n      \u003cProviderTabs selected={provider} onSelect={setProvider} /\u003e\n      \u003cSearchInput value={searchQuery} onChangeText={setSearchQuery} /\u003e\n      \n      \u003cFlatList\n        data={results}\n        renderItem={({ item }) =\u003e (\n          \u003cDiscoveryResultItem\n            channel={item}\n            onSubscribe={() =\u003e handleSubscribe(item)}\n          /\u003e\n        )}\n        ListEmptyComponent={\n          debouncedQuery ? \u003cNoResults /\u003e : \u003cSearchPrompt /\u003e\n        }\n      /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### `apps/mobile/hooks/use-channel-search.ts`\n\nCustom hook with debouncing and caching:\n```typescript\nexport function useChannelSearch(provider: Provider, query: string) {\n  const debouncedQuery = useDebounce(query, 300);\n  \n  return trpc.subscriptions.searchChannels.useQuery(\n    { provider, query: debouncedQuery },\n    {\n      enabled: debouncedQuery.length \u003e= 2,\n      staleTime: 5 * 60 * 1000, // Cache for 5 minutes\n      cacheTime: 30 * 60 * 1000,\n    }\n  );\n}\n```\n\n## Quota Consideration\nYouTube search costs 100 units/request. Consider:\n- Minimum query length (2+ chars)\n- Debouncing (300ms)\n- Client-side result caching\n- Daily search limit per user\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.3","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.685554-06:00","updated_at":"2025-12-16T21:47:58.759507-06:00","closed_at":"2025-12-16T21:47:58.759507-06:00","dependencies":[{"issue_id":"zine-rfy.16","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.685882-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.17","title":"Phase 3.5: Configure deep linking for OAuth callbacks","description":"## Task\nConfigure deep linking for OAuth callbacks in the mobile app.\n\n## app.json Configuration\n\n```json\n{\n  \"expo\": {\n    \"scheme\": \"zine\",\n    \"ios\": {\n      \"bundleIdentifier\": \"app.zine.mobile\",\n      \"associatedDomains\": [\"applinks:zine.app\"]\n    },\n    \"android\": {\n      \"package\": \"app.zine.mobile\",\n      \"intentFilters\": [\n        {\n          \"action\": \"VIEW\",\n          \"autoVerify\": true,\n          \"data\": [\n            {\n              \"scheme\": \"https\",\n              \"host\": \"zine.app\",\n              \"pathPrefix\": \"/oauth/callback\"\n            }\n          ],\n          \"category\": [\"BROWSABLE\", \"DEFAULT\"]\n        },\n        {\n          \"action\": \"VIEW\",\n          \"data\": [\n            {\n              \"scheme\": \"zine\",\n              \"host\": \"oauth\",\n              \"pathPrefix\": \"/callback\"\n            }\n          ],\n          \"category\": [\"BROWSABLE\", \"DEFAULT\"]\n        }\n      ]\n    }\n  }\n}\n```\n\n## URL Schemes\n- Custom: `zine://oauth/callback?code=...\u0026state=...`\n- Universal (HTTPS): `https://zine.app/oauth/callback?code=...\u0026state=...`\n\n## Deep Link Handler\n\n### `apps/mobile/app/_layout.tsx`\n\n```typescript\nimport * as Linking from 'expo-linking';\nimport { useEffect } from 'react';\n\nexport default function RootLayout() {\n  useEffect(() =\u003e {\n    // Handle deep links when app is already open\n    const subscription = Linking.addEventListener('url', handleDeepLink);\n    \n    // Handle deep link that opened the app\n    Linking.getInitialURL().then(url =\u003e {\n      if (url) handleDeepLink({ url });\n    });\n    \n    return () =\u003e subscription.remove();\n  }, []);\n  \n  const handleDeepLink = async ({ url }: { url: string }) =\u003e {\n    const parsed = Linking.parse(url);\n    \n    if (parsed.path === 'oauth/callback') {\n      const { code, state, error } = parsed.queryParams;\n      \n      if (error) {\n        // Handle OAuth error (user denied, etc.)\n        showError(error);\n        return;\n      }\n      \n      // The OAuth flow will complete via WebBrowser.openAuthSessionAsync\n      // This handler is backup for edge cases\n    }\n  };\n  \n  return \u003cSlot /\u003e;\n}\n```\n\n## OAuth Redirect URI\nSet in Google/Spotify OAuth app settings:\n- Development: `zine://oauth/callback`\n- Production: `https://zine.app/oauth/callback`\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.5","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.748698-06:00","updated_at":"2025-12-16T21:47:54.842197-06:00","closed_at":"2025-12-16T21:47:54.842197-06:00","dependencies":[{"issue_id":"zine-rfy.17","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.749007-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.18","title":"Phase 3.6: Add subscription items to inbox display","description":"## Task\nUpdate inbox display to show subscription-sourced items.\n\n## Changes to Inbox\n\n### Visual Indicators\n- Show subscription source for items from subscriptions\n- Provider icon (YouTube/Spotify)\n- \"From: Channel Name\" subtitle\n\n### `apps/mobile/app/(tabs)/inbox.tsx`\n\nUpdate item rendering:\n```typescript\nfunction InboxItem({ userItem }: { userItem: UserItemWithDetails }) {\n  const { item, subscriptionSource } = userItem;\n  \n  return (\n    \u003cPressable className=\"flex-row p-4 border-b\"\u003e\n      \u003cImage source={{ uri: item.thumbnailUrl }} className=\"w-20 h-12 rounded\" /\u003e\n      \u003cView className=\"ml-3 flex-1\"\u003e\n        \u003cText className=\"font-semibold\" numberOfLines={2}\u003e{item.title}\u003c/Text\u003e\n        \u003cView className=\"flex-row items-center mt-1\"\u003e\n          \u003cProviderIcon provider={item.provider} size={14} /\u003e\n          \u003cText className=\"text-gray-500 text-sm ml-1\"\u003e\n            {subscriptionSource?.name || item.creator}\n          \u003c/Text\u003e\n        \u003c/View\u003e\n        {item.duration \u0026\u0026 (\n          \u003cText className=\"text-gray-400 text-xs\"\u003e{formatDuration(item.duration)}\u003c/Text\u003e\n        )}\n      \u003c/View\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Updated Hook\n\n### `apps/mobile/hooks/use-items.ts`\n\n```typescript\nexport function useInboxItems() {\n  return trpc.items.list.useQuery({\n    state: 'INBOX',\n    includeSubscriptionSource: true, // New flag\n  });\n}\n```\n\n### Backend Changes\n\nUpdate items.list to optionally include subscription source:\n```typescript\nlist: protectedProcedure\n  .input(z.object({\n    state: UserItemStateSchema,\n    includeSubscriptionSource: z.boolean().default(false),\n    // ... pagination\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    // Join with subscription_items and subscriptions if requested\n  }),\n```\n\n## Empty State\nWhen inbox is empty but user has subscriptions:\n\"No new items yet. Your subscriptions will appear here when new content is published.\"\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.6","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.813044-06:00","updated_at":"2025-12-16T21:47:54.433712-06:00","closed_at":"2025-12-16T21:47:54.433712-06:00","dependencies":[{"issue_id":"zine-rfy.18","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.813359-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.19","title":"Phase 4.1: Implement adaptive polling intervals","description":"## Task\nImplement adaptive polling intervals based on channel activity.\n\n## Algorithm\n\nAdjust poll frequency based on:\n1. **Channel posting frequency** - Prolific channels poll more often\n2. **Time since last new item** - Stale channels poll less\n3. **Time of day** - Reduce polling during off-peak hours (optional)\n\n### `apps/worker/src/lib/adaptive-polling.ts`\n\n```typescript\ninterface AdaptiveConfig {\n  minIntervalSeconds: number;  // 3600 (1 hour)\n  maxIntervalSeconds: number;  // 86400 (24 hours)\n  defaultIntervalSeconds: number; // 14400 (4 hours)\n}\n\nexport function calculateNextPollInterval(\n  subscription: Subscription,\n  recentItemTimestamps: number[],\n  config: AdaptiveConfig = DEFAULT_CONFIG\n): number {\n  // 1. Calculate average posting frequency\n  const avgPostingInterval = calculateAverageInterval(recentItemTimestamps);\n  \n  // 2. Time since last new item\n  const timeSinceLastItem = Date.now() - subscription.lastPublishedAt;\n  \n  // 3. Base interval on posting frequency\n  let interval: number;\n  \n  if (avgPostingInterval === null) {\n    // New subscription or no history - use default\n    interval = config.defaultIntervalSeconds;\n  } else if (avgPostingInterval \u003c 3600 * 6) {\n    // Posts multiple times per day - poll hourly\n    interval = config.minIntervalSeconds;\n  } else if (avgPostingInterval \u003c 3600 * 24) {\n    // Posts daily - poll every 4 hours\n    interval = 3600 * 4;\n  } else if (avgPostingInterval \u003c 3600 * 24 * 7) {\n    // Posts weekly - poll every 12 hours\n    interval = 3600 * 12;\n  } else {\n    // Posts rarely - poll daily\n    interval = config.maxIntervalSeconds;\n  }\n  \n  // 4. Decay: if no new content for 2x the expected interval, slow down\n  const expectedNextPost = (subscription.lastPublishedAt || 0) + avgPostingInterval;\n  if (Date.now() \u003e expectedNextPost * 2) {\n    interval = Math.min(interval * 1.5, config.maxIntervalSeconds);\n  }\n  \n  return Math.floor(interval);\n}\n```\n\n## Integration\n\nUpdate after each poll:\n```typescript\nasync function pollSubscription(subscription, env) {\n  // ... fetch items ...\n  \n  const recentTimestamps = items.map(i =\u003e i.publishedAt);\n  const newInterval = calculateNextPollInterval(subscription, recentTimestamps);\n  \n  await db.update(subscriptions)\n    .set({ pollIntervalSeconds: newInterval, lastPolledAt: Date.now() })\n    .where(eq(subscriptions.id, subscription.id));\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §3.3","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.876564-06:00","updated_at":"2025-12-16T21:47:58.246995-06:00","closed_at":"2025-12-16T21:47:58.246995-06:00","dependencies":[{"issue_id":"zine-rfy.19","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.876892-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.20","title":"Phase 4.2: Add connection health monitoring and recovery","description":"## Task\nAdd connection health monitoring and automatic recovery.\n\n## Health Check Job\n\n### `apps/worker/src/jobs/health-check.ts`\n\nRun every hour to check connection health:\n```typescript\nexport async function checkConnectionHealth(env: Env) {\n  const connections = await env.db.query.providerConnections.findMany({\n    where: eq(providerConnections.status, 'ACTIVE'),\n  });\n  \n  for (const connection of connections) {\n    const health = await checkSingleConnection(connection, env);\n    \n    if (!health.healthy) {\n      await handleUnhealthyConnection(connection, health.reason, env);\n    }\n  }\n}\n\nasync function checkSingleConnection(connection, env) {\n  try {\n    // Try to refresh token (validates credentials)\n    const token = await getValidTokenWithLock(connection, env);\n    \n    // Make lightweight API call to verify access\n    if (connection.provider === 'YOUTUBE') {\n      await verifyYouTubeAccess(token, env);\n    } else {\n      await verifySpotifyAccess(token, env);\n    }\n    \n    return { healthy: true };\n  } catch (error) {\n    return { healthy: false, reason: categorizeError(error) };\n  }\n}\n```\n\n## Error Categories\n\n```typescript\ntype ConnectionError = \n  | 'token_expired'      // Needs refresh (normal)\n  | 'token_revoked'      // User revoked access\n  | 'refresh_failed'     // Refresh token invalid\n  | 'api_error'          // Temporary API issue\n  | 'quota_exceeded';    // YouTube quota hit\n\nfunction categorizeError(error: unknown): ConnectionError {\n  // Parse error response codes\n}\n```\n\n## Recovery Actions\n\n```typescript\nasync function handleUnhealthyConnection(connection, reason, env) {\n  switch (reason) {\n    case 'token_revoked':\n    case 'refresh_failed':\n      // Mark as EXPIRED, notify user to reconnect\n      await markConnectionExpired(connection.id, env.db);\n      await createNotification(connection.userId, {\n        type: 'connection_expired',\n        provider: connection.provider,\n      });\n      break;\n      \n    case 'quota_exceeded':\n      // Pause YouTube subscriptions temporarily\n      await pauseProviderSubscriptions(connection.userId, 'YOUTUBE', env.db);\n      break;\n      \n    case 'api_error':\n      // Log and retry on next health check\n      console.warn(`API error for connection ${connection.id}`);\n      break;\n  }\n}\n```\n\n## Wrangler Config\n```toml\n[triggers]\ncrons = [\"*/15 * * * *\", \"0 * * * *\"]  # Poll every 15min, health check hourly\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §7.4, §7.5","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.942005-06:00","updated_at":"2025-12-16T21:47:58.09968-06:00","closed_at":"2025-12-16T21:47:58.09968-06:00","dependencies":[{"issue_id":"zine-rfy.20","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.942338-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.21","title":"Phase 4.3: Implement user notifications system","description":"## Task\nImplement user notifications system for subscription events.\n\n## Notification Types\n\n```typescript\ntype NotificationType =\n  | 'connection_expired'    // OAuth token needs refresh\n  | 'subscription_error'    // Polling failed repeatedly\n  | 'rate_limit_warning'    // Approaching rate limits\n  | 'quota_warning';        // YouTube quota running low\n```\n\n## Database\n\nAdd `user_notification_preferences` table:\n```sql\nCREATE TABLE user_notification_preferences (\n  user_id TEXT PRIMARY KEY REFERENCES users(id),\n  connection_issues BOOLEAN DEFAULT TRUE,\n  subscription_errors BOOLEAN DEFAULT TRUE,\n  rate_limit_warnings BOOLEAN DEFAULT FALSE,\n  quota_status BOOLEAN DEFAULT TRUE,\n  push_enabled BOOLEAN DEFAULT FALSE,\n  updated_at INTEGER DEFAULT (unixepoch() * 1000)\n);\n```\n\nAdd `notifications` table:\n```sql\nCREATE TABLE notifications (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id),\n  type TEXT NOT NULL,\n  title TEXT NOT NULL,\n  body TEXT,\n  data TEXT,  -- JSON payload\n  read_at INTEGER,\n  created_at INTEGER DEFAULT (unixepoch() * 1000)\n);\n```\n\n## Backend\n\n### `apps/worker/src/lib/notifications.ts`\n\n```typescript\nexport async function createNotification(\n  db: DrizzleDB,\n  params: {\n    userId: string;\n    type: NotificationType;\n    title: string;\n    body?: string;\n    data?: Record\u003cstring, unknown\u003e;\n  }\n) {\n  // Check user preferences\n  const prefs = await db.query.userNotificationPreferences.findFirst({\n    where: eq(userNotificationPreferences.userId, params.userId),\n  });\n  \n  const prefKey = getPreferenceKey(params.type);\n  if (prefs \u0026\u0026 prefs[prefKey] === false) {\n    return null; // User disabled this notification type\n  }\n  \n  const notification = await db.insert(notifications).values({\n    id: ulid(),\n    ...params,\n    data: params.data ? JSON.stringify(params.data) : null,\n  }).returning();\n  \n  // TODO: Push notification if enabled\n  \n  return notification;\n}\n```\n\n## Mobile\n\n### `apps/mobile/components/notification-banner.tsx`\n\nIn-app notification banner for connection issues:\n```typescript\nexport function ConnectionIssueBanner() {\n  const { data: connections } = trpc.connections.list.useQuery();\n  const expiredConnections = connections?.filter(c =\u003e c.status === 'EXPIRED');\n  \n  if (!expiredConnections?.length) return null;\n  \n  return (\n    \u003cView className=\"bg-yellow-100 p-3 flex-row items-center\"\u003e\n      \u003cAlertIcon className=\"text-yellow-600\" /\u003e\n      \u003cText className=\"ml-2 flex-1\"\u003e\n        {expiredConnections.length} connection(s) need attention\n      \u003c/Text\u003e\n      \u003cPressable onPress={() =\u003e router.push('/connections')}\u003e\n        \u003cText className=\"text-blue-600\"\u003eFix\u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §7.7","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T20:41:32.004018-06:00","updated_at":"2025-12-16T21:48:01.421537-06:00","closed_at":"2025-12-16T21:48:01.421537-06:00","dependencies":[{"issue_id":"zine-rfy.21","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.004347-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.22","title":"Phase 4.4: Add React Error Boundaries for subscription screens","description":"## Task\nAdd React Error Boundaries for subscription-related screens.\n\n## Error Boundary Component\n\n### `apps/mobile/components/error-boundary.tsx`\n\n```typescript\nimport { Component, ErrorInfo, ReactNode } from 'react';\nimport { View, Text, Pressable } from 'react-native';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) =\u003e void;\n  resetKeys?: unknown[]; // Re-render children when these change\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nexport class ErrorBoundary extends Component\u003cProps, State\u003e {\n  state: State = { hasError: false, error: null };\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('[ErrorBoundary]', error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n    // TODO: Report to error tracking service (Sentry, etc.)\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    // Reset error state when resetKeys change\n    if (this.state.hasError \u0026\u0026 this.props.resetKeys) {\n      const hasKeyChanged = this.props.resetKeys.some(\n        (key, i) =\u003e key !== prevProps.resetKeys?.[i]\n      );\n      if (hasKeyChanged) {\n        this.setState({ hasError: false, error: null });\n      }\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        \u003cView className=\"flex-1 items-center justify-center p-6\"\u003e\n          \u003cText className=\"text-xl mb-2\"\u003eSomething went wrong\u003c/Text\u003e\n          \u003cText className=\"text-gray-500 mb-4 text-center\"\u003e\n            {this.state.error?.message || 'An unexpected error occurred'}\n          \u003c/Text\u003e\n          \u003cPressable\n            onPress={() =\u003e this.setState({ hasError: false, error: null })}\n            className=\"bg-blue-500 px-6 py-3 rounded-lg\"\n          \u003e\n            \u003cText className=\"text-white font-medium\"\u003eTry Again\u003c/Text\u003e\n          \u003c/Pressable\u003e\n        \u003c/View\u003e\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n## Usage in Screens\n\nWrap subscription-related screens:\n```typescript\n// In subscriptions list\n\u003cErrorBoundary \n  onError={(e) =\u003e trackError('subscriptions_list', e)}\n  resetKeys={[userId]}\n\u003e\n  \u003cSubscriptionsList /\u003e\n\u003c/ErrorBoundary\u003e\n\n// In OAuth flow\n\u003cErrorBoundary\n  fallback={\u003cOAuthErrorFallback /\u003e}\n  onError={(e) =\u003e trackError('oauth_flow', e)}\n\u003e\n  \u003cOAuthScreen provider={provider} /\u003e\n\u003c/ErrorBoundary\u003e\n\n// In subscription detail\n\u003cErrorBoundary resetKeys={[subscriptionId]}\u003e\n  \u003cSubscriptionDetail id={subscriptionId} /\u003e\n\u003c/ErrorBoundary\u003e\n```\n\n## Query Error Handling\n\nAlso handle tRPC query errors gracefully:\n```typescript\nfunction SubscriptionsList() {\n  const { data, error, refetch } = trpc.subscriptions.list.useQuery();\n  \n  if (error) {\n    return (\n      \u003cView className=\"flex-1 items-center justify-center\"\u003e\n        \u003cText\u003eFailed to load subscriptions\u003c/Text\u003e\n        \u003cPressable onPress={() =\u003e refetch()}\u003e\n          \u003cText className=\"text-blue-600\"\u003eRetry\u003c/Text\u003e\n        \u003c/Pressable\u003e\n      \u003c/View\u003e\n    );\n  }\n  \n  // ...\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.7","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T20:41:32.066784-06:00","updated_at":"2025-12-16T21:48:01.072329-06:00","closed_at":"2025-12-16T21:48:01.072329-06:00","dependencies":[{"issue_id":"zine-rfy.22","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.067118-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.23","title":"Phase 4.5: Implement offline handling with action queue","description":"## Task\nImplement offline handling with action queue for subscription mutations.\n\n## Offline Queue\n\n### `apps/mobile/lib/offline-queue.ts`\n\n```typescript\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-community/netinfo';\n\ninterface QueuedAction {\n  id: string;\n  type: 'subscribe' | 'unsubscribe' | 'pause' | 'resume';\n  payload: Record\u003cstring, unknown\u003e;\n  createdAt: number;\n  retryCount: number;\n}\n\nconst QUEUE_KEY = 'offline_action_queue';\n\nexport class OfflineQueue {\n  private static instance: OfflineQueue;\n  \n  static getInstance() {\n    if (!this.instance) this.instance = new OfflineQueue();\n    return this.instance;\n  }\n  \n  async enqueue(action: Omit\u003cQueuedAction, 'id' | 'createdAt' | 'retryCount'\u003e) {\n    const queue = await this.getQueue();\n    queue.push({\n      ...action,\n      id: crypto.randomUUID(),\n      createdAt: Date.now(),\n      retryCount: 0,\n    });\n    await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(queue));\n  }\n  \n  async getQueue(): Promise\u003cQueuedAction[]\u003e {\n    const raw = await AsyncStorage.getItem(QUEUE_KEY);\n    return raw ? JSON.parse(raw) : [];\n  }\n  \n  async processQueue() {\n    const isOnline = await NetInfo.fetch().then(s =\u003e s.isConnected);\n    if (!isOnline) return;\n    \n    const queue = await this.getQueue();\n    const remaining: QueuedAction[] = [];\n    \n    for (const action of queue) {\n      try {\n        await this.executeAction(action);\n      } catch (error) {\n        if (action.retryCount \u003c 3) {\n          remaining.push({ ...action, retryCount: action.retryCount + 1 });\n        }\n        // Drop after 3 retries\n      }\n    }\n    \n    await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(remaining));\n  }\n  \n  private async executeAction(action: QueuedAction) {\n    switch (action.type) {\n      case 'subscribe':\n        await trpc.subscriptions.add.mutate(action.payload);\n        break;\n      case 'unsubscribe':\n        await trpc.subscriptions.remove.mutate(action.payload);\n        break;\n      // ... etc\n    }\n  }\n}\n```\n\n## Hook Integration\n\n### `apps/mobile/hooks/use-offline-mutations.ts`\n\n```typescript\nexport function useSubscriptionMutation() {\n  const utils = trpc.useUtils();\n  const queue = OfflineQueue.getInstance();\n  \n  const subscribe = async (params: SubscribeParams) =\u003e {\n    const isOnline = await NetInfo.fetch().then(s =\u003e s.isConnected);\n    \n    if (isOnline) {\n      // Online: execute immediately\n      await trpc.subscriptions.add.mutate(params);\n    } else {\n      // Offline: queue and show optimistic UI\n      await queue.enqueue({ type: 'subscribe', payload: params });\n      // Update local cache optimistically\n      utils.subscriptions.list.setData(undefined, (old) =\u003e [\n        ...(old || []),\n        { ...params, id: `temp-${Date.now()}`, status: 'PENDING' },\n      ]);\n    }\n  };\n  \n  return { subscribe };\n}\n```\n\n## Network Listener\n\nProcess queue when coming back online:\n```typescript\nuseEffect(() =\u003e {\n  const unsubscribe = NetInfo.addEventListener(state =\u003e {\n    if (state.isConnected) {\n      OfflineQueue.getInstance().processQueue();\n    }\n  });\n  return unsubscribe;\n}, []);\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.6","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T20:41:32.128728-06:00","updated_at":"2025-12-16T21:48:00.681985-06:00","closed_at":"2025-12-16T21:48:00.681985-06:00","dependencies":[{"issue_id":"zine-rfy.23","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.129074-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.24","title":"Testing: Unit tests for encryption, transformation, idempotency","description":"## Task\nWrite unit tests for encryption, transformation, and idempotency logic.\n\n## Test Files\n\n### `apps/worker/src/lib/encryption.test.ts`\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { encrypt, decrypt, DecryptionError } from './encryption';\n\ndescribe('encryption', () =\u003e {\n  const TEST_KEY = '0'.repeat(64); // 32 bytes as hex\n  \n  it('encrypts and decrypts round-trip', async () =\u003e {\n    const plaintext = 'secret-oauth-token-12345';\n    const encrypted = await encrypt(plaintext, TEST_KEY);\n    const decrypted = await decrypt(encrypted, TEST_KEY);\n    expect(decrypted).toBe(plaintext);\n  });\n  \n  it('produces versioned format', async () =\u003e {\n    const encrypted = await encrypt('test', TEST_KEY);\n    expect(encrypted).toMatch(/^v1:[a-f0-9]+:[a-f0-9]+$/);\n  });\n  \n  it('produces different ciphertext for same plaintext (random IV)', async () =\u003e {\n    const e1 = await encrypt('same', TEST_KEY);\n    const e2 = await encrypt('same', TEST_KEY);\n    expect(e1).not.toBe(e2);\n  });\n  \n  it('throws DecryptionError for invalid format', async () =\u003e {\n    await expect(decrypt('invalid', TEST_KEY)).rejects.toThrow(DecryptionError);\n  });\n  \n  it('throws DecryptionError for wrong key', async () =\u003e {\n    const encrypted = await encrypt('test', TEST_KEY);\n    const wrongKey = '1'.repeat(64);\n    await expect(decrypt(encrypted, wrongKey)).rejects.toThrow(DecryptionError);\n  });\n});\n```\n\n### `apps/worker/src/lib/transform.test.ts`\n\n```typescript\ndescribe('transformYouTubeVideo', () =\u003e {\n  it('transforms playlist item to canonical Item', () =\u003e {\n    const playlistItem = mockYouTubePlaylistItem();\n    const item = transformYouTubeVideo(playlistItem);\n    \n    expect(item.contentType).toBe('VIDEO');\n    expect(item.provider).toBe('YOUTUBE');\n    expect(item.providerId).toBe(playlistItem.contentDetails.videoId);\n    expect(item.title).toBe(playlistItem.snippet.title);\n  });\n});\n\ndescribe('transformSpotifyEpisode', () =\u003e {\n  it('transforms episode to canonical Item', () =\u003e {\n    const episode = mockSpotifyEpisode();\n    const show = mockSpotifyShow();\n    const item = transformSpotifyEpisode(episode, show);\n    \n    expect(item.contentType).toBe('PODCAST');\n    expect(item.provider).toBe('SPOTIFY');\n    expect(item.duration).toBe(Math.floor(episode.duration_ms / 1000));\n  });\n});\n```\n\n### `apps/worker/src/ingestion/index.test.ts`\n\n```typescript\ndescribe('ingestItem', () =\u003e {\n  it('creates new user_item for unseen item', async () =\u003e {\n    const result = await ingestItem(userId, subscriptionId, mockVideo, 'YOUTUBE', db);\n    expect(result.created).toBe(true);\n    expect(result.userItemId).toBeDefined();\n  });\n  \n  it('skips already-seen items (idempotency)', async () =\u003e {\n    // First ingestion\n    await ingestItem(userId, subscriptionId, mockVideo, 'YOUTUBE', db);\n    // Second ingestion of same item\n    const result = await ingestItem(userId, subscriptionId, mockVideo, 'YOUTUBE', db);\n    expect(result.created).toBe(false);\n  });\n  \n  it('handles race condition for canonical item creation', async () =\u003e {\n    // Simulate concurrent ingestion\n    const [r1, r2] = await Promise.all([\n      ingestItem(user1, sub1, mockVideo, 'YOUTUBE', db),\n      ingestItem(user2, sub2, mockVideo, 'YOUTUBE', db),\n    ]);\n    \n    // Both should succeed, using same canonical item\n    expect(r1.created).toBe(true);\n    expect(r2.created).toBe(true);\n    \n    // Should be same canonical item\n    const items = await db.query.items.findMany({\n      where: eq(items.providerId, mockVideo.id)\n    });\n    expect(items).toHaveLength(1);\n  });\n});\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §8 (Testing)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:32.195745-06:00","updated_at":"2025-12-16T21:47:57.377735-06:00","closed_at":"2025-12-16T21:47:57.377735-06:00","dependencies":[{"issue_id":"zine-rfy.24","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.196078-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.25","title":"Testing: Integration tests for OAuth flow and tRPC endpoints","description":"## Task\nWrite integration tests for OAuth flow and tRPC endpoints.\n\n## Test Files\n\n### `apps/worker/src/trpc/routers/connections.test.ts`\n\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createTestContext } from '../test-utils';\n\ndescribe('connections router', () =\u003e {\n  let ctx: TestContext;\n  \n  beforeEach(async () =\u003e {\n    ctx = await createTestContext();\n  });\n  \n  describe('registerState', () =\u003e {\n    it('stores state in KV', async () =\u003e {\n      const state = crypto.randomUUID();\n      await ctx.caller.connections.registerState({ provider: 'YOUTUBE', state });\n      \n      const stored = await ctx.env.KV.get(`oauth:state:${state}`);\n      expect(stored).toBe(ctx.userId);\n    });\n    \n    it('rate limits excessive requests', async () =\u003e {\n      for (let i = 0; i \u003c 5; i++) {\n        await ctx.caller.connections.registerState({\n          provider: 'YOUTUBE',\n          state: crypto.randomUUID(),\n        });\n      }\n      \n      await expect(\n        ctx.caller.connections.registerState({\n          provider: 'YOUTUBE',\n          state: crypto.randomUUID(),\n        })\n      ).rejects.toThrow('TOO_MANY_REQUESTS');\n    });\n  });\n  \n  describe('callback', () =\u003e {\n    it('exchanges code for tokens and stores encrypted', async () =\u003e {\n      // Setup: register state, mock token exchange\n      const state = crypto.randomUUID();\n      await ctx.env.KV.put(`oauth:state:${state}`, ctx.userId, { expirationTtl: 1800 });\n      \n      mockFetch('https://oauth2.googleapis.com/token', {\n        access_token: 'test-access',\n        refresh_token: 'test-refresh',\n        expires_in: 3600,\n        scope: 'youtube.readonly',\n      });\n      \n      await ctx.caller.connections.callback({\n        provider: 'YOUTUBE',\n        code: 'auth-code',\n        state,\n        codeVerifier: 'a'.repeat(43),\n      });\n      \n      // Verify connection created\n      const connection = await ctx.db.query.providerConnections.findFirst({\n        where: eq(providerConnections.userId, ctx.userId),\n      });\n      expect(connection).toBeDefined();\n      expect(connection!.status).toBe('ACTIVE');\n      expect(connection!.accessToken).not.toBe('test-access'); // Should be encrypted\n    });\n  });\n});\n```\n\n### `apps/worker/src/trpc/routers/subscriptions.test.ts`\n\n```typescript\ndescribe('subscriptions router', () =\u003e {\n  describe('add', () =\u003e {\n    it('creates subscription for connected user', async () =\u003e {\n      // Setup: create active connection\n      await createTestConnection(ctx, 'YOUTUBE');\n      \n      const result = await ctx.caller.subscriptions.add({\n        provider: 'YOUTUBE',\n        providerChannelId: 'UCBJycsmduvYEL83R_U4JriQ',\n        name: 'Test Channel',\n      });\n      \n      expect(result.id).toBeDefined();\n      expect(result.status).toBe('ACTIVE');\n    });\n    \n    it('validates YouTube channel ID format', async () =\u003e {\n      await createTestConnection(ctx, 'YOUTUBE');\n      \n      await expect(\n        ctx.caller.subscriptions.add({\n          provider: 'YOUTUBE',\n          providerChannelId: 'invalid-id',\n        })\n      ).rejects.toThrow('Invalid YouTube channel ID');\n    });\n    \n    it('requires active provider connection', async () =\u003e {\n      // No connection created\n      await expect(\n        ctx.caller.subscriptions.add({\n          provider: 'YOUTUBE',\n          providerChannelId: 'UCBJycsmduvYEL83R_U4JriQ',\n        })\n      ).rejects.toThrow('PRECONDITION_FAILED');\n    });\n  });\n  \n  describe('list', () =\u003e {\n    it('returns paginated subscriptions', async () =\u003e {\n      // Create 60 subscriptions\n      await createTestSubscriptions(ctx, 60);\n      \n      const page1 = await ctx.caller.subscriptions.list({ limit: 50 });\n      expect(page1.items).toHaveLength(50);\n      expect(page1.hasMore).toBe(true);\n      \n      const page2 = await ctx.caller.subscriptions.list({\n        limit: 50,\n        cursor: page1.nextCursor,\n      });\n      expect(page2.items).toHaveLength(10);\n      expect(page2.hasMore).toBe(false);\n    });\n  });\n});\n```\n\n## Test Utilities\n\nCreate shared test utilities:\n```typescript\n// apps/worker/src/trpc/test-utils.ts\nexport async function createTestContext() { /* ... */ }\nexport async function createTestConnection(ctx, provider) { /* ... */ }\nexport async function createTestSubscriptions(ctx, count) { /* ... */ }\nexport function mockFetch(url, response) { /* ... */ }\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §8 (Testing)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:32.261275-06:00","updated_at":"2025-12-16T21:47:56.952898-06:00","closed_at":"2025-12-16T21:47:56.952898-06:00","dependencies":[{"issue_id":"zine-rfy.25","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.261573-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.5","title":"Phase 1.5: Add OAuth rate limiting middleware","description":"## Task\nAdd rate limiting to OAuth endpoints for defense-in-depth protection.\n\n## Rate Limits\n\n| Endpoint        | Window   | Max Requests | Key    |\n|-----------------|----------|--------------|--------|\n| `registerState` | 1 minute | 5            | userId |\n| `callback`      | 1 minute | 10           | userId |\n| `disconnect`    | 1 minute | 3            | userId |\n\n## Implementation\n\n### `apps/worker/src/middleware/rate-limit.ts`\n\n```typescript\ninterface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  keyPrefix: string;\n}\n\nexport async function checkRateLimit(\n  env: Env,\n  config: RateLimitConfig,\n  identifier: string\n): Promise\u003c{ allowed: boolean; remaining: number; resetMs: number }\u003e\n```\n\nUse KV with sliding window counter:\n- Key: `{prefix}:{identifier}`\n- Value: `{ count: number, windowStart: number }`\n- TTL: `windowMs / 1000 + 10` seconds\n\n### Integration\nApply rate limiting in tRPC procedures before business logic:\n```typescript\nconst rateLimit = await checkRateLimit(ctx.env, OAUTH_LIMITS.callback, ctx.userId);\nif (!rateLimit.allowed) {\n  throw new TRPCError({ code: 'TOO_MANY_REQUESTS', ... });\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.2.1","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:30.999218-06:00","updated_at":"2025-12-16T21:47:59.725781-06:00","closed_at":"2025-12-16T21:47:59.725781-06:00","dependencies":[{"issue_id":"zine-rfy.5","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:30.999586-06:00","created_by":"daemon"}]}
