{"id":"zine-12m","title":"Backend Spec Refinements: Subtasks","description":"Subtasks for updating backend-spec.md with review findings. Parent epic: zine-cvh","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T22:28:35.426642-06:00","updated_at":"2025-12-16T22:28:40.803386-06:00","closed_at":"2025-12-16T22:28:40.803386-06:00"}
{"id":"zine-12m.1","title":"Add Current Schema Analysis section to backend-spec.md","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:28:35.489549-06:00","updated_at":"2025-12-17T19:55:37.903933-06:00","closed_at":"2025-12-17T19:55:37.903933-06:00","dependencies":[{"issue_id":"zine-12m.1","depends_on_id":"zine-12m","type":"parent-child","created_at":"2025-12-16T22:28:35.489875-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-12m.2","title":"Add Timestamp Format Bridge section with conversion examples","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:28:35.551701-06:00","updated_at":"2025-12-17T19:55:37.490421-06:00","closed_at":"2025-12-17T19:55:37.490421-06:00","dependencies":[{"issue_id":"zine-12m.2","depends_on_id":"zine-12m","type":"parent-child","created_at":"2025-12-16T22:28:35.552018-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-12m.3","title":"Add user_notifications table schema to Section 1.2","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:28:35.614203-06:00","updated_at":"2025-12-17T19:55:37.071064-06:00","closed_at":"2025-12-17T19:55:37.071064-06:00","dependencies":[{"issue_id":"zine-12m.3","depends_on_id":"zine-12m","type":"parent-child","created_at":"2025-12-16T22:28:35.614514-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-12m.4","title":"Add tRPC Contract section with Zod input/output schemas","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:28:35.677555-06:00","updated_at":"2025-12-17T19:55:36.688004-06:00","closed_at":"2025-12-17T19:55:36.688004-06:00","dependencies":[{"issue_id":"zine-12m.4","depends_on_id":"zine-12m","type":"parent-child","created_at":"2025-12-16T22:28:35.677845-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-12m.5","title":"Clarify initial fetch flow in subscription creation","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:28:35.74082-06:00","updated_at":"2025-12-17T19:55:39.105694-06:00","closed_at":"2025-12-17T19:55:39.105694-06:00","dependencies":[{"issue_id":"zine-12m.5","depends_on_id":"zine-12m","type":"parent-child","created_at":"2025-12-16T22:28:35.741133-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-12m.6","title":"Add rate limiter integration to polling examples","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:28:35.803504-06:00","updated_at":"2025-12-17T19:55:38.741259-06:00","closed_at":"2025-12-17T19:55:38.741259-06:00","dependencies":[{"issue_id":"zine-12m.6","depends_on_id":"zine-12m","type":"parent-child","created_at":"2025-12-16T22:28:35.803858-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-207","title":"Phase 4: Wire navigation from all screens to Item Detail","description":"# Phase 4: Wire Navigation to Item Detail\n\n## What This Task Does\nEnable navigation from item cards across all screens to the Item Detail page:\n- Library screen cards → /item/:id\n- Inbox screen cards → /item/:id\n- Home screen cards → /item/:id\n\n## Why Consolidate?\nThe original plan had 3 separate beads (22, 23, 24). In practice:\n- All three are nearly identical work\n- If using shared ItemCard, navigation is already built-in\n- Can be verified and fixed in a single pass\n- No meaningful reason to do Home before Inbox\n\n## Implementation Notes\n\n### If ItemCard Handles Navigation (preferred)\nItemCard component should have internal useRouter().push() on press.\nThis task becomes verification that all screens use ItemCard correctly.\n\n### Action Button Isolation (Inbox)\nInbox cards have Archive/Bookmark buttons. Ensure:\n- Tapping card body → navigates\n- Tapping action buttons → performs action (no navigation)\nReact Native Pressable nesting handles this naturally.\n\n## Acceptance Criteria\n- [ ] Library cards navigate to detail on tap\n- [ ] Inbox cards navigate to detail on tap (not when tapping actions)\n- [ ] Home cards navigate to detail on tap\n- [ ] Back button returns to originating screen\n- [ ] Correct item.id passed (UserItem ID, not canonical Item ID)\n\n## Dependencies\n- zine-vq9: Item Detail Page must exist\n- zine-qch.4: ItemCard component (handles navigation)\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:35:48.369201-06:00","updated_at":"2025-12-25T22:59:37.217552-06:00","closed_at":"2025-12-25T22:59:37.217552-06:00","dependencies":[{"issue_id":"zine-207","depends_on_id":"zine-vq9","type":"blocks","created_at":"2025-12-25T22:35:55.170654-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-207","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:35:55.339373-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-207","depends_on_id":"zine-qch","type":"blocks","created_at":"2025-12-25T22:35:55.509683-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h","title":"Tech Debt Remediation: Comprehensive Codebase Cleanup (GH-5)","description":"# Tech Debt Remediation Epic\n\n## Source\nGitHub Issue #5: Tech Debt Audit: Comprehensive Codebase Cleanup Required\n\n## Executive Summary\nA comprehensive analysis identified multiple categories of technical debt. This epic orchestrates systematic remediation to improve code quality, maintainability, and reliability.\n\n## Current Status\n- **Total Tasks**: 27\n- **Closed**: 3 (P0.4, P0.5, P3.1)\n- **Open**: 24\n\n## Phased Approach\n\n### Phase 1: Foundation (P0 Tasks - CRITICAL)\nMust be done first - unblocks other work.\n\n| Task | Description | Effort | Status |\n|------|-------------|--------|--------|\n| P0.1 | Delete dead code - routes/sources.ts | 30m | Open |\n| P0.2 | Fix tRPC type exports (11 any casts) | 2-3h | Open |\n| P0.3 | Set up mobile test infrastructure | 2-3h | Open |\n| P0.4 | Implement toggleFinished mutation | - | ✅ Closed |\n| P0.5 | Implement unbookmark mutation | - | ✅ Closed |\n\n**Critical Path**: P0.3 (tests) blocks P1.1 (Home screen split) and all P2 test tasks.\n\n### Phase 2: Consolidation (P1 Tasks - HIGH)\nRemove duplication, prepare for refactoring.\n\n| Task | Description | Effort | Dependencies |\n|------|-------------|--------|--------------|\n| P1.1 | Split index.tsx Home screen (~1041 lines) | 4-5h | P0.3, P1.2 |\n| P1.2 | Consolidate duplicate icons | 1-2h | None |\n| P1.3 | Consolidate UIContentType/mapContentType | 20m | None |\n| P1.4 | Consolidate formatDuration (different impls!) | 30m | None |\n| P1.5 | Consolidate polling processors | 3-4h | Tests exist |\n\n**Quick Wins**: P1.2, P1.3, P1.4 can be done in parallel, ~2 hours total.\n\n### Phase 3: Testing (P2 Tasks - MEDIUM)\nAdd test coverage to enable safe refactoring.\n\n| Task | Description | Effort | Dependencies |\n|------|-------------|--------|--------------|\n| P2.1 | Tests for lib/format.ts | 1-2h | P0.3 |\n| P2.2 | Tests for lib/content-utils.ts | 1-2h | P0.3 |\n| P2.3 | Tests for lib/offline-queue.ts | 4-6h | P0.3 |\n| P2.4 | Tests for use-subscriptions.ts | 4-6h | P0.3 |\n| P2.5 | Tests for polling/health.ts | 3-4h | None (Vitest) |\n| P2.6 | Tests for providers/youtube.ts | 3-4h | None (Vitest) |\n| P2.7 | Tests for providers/spotify.ts | 3-4h | None (Vitest) |\n| P2.8 | Extract magic numbers to constants | 2h | None |\n| P2.9 | Add toast feedback for errors | 2-3h | None |\n| P2.10 | Refactor processQueue (116 lines) | 3-4h | P2.3 |\n| P2.11 | Split select-channels.tsx | 3-4h | P1.2 |\n\n**Parallelization**: P2.5-P2.7 (worker tests) can run in parallel with P2.1-P2.4 (mobile tests).\n\n### Phase 4: Polish (P3 Tasks - LOW)\nNice-to-haves that improve consistency.\n\n| Task | Description | Effort |\n|------|-------------|--------|\n| P3.1 | Remove unused styles | - | ✅ Closed |\n| P3.2 | Standardize provider casing | 2-3h |\n| P3.3 | Unify error boundary components | 2-3h |\n| P3.4 | Add route param validation | 2-3h |\n\n## Dependency Graph (Simplified)\n```\nP0.3 (Test Infra) ─┬─\u003e P1.1 (Home Split)\n                   ├─\u003e P2.1-P2.4 (Mobile Tests)\n                   └─\u003e P2.10 (Queue Refactor) ─\u003e P2.3 (Queue Tests)\n\nP1.2 (Icons) ─┬─\u003e P1.1 (Home Split)\n              └─\u003e P2.11 (Select Channels Split)\n```\n\n## Parallelization Opportunities\n\n### Immediate (No Dependencies)\n- P0.1: Delete dead code\n- P1.2: Consolidate icons\n- P1.3: Consolidate content types\n- P1.4: Consolidate formatDuration\n- P2.5-P2.7: Worker tests (Vitest already set up)\n\n### After P0.3 Complete\n- P2.1-P2.4: Mobile utility and hook tests\n\n### After P1.2 + P0.3 Complete\n- P1.1: Home screen split\n- P2.11: Select channels split\n\n## Risk Notes\n\n1. **P0.2 (tRPC types)**: Already works via relative import, just needs any cast removal\n2. **P1.4 (formatDuration)**: Two DIFFERENT implementations - timestamp vs friendly format\n3. **P1.5 (Polling consolidation)**: Well-tested code, consolidation is optional\n4. **P2.10 (Queue refactor)**: Complex error handling logic, needs tests first\n\n## Success Criteria\n1. Zero `(trpc as any)` patterns\n2. ≥80% test coverage for hooks and utilities\n3. No file exceeds 400 lines\n4. Structured logging with log levels\n5. Consistent code patterns across screens\n\n## Out of Scope\n- New features (covered by separate epics)\n- Performance optimization (premature until debt cleared)\n- UI/UX redesign (separate initiative)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-28T09:49:22.39774-06:00","updated_at":"2025-12-28T10:55:08.606101-06:00"}
{"id":"zine-b4h.1","title":"P0.1: Delete dead code - routes/sources.ts stub endpoints","description":"# P0.1: Delete Dead Code - routes/sources.ts Stub Endpoints\n\n## Problem Statement\n`apps/worker/src/routes/sources.ts` contains **150 lines of completely unimplemented stub endpoints** with TODO comments. This file has 6 endpoints that return placeholder responses and duplicate functionality already implemented in the tRPC `subscriptions` router.\n\n## Evidence\n```typescript\n// Current state (apps/worker/src/routes/sources.ts)\napp.get('/sources', (c) =\u003e {\n  // TODO: Implement list sources\n  return c.json({ sources: [] });\n});\n\napp.post('/sources', (c) =\u003e {\n  // TODO: Implement create source\n  return c.json({ id: 'stub' });\n});\n// ... 4 more unimplemented endpoints\n```\n\n## Why This Must Be Fixed (P0)\n\n### Confusion Risk\n- Developers may call these endpoints thinking they work\n- API documentation becomes inaccurate\n- Two \"source of truth\" for similar functionality\n\n### Maintenance Burden\n- Dead code must be reviewed in PRs\n- TypeScript still compiles it\n- Test coverage metrics are skewed\n\n### Already Implemented Elsewhere\nThe tRPC `subscriptions` router already provides:\n- `subscriptions.list` - List user's subscriptions\n- `subscriptions.add` - Create subscription\n- `subscriptions.remove` - Delete subscription\n- `subscriptions.pause/resume` - Status changes\n\n## Implementation Steps\n\n1. **Verify tRPC coverage**: Confirm all functionality exists in tRPC routers\n2. **Remove file**: Delete `apps/worker/src/routes/sources.ts`\n3. **Remove registration**: Update `apps/worker/src/index.ts` to remove Hono route registration\n4. **Search for usages**: Grep for any references to `/sources` endpoints\n5. **Update docs**: Remove any documentation referencing these endpoints\n\n## Files to Modify\n- DELETE: `apps/worker/src/routes/sources.ts`\n- MODIFY: `apps/worker/src/index.ts` (remove route registration)\n\n## Acceptance Criteria\n- [ ] File `routes/sources.ts` no longer exists\n- [ ] No Hono routes registered for `/sources*`\n- [ ] Worker builds and deploys successfully\n- [ ] tRPC subscriptions endpoints still functional\n- [ ] No orphan imports or references\n\n## Risk Assessment\n**Low risk**: These endpoints are not functional and likely not used. If anything calls them, it's already broken.\n\n## Estimated Effort\n30 minutes","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-28T09:49:22.592968-06:00","updated_at":"2025-12-28T11:59:14.714723-06:00","closed_at":"2025-12-28T11:59:14.714723-06:00","close_reason":"Deleted routes/sources.ts (150 lines of dead stub code) and removed route registration from index.ts. tRPC sources and subscriptions routers already provide the needed functionality.","dependencies":[{"issue_id":"zine-b4h.1","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:22.593385-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.10","title":"P1.5: Consolidate polling batch processors (processYouTubeBatch/processSpotifyBatch)","description":"# P1.5: Consolidate Polling Batch Processors\n\n## Problem Statement\n`apps/worker/src/polling/scheduler.ts` contains two structurally similar functions:\n- `processYouTubeBatch()` (lines 182-263)\n- `processSpotifyBatch()` (lines 356-437)\n\nBoth follow the same pattern: group by user, check rate limits, get connection, process subscriptions.\n\n## Evidence\nBoth functions share ~80% structural similarity:\n1. Group subscriptions by user (`groupBy(subs, 'userId')`)\n2. Check rate limits (`isRateLimited`)\n3. Get provider connection from DB\n4. Create provider client\n5. Process each subscription with provider-specific function\n6. Handle auth errors at user level\n\nThe key differences are:\n- Provider-specific client creation (`getYouTubeClientForConnection` vs `getSpotifyClientForConnection`)\n- Provider-specific single-subscription polling (`pollSingleYouTubeSubscription` vs `pollSingleSpotifySubscription`)\n\n## Analysis: Is Consolidation Worth It?\n\n### Pros of Consolidation\n- Single control flow to maintain\n- Easier to add new providers\n- Bug fixes apply to both\n\n### Cons of Consolidation\n- Provider-specific error handling may diverge (YouTube quota vs Spotify rate limits)\n- The file already has tests (`scheduler.test.ts` - 27KB) that would need updating\n- Generic abstraction may be harder to debug\n\n### Recommendation\n**Low priority to consolidate** - The current code is:\n1. Well-tested (27KB of tests exist)\n2. Clear and readable\n3. Provider differences are isolated in single-subscription functions\n\nA better approach may be to **extract shared utilities** rather than a generic processor:\n- `processUserBatch(userId, subs, getClient, pollSingle)` helper\n- Keep provider-specific wrappers for clarity\n\n## Implementation (If Proceeding)\n\n### Option A: Extract Shared Helper (Recommended)\n```typescript\nasync function processProviderUserBatch\u003cTClient\u003e(\n  userId: string,\n  userSubs: Subscription[],\n  provider: 'YOUTUBE' | 'SPOTIFY',\n  getClient: (conn: ProviderConnection) =\u003e Promise\u003cTClient\u003e,\n  pollSingle: (sub: Subscription, client: TClient) =\u003e Promise\u003c{ newItems: number }\u003e,\n  env: Bindings,\n  db: DrizzleDB\n): Promise\u003cBatchResult\u003e {\n  // Shared rate limiting, connection lookup, error handling\n}\n```\n\n### Option B: Full Generic (More Complex)\nCreate `ProviderConfig` interface and dispatch table.\n\n## Files to Modify\n- `apps/worker/src/polling/scheduler.ts`\n- `apps/worker/src/polling/scheduler.test.ts` (update tests)\n\n## Dependencies\n- Consider after worker test coverage is improved\n\n## Acceptance Criteria\n- [ ] Reduced code duplication in batch processing\n- [ ] All existing tests pass\n- [ ] Easy to add third provider (e.g., RSS)\n- [ ] No performance regression\n\n## Risk Assessment\n**Medium risk** - Existing tests provide safety net, but refactoring tested code requires care.\n\n## Estimated Effort\n3-4 hours (including test updates)\n\n## Priority Reassessment\nConsider downgrading to P2 - the code works, is tested, and duplication is manageable.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:24.361491-06:00","updated_at":"2025-12-28T10:51:17.254775-06:00","dependencies":[{"issue_id":"zine-b4h.10","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:24.361864-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.11","title":"P1.6: Replace console.log with structured logger","description":"# P1.6: Replace console.log with Structured Logger\n\n## Problem Statement\nThe codebase has **many console.log statements** scattered across both worker and mobile apps:\n\n### Worker (apps/worker/src/)\n- `polling/scheduler.ts` - 15+ console.log/error for polling status\n- `polling/health.ts` - Health check logging  \n- `ingestion/processor.ts` - Ingestion status\n- `providers/youtube.ts` - API debugging\n- `providers/spotify.ts` - API debugging\n\n### Mobile (apps/mobile/)\n- `lib/offline-queue.ts` - 15+ console.log/warn/error for queue operations\n- Various hooks and components\n\n## Why This Matters (P2, not P1)\n\n### Production Issues\n- All logs appear at same level\n- No filtering capability\n- No structured data for analysis\n- Console logs don't persist in Cloudflare Workers\n\n### Recommended Approach by Platform\n\n#### Worker: Use Cloudflare's built-in logging\nCloudflare Workers have `console.log` that goes to Workers Logs. For structured logging:\n```typescript\n// Simple structured logger for Workers\nexport const logger = {\n  info: (msg: string, data?: Record\u003cstring, unknown\u003e) =\u003e \n    console.log(JSON.stringify({ level: 'info', msg, ...data, ts: Date.now() })),\n  error: (msg: string, data?: Record\u003cstring, unknown\u003e) =\u003e \n    console.error(JSON.stringify({ level: 'error', msg, ...data, ts: Date.now() })),\n  // ...\n};\n```\n\n#### Mobile: Use React Native logging best practices\n- Development: Keep console.log for debugging\n- Production: Use a logging service or structured logger\n- Consider `react-native-logs` or similar\n\n## Implementation\n\n### Phase 1: Create Logger Modules\n- `apps/worker/src/lib/logger.ts` - Structured JSON logger\n- `apps/mobile/lib/logger.ts` - Development-aware logger\n\n### Phase 2: Replace console.* calls\nMechanical replacement across files.\n\n### Phase 3: Add log levels to environment\n```typescript\n// Worker\nconst LOG_LEVEL = env.LOG_LEVEL || 'info';\n```\n\n## Files to Create\n- `apps/worker/src/lib/logger.ts`\n- `apps/mobile/lib/logger.ts`\n\n## Files to Modify (many)\nAll files currently using console.log/error/warn\n\n## Acceptance Criteria\n- [ ] Logger module for worker\n- [ ] Logger module for mobile\n- [ ] Structured JSON output in worker logs\n- [ ] Log levels respected\n- [ ] No raw console.log for non-debug purposes\n- [ ] Sensitive data not logged (PII check)\n\n## Priority Reassessment\nThis is more of a **P2** task:\n- Current logging works\n- No production issues reported\n- Enhancement rather than critical fix\n\n## Estimated Effort\n4-6 hours (mostly mechanical replacement)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:24.558856-06:00","updated_at":"2025-12-28T10:54:03.884727-06:00","dependencies":[{"issue_id":"zine-b4h.11","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:24.559258-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.12","title":"P1.7: Standardize timestamp format (ISO8601 vs Unix ms)","description":"# P1.7: Standardize Timestamp Format (ISO8601 vs Unix ms)\n\n## Problem Statement\nThe codebase mixes two timestamp formats inconsistently:\n\n| Tables | Format | Example |\n|--------|--------|---------|\n| `users.createdAt` | TEXT (ISO8601) | `\"2024-01-15T10:00:00.000Z\"` |\n| `subscriptions.createdAt` | INTEGER (Unix ms) | `1705312800000` |\n\nThis creates conversion bugs at every boundary.\n\n## Evidence\nFrom `apps/worker/src/db/schema.ts`:\n```typescript\n// ISO8601 tables\nusers.createdAt: text('created_at')\nitems.publishedAt: text('published_at')\nuserItems.ingestedAt: text('ingested_at')\n\n// Unix ms tables\nsubscriptions.createdAt: integer('created_at')\nproviderConnections.connectedAt: integer('connected_at')\n```\n\n## Why This Matters (P1)\n\n### Conversion Errors\nEvery join or comparison across formats requires explicit conversion.\n\n### API Inconsistency\nFrontend receives mixed formats, must handle both.\n\n### New Code Confusion\nDevelopers don't know which format to use.\n\n## The Decision (Already Made)\nPer `features/subscriptions/backend-spec.md`:\n- **Existing tables**: ISO8601 strings (for backwards compatibility)\n- **New subscription tables**: Unix ms (matches JS Date.now(), efficient comparisons)\n\n## Implementation\n\n### Document the Convention\nCreate explicit documentation:\n```markdown\n## Timestamp Convention\n\n### ISO8601 Tables (Legacy)\nTables: users, items, user_items, sources, provider_items_seen\nFormat: \"2024-01-15T10:00:00.000Z\"\nReason: Original schema, backwards compatible\n\n### Unix Milliseconds Tables (New)\nTables: provider_connections, subscriptions, subscription_items, user_notifications\nFormat: 1705312800000\nReason: Efficient comparisons, matches Date.now()\n\n### Conversion Patterns\n```typescript\n// ISO → Unix\nconst unixMs = new Date(isoString).getTime();\n\n// Unix → ISO\nconst isoString = new Date(unixMs).toISOString();\n```\n```\n\n### Add Helper Functions\n```typescript\n// apps/worker/src/lib/timestamps.ts\nexport function isoToUnix(iso: string): number {\n  return new Date(iso).getTime();\n}\n\nexport function unixToIso(unix: number): string {\n  return new Date(unix).toISOString();\n}\n\nexport function nowUnix(): number {\n  return Date.now();\n}\n\nexport function nowIso(): string {\n  return new Date().toISOString();\n}\n```\n\n### Update Ingestion Pipeline\nEnsure ingestion code converts correctly when writing across formats.\n\n## Files to Create\n- `docs/timestamp-convention.md`\n- `apps/worker/src/lib/timestamps.ts`\n\n## Files to Modify\n- `apps/worker/src/ingestion/processor.ts` - Use helper functions\n- Any files doing manual conversions\n\n## Acceptance Criteria\n- [ ] Convention documented\n- [ ] Helper functions created\n- [ ] All conversions use helpers\n- [ ] No inline Date.now().toString() patterns\n- [ ] Ingestion correctly bridges formats\n\n## Note\nThis task does NOT migrate existing data. That would be a separate, more risky task.\n\n## Estimated Effort\n2-3 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:24.757141-06:00","updated_at":"2025-12-28T10:32:07.273987-06:00","dependencies":[{"issue_id":"zine-b4h.12","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:24.757562-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.13","title":"P2.1: Add tests for lib/format.ts","description":"# P2.1: Add Tests for lib/format.ts\n\n## Overview\nAdd comprehensive unit tests for `apps/mobile/lib/format.ts` - the formatting utility module.\n\n## Why This File First\n- **Pure functions**: No side effects, no mocking needed\n- **Easy wins**: High test coverage with minimal effort\n- **Foundation**: Other tests may use these utilities\n\n## Functions to Test\n\n### formatDuration(seconds)\n```typescript\ndescribe('formatDuration', () =\u003e {\n  it('formats hours and minutes', () =\u003e {\n    expect(formatDuration(3723)).toBe('1h 2m');\n    expect(formatDuration(7200)).toBe('2h 0m');\n  });\n  \n  it('formats minutes only', () =\u003e {\n    expect(formatDuration(2700)).toBe('45m');\n    expect(formatDuration(60)).toBe('1m');\n  });\n  \n  it('formats seconds for short durations', () =\u003e {\n    expect(formatDuration(45)).toBe('45s');\n    expect(formatDuration(1)).toBe('1s');\n  });\n  \n  it('handles edge cases', () =\u003e {\n    expect(formatDuration(0)).toBe('0s');\n    expect(formatDuration(null)).toBe('');\n    expect(formatDuration(undefined)).toBe('');\n  });\n});\n```\n\n### formatRelativeTime(dateString)\n```typescript\ndescribe('formatRelativeTime', () =\u003e {\n  const now = new Date('2024-01-15T12:00:00Z');\n  \n  beforeEach(() =\u003e {\n    jest.useFakeTimers().setSystemTime(now);\n  });\n  \n  afterEach(() =\u003e {\n    jest.useRealTimers();\n  });\n  \n  it('formats seconds ago', () =\u003e {\n    const thirtySecsAgo = new Date(now.getTime() - 30000).toISOString();\n    expect(formatRelativeTime(thirtySecsAgo)).toBe('30s ago');\n  });\n  \n  it('formats minutes ago', () =\u003e {\n    const fiveMinAgo = new Date(now.getTime() - 5 * 60000).toISOString();\n    expect(formatRelativeTime(fiveMinAgo)).toBe('5m ago');\n  });\n  \n  it('formats hours ago', () =\u003e {\n    const twoHoursAgo = new Date(now.getTime() - 2 * 3600000).toISOString();\n    expect(formatRelativeTime(twoHoursAgo)).toBe('2h ago');\n  });\n  \n  it('formats days ago', () =\u003e {\n    const threeDaysAgo = new Date(now.getTime() - 3 * 86400000).toISOString();\n    expect(formatRelativeTime(threeDaysAgo)).toBe('3d ago');\n  });\n  \n  it('handles null/undefined', () =\u003e {\n    expect(formatRelativeTime(null)).toBe('');\n    expect(formatRelativeTime(undefined)).toBe('');\n  });\n});\n```\n\n## Files to Create\n- `apps/mobile/lib/format.test.ts`\n\n## Dependencies\n- P0.3 (Test infrastructure) must be complete\n\n## Acceptance Criteria\n- [ ] All functions in format.ts tested\n- [ ] Edge cases covered (null, undefined, 0)\n- [ ] Time-based tests use fake timers\n- [ ] 100% code coverage for format.ts\n\n## Estimated Effort\n1-2 hours","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:24.954737-06:00","updated_at":"2025-12-28T12:11:13.73014-06:00","closed_at":"2025-12-28T12:11:13.73014-06:00","close_reason":"Completed as part of P0.3 - format.test.ts created with 41 comprehensive tests.","dependencies":[{"issue_id":"zine-b4h.13","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:24.955153-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.13","depends_on_id":"zine-b4h.3","type":"blocks","created_at":"2025-12-28T09:58:18.420894-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.14","title":"P2.2: Add tests for lib/content-utils.ts","description":"# P2.2: Add Tests for lib/content-utils.ts\n\n## Overview\nAdd unit tests for `apps/mobile/lib/content-utils.ts` - content type utilities.\n\n## Functions to Test\n\n### mapContentType\n```typescript\ndescribe('mapContentType', () =\u003e {\n  it('maps uppercase to lowercase', () =\u003e {\n    expect(mapContentType('VIDEO')).toBe('video');\n    expect(mapContentType('PODCAST')).toBe('podcast');\n    expect(mapContentType('ARTICLE')).toBe('article');\n  });\n  \n  it('handles already lowercase', () =\u003e {\n    expect(mapContentType('video')).toBe('video');\n  });\n  \n  it('defaults unknown types to article', () =\u003e {\n    expect(mapContentType('UNKNOWN')).toBe('article');\n    expect(mapContentType('')).toBe('article');\n  });\n});\n```\n\n### getContentIcon\n```typescript\ndescribe('getContentIcon', () =\u003e {\n  it('returns correct icon for each type', () =\u003e {\n    const videoIcon = getContentIcon('video', 24, '#000');\n    expect(videoIcon.type).toBe(VideoIcon);\n    \n    const podcastIcon = getContentIcon('podcast', 24, '#000');\n    expect(podcastIcon.type).toBe(HeadphonesIcon);\n  });\n  \n  it('defaults to article icon', () =\u003e {\n    const icon = getContentIcon('unknown', 24, '#000');\n    expect(icon.type).toBe(ArticleIcon);\n  });\n});\n```\n\n### getProviderColor\n```typescript\ndescribe('getProviderColor', () =\u003e {\n  it('returns YouTube red', () =\u003e {\n    expect(getProviderColor('YOUTUBE')).toBe('#FF0000');\n  });\n  \n  it('returns Spotify green', () =\u003e {\n    expect(getProviderColor('SPOTIFY')).toBe('#1DB954');\n  });\n  \n  it('returns default color for unknown', () =\u003e {\n    expect(getProviderColor('UNKNOWN')).toBe('#6366F1');\n  });\n});\n```\n\n### getContentAspectRatio\n```typescript\ndescribe('getContentAspectRatio', () =\u003e {\n  it('returns 1:1 for podcasts', () =\u003e {\n    expect(getContentAspectRatio('podcast')).toBe(1);\n  });\n  \n  it('returns 16:9 for videos', () =\u003e {\n    expect(getContentAspectRatio('video')).toBeCloseTo(1.777, 2);\n  });\n  \n  it('returns 16:10 for articles', () =\u003e {\n    expect(getContentAspectRatio('article')).toBe(1.6);\n  });\n});\n```\n\n## Files to Create\n- `apps/mobile/lib/content-utils.test.ts`\n\n## Dependencies\n- P0.3 (Test infrastructure)\n- P1.3 (Content-utils consolidation) - should be done first\n\n## Acceptance Criteria\n- [ ] All exported functions tested\n- [ ] Type mappings verified\n- [ ] Color values verified\n- [ ] Aspect ratios verified\n- [ ] Edge cases handled\n\n## Estimated Effort\n1-2 hours","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:25.159351-06:00","updated_at":"2025-12-28T12:14:43.026084-06:00","closed_at":"2025-12-28T12:14:43.026084-06:00","close_reason":"Completed: Added 45 tests for content-utils.ts covering type mapping, color helpers, label helpers, and aspect ratio helpers. Total test count now 86.","dependencies":[{"issue_id":"zine-b4h.14","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:25.159744-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.14","depends_on_id":"zine-b4h.3","type":"blocks","created_at":"2025-12-28T09:58:18.646467-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.15","title":"P2.3: Add tests for lib/offline-queue.ts","description":"# P2.3: Add Tests for lib/offline-queue.ts\n\n## Overview\nAdd comprehensive tests for the offline action queue - a critical piece of the offline-first architecture.\n\n## Why This is Important\nThe offline queue handles:\n- Persisting actions to AsyncStorage\n- Retry logic with exponential backoff\n- Error classification (network, auth, conflict, client, server)\n- Queue processing when online\n\nA bug here could cause:\n- Lost user actions\n- Infinite retry loops\n- Stale data\n\n## Test Categories\n\n### 1. Queue Operations\n```typescript\ndescribe('OfflineActionQueue', () =\u003e {\n  beforeEach(async () =\u003e {\n    await AsyncStorage.clear();\n  });\n  \n  describe('enqueue', () =\u003e {\n    it('adds action to queue with ULID', async () =\u003e {\n      const id = await queue.enqueue({ type: 'SUBSCRIBE', payload: { id: '123' } });\n      expect(id).toMatch(/^[0-9A-Z]{26}$/); // ULID format\n    });\n    \n    it('persists to AsyncStorage', async () =\u003e {\n      await queue.enqueue({ type: 'SUBSCRIBE', payload: {} });\n      const stored = await AsyncStorage.getItem('zine:offline_action_queue');\n      expect(JSON.parse(stored!)).toHaveLength(1);\n    });\n    \n    it('orders by ULID (creation time)', async () =\u003e {\n      await queue.enqueue({ type: 'SUBSCRIBE', payload: { order: 1 } });\n      await queue.enqueue({ type: 'SUBSCRIBE', payload: { order: 2 } });\n      const actions = await queue.getQueue();\n      expect(actions[0].payload.order).toBe(1);\n    });\n  });\n  \n  describe('getQueue', () =\u003e {\n    it('returns empty array when empty', async () =\u003e {\n      const actions = await queue.getQueue();\n      expect(actions).toEqual([]);\n    });\n  });\n  \n  describe('getPendingCount', () =\u003e {\n    it('returns correct count', async () =\u003e {\n      await queue.enqueue({ type: 'SUBSCRIBE', payload: {} });\n      await queue.enqueue({ type: 'UNSUBSCRIBE', payload: {} });\n      expect(await queue.getPendingCount()).toBe(2);\n    });\n  });\n});\n```\n\n### 2. Error Classification\n```typescript\ndescribe('classifyError', () =\u003e {\n  it('classifies network errors', () =\u003e {\n    const error = new TypeError('Network request failed');\n    expect(classifyError(error)).toBe('NETWORK');\n  });\n  \n  it('classifies auth errors', () =\u003e {\n    const error = { data: { code: 'UNAUTHORIZED' } };\n    expect(classifyError(error)).toBe('AUTH');\n  });\n  \n  it('classifies conflict errors (409)', () =\u003e {\n    const error = { status: 409 };\n    expect(classifyError(error)).toBe('CONFLICT');\n  });\n  \n  it('classifies server errors (5xx)', () =\u003e {\n    const error = { status: 500 };\n    expect(classifyError(error)).toBe('SERVER');\n  });\n});\n```\n\n### 3. Retry Logic\n```typescript\ndescribe('isRetryable', () =\u003e {\n  it('retries network errors up to MAX_RETRIES', () =\u003e {\n    const action = { retryCount: 2 };\n    expect(isRetryableError('NETWORK', action)).toBe(true);\n  });\n  \n  it('stops retrying after MAX_RETRIES', () =\u003e {\n    const action = { retryCount: 4 }; // \u003e MAX_RETRIES (3)\n    expect(isRetryableError('NETWORK', action)).toBe(false);\n  });\n  \n  it('retries auth errors once', () =\u003e {\n    const action = { authRetryCount: 0 };\n    expect(isRetryableError('AUTH', action)).toBe(true);\n  });\n  \n  it('does not retry conflicts', () =\u003e {\n    expect(isRetryableError('CONFLICT', {})).toBe(false);\n  });\n});\n```\n\n### 4. Queue Processing\n```typescript\ndescribe('processQueue', () =\u003e {\n  it('processes actions in order', async () =\u003e {\n    // Setup mock tRPC client\n    // Enqueue actions\n    // Process queue\n    // Verify order of execution\n  });\n  \n  it('removes successful actions', async () =\u003e {\n    // Enqueue action\n    // Mock success\n    // Process\n    // Verify removed\n  });\n  \n  it('keeps failed retryable actions', async () =\u003e {\n    // Enqueue action\n    // Mock network error\n    // Process\n    // Verify still in queue with incremented retryCount\n  });\n  \n  it('removes non-retryable failures', async () =\u003e {\n    // Enqueue action\n    // Mock 409 conflict\n    // Process\n    // Verify removed\n  });\n});\n```\n\n## Mocking Strategy\n- Mock AsyncStorage with jest/async-storage-mock\n- Mock tRPC client for mutation calls\n- Mock network status\n\n## Files to Create\n- `apps/mobile/lib/offline-queue.test.ts`\n\n## Dependencies\n- P0.3 (Test infrastructure)\n- P2.10 (Refactor processQueue) - may want to test after refactor\n\n## Acceptance Criteria\n- [ ] Queue CRUD operations tested\n- [ ] Error classification tested\n- [ ] Retry logic verified\n- [ ] Queue processing end-to-end tested\n- [ ] Subscription pattern tested\n- [ ] ≥80% code coverage\n\n## Estimated Effort\n4-6 hours (complex module)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:25.357605-06:00","updated_at":"2025-12-28T09:54:11.891357-06:00","dependencies":[{"issue_id":"zine-b4h.15","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:25.357997-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.15","depends_on_id":"zine-b4h.3","type":"blocks","created_at":"2025-12-28T09:58:18.85229-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.16","title":"P2.4: Add tests for hooks/use-subscriptions.ts","description":"# P2.4: Add Tests for hooks/use-subscriptions.ts\n\n## Overview\nAdd tests for the `useSubscriptions` hook - the most complex hook with optimistic updates and rollback logic.\n\n## Why This is Critical\nThis hook has:\n- 11 `any` casts (will be removed by P0.2)\n- Complex optimistic update logic\n- Rollback on error\n- Multiple mutation methods\n\nUntested, any change here risks breaking subscriptions.\n\n## Test Categories\n\n### 1. Query Behavior\n```typescript\ndescribe('useSubscriptions', () =\u003e {\n  it('returns loading state initially', () =\u003e {\n    const { result } = renderHook(() =\u003e useSubscriptions());\n    expect(result.current.isLoading).toBe(true);\n  });\n  \n  it('returns subscriptions data', async () =\u003e {\n    mockTRPC.subscriptions.list.useQuery.mockReturnValue({\n      data: { items: [mockSubscription] },\n      isLoading: false,\n    });\n    \n    const { result } = renderHook(() =\u003e useSubscriptions());\n    expect(result.current.subscriptions).toHaveLength(1);\n  });\n});\n```\n\n### 2. Subscribe Mutation\n```typescript\ndescribe('subscribe', () =\u003e {\n  it('optimistically adds subscription', async () =\u003e {\n    const { result } = renderHook(() =\u003e useSubscriptions());\n    \n    act(() =\u003e {\n      result.current.subscribe({ provider: 'YOUTUBE', channelId: '123' });\n    });\n    \n    // Verify optimistic update happened\n    expect(result.current.subscriptions).toContainEqual(\n      expect.objectContaining({ providerChannelId: '123', status: 'ACTIVE' })\n    );\n  });\n  \n  it('rolls back on error', async () =\u003e {\n    mockMutate.mockRejectedValue(new Error('Failed'));\n    \n    const { result } = renderHook(() =\u003e useSubscriptions());\n    const originalSubs = [...result.current.subscriptions];\n    \n    await act(async () =\u003e {\n      await result.current.subscribe({ provider: 'YOUTUBE', channelId: '123' });\n    });\n    \n    expect(result.current.subscriptions).toEqual(originalSubs);\n  });\n});\n```\n\n### 3. Unsubscribe Mutation\n```typescript\ndescribe('unsubscribe', () =\u003e {\n  it('optimistically removes subscription', async () =\u003e {\n    const { result } = renderHook(() =\u003e useSubscriptions());\n    \n    act(() =\u003e {\n      result.current.unsubscribe('sub-123');\n    });\n    \n    expect(result.current.subscriptions).not.toContainEqual(\n      expect.objectContaining({ id: 'sub-123' })\n    );\n  });\n});\n```\n\n### 4. Pause/Resume Mutations\n```typescript\ndescribe('pause', () =\u003e {\n  it('optimistically sets status to PAUSED', async () =\u003e {\n    // Similar pattern\n  });\n});\n\ndescribe('resume', () =\u003e {\n  it('optimistically sets status to ACTIVE', async () =\u003e {\n    // Similar pattern\n  });\n});\n```\n\n## Mocking Setup\n```typescript\njest.mock('@/lib/trpc', () =\u003e ({\n  trpc: {\n    subscriptions: {\n      list: { useQuery: jest.fn() },\n      add: { useMutation: jest.fn() },\n      remove: { useMutation: jest.fn() },\n      pause: { useMutation: jest.fn() },\n      resume: { useMutation: jest.fn() },\n    },\n    useUtils: jest.fn(() =\u003e ({\n      subscriptions: {\n        list: {\n          cancel: jest.fn(),\n          getData: jest.fn(),\n          setData: jest.fn(),\n          invalidate: jest.fn(),\n        },\n      },\n    })),\n  },\n}));\n```\n\n## Files to Create\n- `apps/mobile/hooks/use-subscriptions.test.ts`\n\n## Dependencies\n- P0.3 (Test infrastructure)\n- P0.2 (tRPC types) - testing will be easier with proper types\n\n## Acceptance Criteria\n- [ ] Query states tested (loading, error, success)\n- [ ] All mutations tested\n- [ ] Optimistic updates verified\n- [ ] Rollback behavior verified\n- [ ] ≥80% code coverage\n\n## Estimated Effort\n4-6 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:25.5541-06:00","updated_at":"2025-12-28T09:54:30.016261-06:00","dependencies":[{"issue_id":"zine-b4h.16","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:25.55448-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.16","depends_on_id":"zine-b4h.3","type":"blocks","created_at":"2025-12-28T09:58:19.046645-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.17","title":"P2.5: Add tests for polling/health.ts","description":"# P2.5: Add Tests for polling/health.ts\n\n## Overview\nAdd tests for the connection health monitoring module in the worker.\n\n## File Under Test\n`apps/worker/src/polling/health.ts`\n\n## Key Functions to Test\n\n### checkConnectionHealth\n```typescript\ndescribe('checkConnectionHealth', () =\u003e {\n  it('returns ACTIVE for healthy connection', async () =\u003e {\n    // Mock connection with valid token\n    // Mock successful API call\n    const status = await checkConnectionHealth(connection, env);\n    expect(status).toBe('ACTIVE');\n  });\n  \n  it('returns EXPIRED when token refresh fails', async () =\u003e {\n    // Mock connection with expired token\n    // Mock failed refresh\n    const status = await checkConnectionHealth(connection, env);\n    expect(status).toBe('EXPIRED');\n  });\n  \n  it('returns REVOKED when provider returns 403', async () =\u003e {\n    // Mock 403 response from provider\n    const status = await checkConnectionHealth(connection, env);\n    expect(status).toBe('REVOKED');\n  });\n});\n```\n\n### updateConnectionStatus\n```typescript\ndescribe('updateConnectionStatus', () =\u003e {\n  it('updates status in database', async () =\u003e {\n    await updateConnectionStatus(connectionId, 'EXPIRED', db);\n    \n    const updated = await db.query.providerConnections.findFirst({\n      where: eq(providerConnections.id, connectionId),\n    });\n    expect(updated?.status).toBe('EXPIRED');\n  });\n  \n  it('creates notification for expired connection', async () =\u003e {\n    await updateConnectionStatus(connectionId, 'EXPIRED', db);\n    \n    const notification = await db.query.userNotifications.findFirst({\n      where: and(\n        eq(userNotifications.userId, userId),\n        eq(userNotifications.type, 'connection_expired'),\n      ),\n    });\n    expect(notification).toBeDefined();\n  });\n});\n```\n\n### recordPollFailure\n```typescript\ndescribe('recordPollFailure', () =\u003e {\n  it('increments failure count in KV', async () =\u003e {\n    await recordPollFailure(subscriptionId, env);\n    await recordPollFailure(subscriptionId, env);\n    await recordPollFailure(subscriptionId, env);\n    \n    const count = await getFailureCount(subscriptionId, env);\n    expect(count).toBe(3);\n  });\n  \n  it('triggers notification after 3 failures', async () =\u003e {\n    // Record 3 failures\n    await recordPollFailure(subscriptionId, env);\n    await recordPollFailure(subscriptionId, env);\n    await recordPollFailure(subscriptionId, env);\n    \n    // Check notification created\n    const notification = await db.query.userNotifications.findFirst({\n      where: eq(userNotifications.type, 'poll_failures'),\n    });\n    expect(notification).toBeDefined();\n  });\n});\n```\n\n## Mocking Strategy\n- Mock Cloudflare D1 database\n- Mock KV namespace\n- Mock provider API responses\n\n## Files to Create\n- `apps/worker/src/polling/health.test.ts`\n\n## Dependencies\n- Vitest configured for workers\n- Mock utilities for D1/KV\n\n## Acceptance Criteria\n- [ ] All health check scenarios tested\n- [ ] Status transitions verified\n- [ ] Notification creation tested\n- [ ] Failure counting tested\n- [ ] ≥80% code coverage\n\n## Estimated Effort\n3-4 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:25.750906-06:00","updated_at":"2025-12-28T09:56:49.782433-06:00","dependencies":[{"issue_id":"zine-b4h.17","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:25.751345-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.18","title":"P2.6: Add tests for providers/youtube.ts","description":"# P2.6: Add Tests for providers/youtube.ts\n\n## Overview\nAdd tests for the YouTube provider module.\n\n## File Under Test\n`apps/worker/src/providers/youtube.ts`\n\n## Key Functions to Test\n\n### getYouTubeClient\n```typescript\ndescribe('getYouTubeClient', () =\u003e {\n  it('creates client with decrypted access token', async () =\u003e {\n    const client = await getYouTubeClient(connection, env);\n    expect(client.auth.accessToken).toBe('decrypted-token');\n  });\n  \n  it('refreshes token if expired', async () =\u003e {\n    const expiredConnection = { ...connection, tokenExpiresAt: Date.now() - 1000 };\n    await getYouTubeClient(expiredConnection, env);\n    \n    // Verify refresh was called\n    expect(mockRefreshToken).toHaveBeenCalled();\n  });\n});\n```\n\n### fetchChannelVideos\n```typescript\ndescribe('fetchChannelVideos', () =\u003e {\n  it('returns videos published after since', async () =\u003e {\n    mockYouTubeAPI.search.list.mockResolvedValue({\n      data: { items: [mockVideo1, mockVideo2] },\n    });\n    \n    const videos = await fetchChannelVideos(client, channelId, since);\n    expect(videos).toHaveLength(2);\n  });\n  \n  it('handles quota exceeded error', async () =\u003e {\n    mockYouTubeAPI.search.list.mockRejectedValue(\n      new Error('quotaExceeded')\n    );\n    \n    await expect(fetchChannelVideos(client, channelId, since))\n      .rejects.toThrow('QUOTA_EXCEEDED');\n  });\n  \n  it('filters out videos before since timestamp', async () =\u003e {\n    // Videos with publishedAt before and after since\n    const videos = await fetchChannelVideos(client, channelId, since);\n    \n    videos.forEach(v =\u003e {\n      expect(new Date(v.publishedAt).getTime()).toBeGreaterThan(since);\n    });\n  });\n});\n```\n\n### getUserSubscriptions\n```typescript\ndescribe('getUserSubscriptions', () =\u003e {\n  it('fetches all pages of subscriptions', async () =\u003e {\n    // Mock paginated response\n    mockYouTubeAPI.subscriptions.list\n      .mockResolvedValueOnce({ data: { items: [...], nextPageToken: 'page2' } })\n      .mockResolvedValueOnce({ data: { items: [...], nextPageToken: null } });\n    \n    const subs = await getUserSubscriptions(client);\n    expect(mockYouTubeAPI.subscriptions.list).toHaveBeenCalledTimes(2);\n  });\n});\n```\n\n## Mocking Strategy\n```typescript\njest.mock('googleapis', () =\u003e ({\n  google: {\n    youtube: jest.fn(() =\u003e ({\n      search: { list: jest.fn() },\n      subscriptions: { list: jest.fn() },\n      channels: { list: jest.fn() },\n    })),\n  },\n}));\n```\n\n## Files to Create\n- `apps/worker/src/providers/youtube.test.ts`\n\n## Acceptance Criteria\n- [ ] Client creation tested\n- [ ] Token refresh tested\n- [ ] Video fetching tested\n- [ ] Pagination tested\n- [ ] Error scenarios tested (quota, auth, network)\n\n## Estimated Effort\n3-4 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:25.947454-06:00","updated_at":"2025-12-28T09:57:02.541785-06:00","dependencies":[{"issue_id":"zine-b4h.18","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:25.94786-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.19","title":"P2.7: Add tests for providers/spotify.ts","description":"# P2.7: Add Tests for providers/spotify.ts\n\n## Overview\nAdd tests for the Spotify provider module.\n\n## File Under Test\n`apps/worker/src/providers/spotify.ts`\n\n## Key Functions to Test\n\n### getSpotifyClient\n```typescript\ndescribe('getSpotifyClient', () =\u003e {\n  it('creates client with access token', async () =\u003e {\n    const client = await getSpotifyClient(connection, env);\n    // Verify client is configured\n    expect(client.accessToken).toBe('decrypted-token');\n  });\n  \n  it('refreshes token if expired', async () =\u003e {\n    const expiredConnection = { ...connection, tokenExpiresAt: Date.now() - 1000 };\n    await getSpotifyClient(expiredConnection, env);\n    \n    expect(mockRefreshSpotifyToken).toHaveBeenCalled();\n  });\n});\n```\n\n### fetchShowEpisodes\n```typescript\ndescribe('fetchShowEpisodes', () =\u003e {\n  it('returns episodes published after since', async () =\u003e {\n    mockSpotifyAPI.getShowEpisodes.mockResolvedValue({\n      body: { items: [mockEpisode1, mockEpisode2] },\n    });\n    \n    const episodes = await fetchShowEpisodes(client, showId, since);\n    expect(episodes).toHaveLength(2);\n  });\n  \n  it('handles rate limit (429)', async () =\u003e {\n    mockSpotifyAPI.getShowEpisodes.mockRejectedValue({\n      statusCode: 429,\n      headers: { 'Retry-After': '30' },\n    });\n    \n    await expect(fetchShowEpisodes(client, showId, since))\n      .rejects.toThrow('RATE_LIMITED');\n  });\n});\n```\n\n### getUserSavedShows\n```typescript\ndescribe('getUserSavedShows', () =\u003e {\n  it('fetches saved shows', async () =\u003e {\n    mockSpotifyAPI.getMySavedShows.mockResolvedValue({\n      body: { items: [{ show: mockShow1 }, { show: mockShow2 }] },\n    });\n    \n    const shows = await getUserSavedShows(client);\n    expect(shows).toHaveLength(2);\n    expect(shows[0].name).toBe(mockShow1.name);\n  });\n  \n  it('handles empty library', async () =\u003e {\n    mockSpotifyAPI.getMySavedShows.mockResolvedValue({\n      body: { items: [] },\n    });\n    \n    const shows = await getUserSavedShows(client);\n    expect(shows).toEqual([]);\n  });\n});\n```\n\n## Mocking Strategy\n```typescript\njest.mock('spotify-web-api-node', () =\u003e {\n  return jest.fn().mockImplementation(() =\u003e ({\n    setAccessToken: jest.fn(),\n    getShowEpisodes: jest.fn(),\n    getMySavedShows: jest.fn(),\n    getShow: jest.fn(),\n  }));\n});\n```\n\n## Files to Create\n- `apps/worker/src/providers/spotify.test.ts`\n\n## Acceptance Criteria\n- [ ] Client creation tested\n- [ ] Token refresh tested\n- [ ] Episode fetching tested\n- [ ] Rate limit handling tested\n- [ ] Show discovery tested\n\n## Estimated Effort\n3-4 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:26.144423-06:00","updated_at":"2025-12-28T09:57:14.803774-06:00","dependencies":[{"issue_id":"zine-b4h.19","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:26.144861-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.2","title":"P0.2: Fix tRPC type exports to eliminate `any` casts","description":"# P0.2: Fix tRPC Type Exports to Eliminate `any` Casts\n\n## Problem Statement\nThe mobile app has **11 instances** of `(trpc as any).procedure.method()` casts because tRPC router types are imported via relative path but some router paths may not be fully typed.\n\n## Evidence\n```bash\n$ grep -r \"(trpc as any)\" apps/mobile --include=\"*.ts\" --include=\"*.tsx\" | wc -l\n11\n```\n\n**Key affected files:**\n- `hooks/use-sync-now.ts` (1)\n- `hooks/use-connections.ts` (2)  \n- `hooks/use-subscriptions-query.ts` (2)\n- `hooks/use-subscriptions.ts` (2)\n- `app/settings/connections.tsx` (1)\n- `app/subscriptions/discover/[provider].tsx` (2)\n- `app/onboarding/select-channels.tsx` (1)\n\n## Current State Analysis\nThe mobile app **already imports AppRouter correctly**:\n```typescript\n// apps/mobile/lib/trpc.ts\nimport type { AppRouter } from '../../worker/src/trpc/router';\nexport const trpc = createTRPCReact\u003cAppRouter\u003e();\n```\n\nThe issue is that `(trpc as any)` is used in specific hooks/screens where the TypeScript compiler is having trouble inferring types for nested router paths.\n\n## Root Cause\nThe tRPC router structure uses nested routers. When accessing deeply nested paths like `trpc.subscriptions.connections.disconnect`, TypeScript may need explicit type annotations.\n\n## Implementation Steps\n\n1. **Audit existing any casts** - Document each occurrence and the specific procedure being called\n\n2. **Ensure router exports all procedures properly** - Verify `AppRouter` type includes all nested routers\n\n3. **Fix each any cast by removing cast and fixing type errors**\n\n4. **Add eslint rule to prevent future any casts**\n\n## Files to Modify\n- `apps/mobile/hooks/use-sync-now.ts`\n- `apps/mobile/hooks/use-connections.ts`\n- `apps/mobile/hooks/use-subscriptions-query.ts`\n- `apps/mobile/hooks/use-subscriptions.ts`\n- `apps/mobile/app/settings/connections.tsx`\n- `apps/mobile/app/subscriptions/discover/[provider].tsx`\n- `apps/mobile/app/onboarding/select-channels.tsx`\n- `apps/mobile/eslint.config.js`\n\n## Acceptance Criteria\n- [ ] Zero `(trpc as any)` patterns in codebase\n- [ ] Full autocomplete for all tRPC procedures\n- [ ] Mobile app builds with strict TypeScript\n- [ ] ESLint rule prevents future any casts\n\n## Estimated Effort\n2-3 hours (reduced from 4-6 hours - simpler than originally thought)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-28T09:49:22.789201-06:00","updated_at":"2025-12-28T12:09:53.880702-06:00","closed_at":"2025-12-28T12:09:53.880702-06:00","close_reason":"Fixed tRPC type exports by adding @cloudflare/workers-types to mobile app and updating tsconfig. Removed all 11 (trpc as any) casts and additional (utils as any) casts by properly typing the tRPC client. Updated Subscription type to match actual database schema.","dependencies":[{"issue_id":"zine-b4h.2","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:22.789651-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.20","title":"P2.8: Extract magic numbers to named constants","description":"# P2.8: Extract Magic Numbers to Named Constants\n\n## Problem Statement\nMultiple files contain hardcoded numeric values without explanation:\n\n| File | Value | Meaning |\n|------|-------|---------|\n| `polling/scheduler.ts:47` | `900` | Poll lock TTL in seconds |\n| `polling/scheduler.ts:50` | `50` | Batch size for polling |\n| `offline-queue.ts:33` | `3` | Max retry attempts |\n| `use-subscriptions.ts:466` | `5 * 60 * 1000` | Sync rate limit (5 min) |\n| Multiple hooks | `5 * 60 * 1000` | Stale time for queries |\n\n## Why This Matters (P2)\n\n### Readability\n`if (retryCount \u003e= 3)` vs `if (retryCount \u003e= MAX_RETRIES)`\n\n### Maintainability\nChanging a value requires finding all occurrences.\n\n### Documentation\nConstants can have JSDoc explaining the value.\n\n## Implementation\n\n### Worker Constants\n```typescript\n// apps/worker/src/lib/constants.ts\n\n/**\n * Time-to-live for the polling distributed lock.\n * Should match or slightly exceed the cron interval (15 min).\n */\nexport const POLL_LOCK_TTL_SECONDS = 900; // 15 minutes\n\n/**\n * Number of subscriptions to process in a single batch.\n * Balances throughput with memory usage.\n */\nexport const POLL_BATCH_SIZE = 50;\n\n/**\n * How long manual sync is blocked after previous sync.\n * Prevents API abuse.\n */\nexport const MANUAL_SYNC_COOLDOWN_MS = 5 * 60 * 1000; // 5 minutes\n```\n\n### Mobile Constants\n```typescript\n// apps/mobile/lib/constants.ts\n\n/**\n * Maximum retry attempts for offline actions before giving up.\n */\nexport const MAX_OFFLINE_RETRIES = 3;\n\n/**\n * Maximum auth refresh retries before requiring re-login.\n */\nexport const MAX_AUTH_RETRIES = 1;\n\n/**\n * React Query stale time for subscription data.\n * How long before cached data is considered stale.\n */\nexport const STALE_TIME_5_MINUTES = 5 * 60 * 1000;\n\n/**\n * React Query garbage collection time.\n * How long unused data is kept in cache.\n */\nexport const GC_TIME_24_HOURS = 24 * 60 * 60 * 1000;\n```\n\n### Usage\n```typescript\n// Before\nstaleTime: 5 * 60 * 1000,\n\n// After\nimport { STALE_TIME_5_MINUTES } from '@/lib/constants';\nstaleTime: STALE_TIME_5_MINUTES,\n```\n\n## Files to Create\n- `apps/worker/src/lib/constants.ts`\n- `apps/mobile/lib/constants.ts`\n\n## Files to Modify\n- `apps/worker/src/polling/scheduler.ts`\n- `apps/mobile/lib/offline-queue.ts`\n- `apps/mobile/hooks/use-subscriptions.ts`\n- `apps/mobile/hooks/use-connections.ts`\n- `apps/mobile/hooks/use-subscriptions-query.ts`\n\n## Acceptance Criteria\n- [ ] All magic numbers in config/timing category extracted\n- [ ] Constants have JSDoc comments\n- [ ] All usages updated to use constants\n- [ ] No bare numeric literals for configuration values\n\n## Estimated Effort\n2-3 hours","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:26.342259-06:00","updated_at":"2025-12-28T12:14:10.209036-06:00","dependencies":[{"issue_id":"zine-b4h.20","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:26.342629-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.21","title":"P2.9: Add user-facing error feedback (toasts)","description":"# P2.9: Add User-Facing Error Feedback (Toasts)\n\n## Problem Statement\nErrors are logged to console but not shown to users:\n\n```typescript\n// app/item/[id].tsx:136-137\n} catch (error) {\n  console.error('Failed to toggle finished:', error);\n  // User sees nothing!\n}\n\n// app/onboarding/select-channels.tsx:337-338\n} catch (error) {\n  console.error('Failed to subscribe:', error);\n  // User thinks it worked!\n}\n```\n\n## Why This Matters (P2)\n\n### Poor UX\nUsers perform actions that fail silently. They don't know to retry.\n\n### Data Integrity\nUsers may think data was saved when it wasn't.\n\n### Trust\nSilent failures erode trust in the app.\n\n## Implementation\n\n### Toast System\nHeroUI Native provides toast primitives (added in beta.4):\n\n```typescript\nimport { Toast, ToastProvider, useToast } from '@heroui/native';\n\n// In root layout\nexport default function RootLayout() {\n  return (\n    \u003cToastProvider\u003e\n      \u003cStack /\u003e\n    \u003c/ToastProvider\u003e\n  );\n}\n\n// In components\nfunction ItemDetailScreen() {\n  const { show } = useToast();\n  \n  const handleToggleFinished = async () =\u003e {\n    try {\n      await toggleFinished(item.id);\n      show({\n        title: item.isFinished ? 'Marked as unfinished' : 'Marked as finished',\n        type: 'success',\n      });\n    } catch (error) {\n      show({\n        title: 'Failed to update',\n        description: 'Please try again',\n        type: 'error',\n      });\n    }\n  };\n}\n```\n\n### Error Messages\n| Action | Success | Error |\n|--------|---------|-------|\n| Toggle finished | \"Marked as finished\" | \"Failed to update\" |\n| Bookmark | \"Saved to library\" | \"Failed to save\" |\n| Subscribe | \"Subscribed to [name]\" | \"Failed to subscribe\" |\n| Unsubscribe | \"Unsubscribed\" | \"Failed to unsubscribe\" |\n\n### Error Handler Utility\n```typescript\n// apps/mobile/lib/error-handler.ts\nexport function handleMutationError(\n  error: unknown,\n  toast: Toast,\n  defaultMessage = 'Something went wrong'\n) {\n  const message = error instanceof Error ? error.message : defaultMessage;\n  \n  toast.show({\n    title: 'Error',\n    description: message,\n    type: 'error',\n    duration: 4000,\n  });\n  \n  // Still log for debugging\n  console.error('[MutationError]', error);\n}\n```\n\n## Files to Modify\n- `apps/mobile/app/_layout.tsx` - Add ToastProvider\n- `apps/mobile/app/item/[id].tsx` - Add toasts\n- `apps/mobile/app/onboarding/select-channels.tsx` - Add toasts\n- `apps/mobile/app/(tabs)/inbox.tsx` - Add toasts for bookmark/archive\n\n## Files to Create\n- `apps/mobile/lib/error-handler.ts`\n\n## Dependencies\n- HeroUI Native beta.4+ (already in dependencies)\n\n## Acceptance Criteria\n- [ ] ToastProvider in root layout\n- [ ] All mutations show success/error toasts\n- [ ] Toast messages are user-friendly\n- [ ] Errors still logged for debugging\n- [ ] Toasts auto-dismiss after 4s\n\n## Estimated Effort\n2-3 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:26.539358-06:00","updated_at":"2025-12-28T09:55:04.773488-06:00","dependencies":[{"issue_id":"zine-b4h.21","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:26.53974-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.22","title":"P2.10: Refactor processQueue function (115 lines, nested try/catch)","description":"# P2.10: Refactor processQueue function (115 lines, nested try/catch)\n\n## Problem Statement\n`processQueue()` in `apps/mobile/lib/offline-queue.ts` is actually **116 lines** (lines 292-407) with complex nested try/catch logic.\n\n## Current Structure Analysis\nThe function has this flow:\n1. Check if already processing (prevent concurrent)\n2. Check connectivity via NetInfo\n3. Loop through queue\n4. For each action:\n   - Try to execute\n   - On success: mark for removal\n   - On error: classify error type, handle based on type (CONFLICT, AUTH, CLIENT, NETWORK/SERVER)\n5. Save remaining queue\n6. Notify listeners and React Query\n\n## Complexity Assessment\nThe nested try/catch blocks handle:\n- AUTH errors with retry after token refresh (lines 329-364)\n- CONFLICT errors (lines 319-327)\n- CLIENT errors (lines 367-374)\n- NETWORK/SERVER/UNKNOWN errors with retry counting (lines 376-392)\n\n## Proposed Refactoring\n\n### 1. Extract Action Execution Result Handler\n```typescript\ninterface ActionResult {\n  success: boolean;\n  shouldRemove: boolean;\n  updatedAction?: OfflineAction;\n  error?: { type: ErrorClassification; message: string };\n}\n\nasync function handleActionExecution(\n  action: OfflineAction,\n  executeAction: () =\u003e Promise\u003cvoid\u003e\n): Promise\u003cActionResult\u003e {\n  try {\n    await executeAction();\n    return { success: true, shouldRemove: true };\n  } catch (error) {\n    return classifyAndHandleError(action, error);\n  }\n}\n```\n\n### 2. Extract Error Handling Logic\n```typescript\nfunction classifyAndHandleError(\n  action: OfflineAction,\n  error: unknown\n): ActionResult {\n  const errorType = classifyError(error);\n  // Return appropriate ActionResult based on error type\n}\n```\n\n### 3. Simplified processQueue\n```typescript\nasync processQueue(): Promise\u003cvoid\u003e {\n  if (this.isProcessing) return;\n  if (!(await this.isOnline())) return;\n\n  this.isProcessing = true;\n  try {\n    const queue = await this.getQueue();\n    const results = await Promise.all(\n      queue.map(action =\u003e this.processAction(action))\n    );\n    await this.saveRemainingActions(results);\n    await this.notifyIfSuccesses(results);\n  } finally {\n    this.isProcessing = false;\n  }\n}\n```\n\n## Benefits\n- Each function is testable in isolation\n- Clear separation: execution vs error handling vs queue management\n- Easier to understand and modify specific behaviors\n- processQueue becomes orchestration only\n\n## Dependencies\n- **P2.3 (Tests for offline-queue)** should be done FIRST\n- The test file should verify current behavior before refactoring\n- After refactoring, tests validate no regression\n\n## Files to Modify\n- `apps/mobile/lib/offline-queue.ts`\n\n## Acceptance Criteria\n- [ ] processQueue under 30-40 lines\n- [ ] Each extracted function under 25 lines\n- [ ] All existing behaviors preserved\n- [ ] Tests pass before AND after refactor\n- [ ] No nested try/catch blocks\n\n## Risk Assessment\n**Medium risk** - Complex logic that handles offline mutations. Test coverage is critical before refactoring.\n\n## Estimated Effort\n3-4 hours (including careful testing)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:26.737616-06:00","updated_at":"2025-12-28T10:52:13.604446-06:00","dependencies":[{"issue_id":"zine-b4h.22","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:26.738021-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.22","depends_on_id":"zine-b4h.15","type":"blocks","created_at":"2025-12-28T09:58:27.601722-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.23","title":"P2.11: Split select-channels.tsx into components (~653 lines)","description":"# P2.11: Split select-channels.tsx into Components (~653 lines)\n\n## Problem Statement\n`apps/mobile/app/onboarding/select-channels.tsx` is 653 lines containing:\n- Inline icon definitions (duplicating /components/icons/)\n- LoadingState, ErrorState, EmptyState components\n- ChannelCard component\n- Main screen component\n- 100+ line StyleSheet\n\n## Why This Matters (P2)\n\n### Same Issues as Home Screen\n- Hard to navigate\n- Hard to test\n- Hard to review\n- Components can't be reused\n\n### Lower Priority Than Home\n- Less frequently modified\n- Smaller file (653 vs 1040)\n- Onboarding is less critical path\n\n## Proposed Structure\n```\napps/mobile/\n├── app/onboarding/select-channels.tsx  # ~150 lines (composition)\n└── components/onboarding/\n    ├── index.tsx                       # Barrel exports\n    ├── channel-card.tsx                # Individual channel\n    ├── channel-list.tsx                # FlatList wrapper\n    ├── onboarding-header.tsx           # Header section\n    └── select-channels.styles.ts       # Shared styles\n```\n\n## Shared Components Reuse\nThese should use shared components (after P1.2 completes):\n- LoadingState → `@/components/list-states`\n- ErrorState → `@/components/list-states`\n- EmptyState → `@/components/list-states`\n- Icons → `@/components/icons`\n\n## Files to Create\n- `apps/mobile/components/onboarding/index.tsx`\n- `apps/mobile/components/onboarding/channel-card.tsx`\n- `apps/mobile/components/onboarding/channel-list.tsx`\n\n## Files to Modify\n- `apps/mobile/app/onboarding/select-channels.tsx` (reduce to ~150 lines)\n\n## Dependencies\n- P1.2 (Icon consolidation) - Should be done first\n- P0.3 (Test infrastructure) - Should have tests before refactoring\n\n## Acceptance Criteria\n- [ ] select-channels.tsx under 200 lines\n- [ ] Inline icons replaced with imports\n- [ ] State components use shared list-states\n- [ ] No visual changes\n- [ ] Components independently importable\n\n## Estimated Effort\n3-4 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T09:49:26.933245-06:00","updated_at":"2025-12-28T09:55:41.180375-06:00","dependencies":[{"issue_id":"zine-b4h.23","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:26.933642-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.23","depends_on_id":"zine-b4h.7","type":"blocks","created_at":"2025-12-28T10:31:59.592111-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.24","title":"P3.1: Remove unused styles from index.tsx","description":"# P3.1: Remove Unused Styles from index.tsx\n\n## Problem Statement\n`apps/mobile/app/(tabs)/index.tsx` lines 889-1013 contain ~20 unused style definitions:\n- `jumpBackInCard`, `jumpBackInThumbnail`\n- `playOverlay`, `playButton`\n- `cardProgressContainer`, `cardProgressFill`\n- `badge`, `badgeText`\n- `loadingContainer`, `loadingText`\n\nThese are remnants from removed or redesigned features.\n\n## Why This Matters (P3)\n\n### Bundle Size\nUnused styles are still compiled and bundled.\n\n### Confusion\nDevelopers may think these styles are in use.\n\n### Low Priority\nNo functional impact, purely cleanup.\n\n## Implementation\n\n### 1. Audit Used Styles\nSearch for each style name in the file:\n```typescript\nstyles.jumpBackInCard  // Used?\nstyles.playOverlay     // Used?\n```\n\n### 2. Remove Unused\nDelete style definitions not referenced anywhere.\n\n### 3. Verify No Breaks\nEnsure app still builds and renders correctly.\n\n## Acceptance Criteria\n- [ ] All unused styles removed\n- [ ] App builds without errors\n- [ ] No visual changes\n- [ ] StyleSheet is smaller\n\n## Dependencies\n- P1.1 (Split index.tsx) - Easier to audit after split\n\n## Estimated Effort\n30 minutes","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-28T09:49:27.130554-06:00","updated_at":"2025-12-28T10:31:35.571814-06:00","closed_at":"2025-12-28T10:31:35.571814-06:00","dependencies":[{"issue_id":"zine-b4h.24","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:27.130932-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.25","title":"P3.2: Standardize provider casing (youtube vs YOUTUBE)","description":"# P3.2: Standardize Provider Casing (youtube vs YOUTUBE)\n\n## Problem Statement\nProvider identifiers use inconsistent casing:\n- Mobile: `'youtube'`, `'spotify'` (lowercase)\n- Worker: `'YOUTUBE'`, `'SPOTIFY'` (uppercase)\n\nThis requires case conversion at API boundaries.\n\n## Evidence\n```typescript\n// Mobile (lowercase)\nif (provider === 'youtube') { ... }\n\n// Worker (uppercase)\neq(subscriptions.provider, 'YOUTUBE')\n```\n\n## Why This Matters (P3)\n\n### Friction\nEvery boundary needs `.toLowerCase()` or `.toUpperCase()`.\n\n### Typo Risk\n`'Youtube'` (mixed case) would fail silently.\n\n### Convention Violation\nEnums should have consistent casing.\n\n## The Correct Convention\nPer `packages/shared/src/schemas/index.ts`, the canonical format is **UPPERCASE**:\n```typescript\nexport const ProviderSchema = z.enum(['YOUTUBE', 'SPOTIFY']);\n```\n\nMobile should convert user-facing lowercase to uppercase when calling APIs.\n\n## Implementation\n\n### 1. Add Type Guard in Shared\n```typescript\n// packages/shared/src/types/domain.ts\nexport type Provider = 'YOUTUBE' | 'SPOTIFY';\n\nexport function normalizeProvider(p: string): Provider {\n  const upper = p.toUpperCase();\n  if (upper === 'YOUTUBE' || upper === 'SPOTIFY') {\n    return upper;\n  }\n  throw new Error(`Invalid provider: ${p}`);\n}\n```\n\n### 2. Update Mobile Comparisons\n```typescript\n// Before\nif (item.provider === 'youtube') { ... }\n\n// After\nif (item.provider === 'YOUTUBE') { ... }\n```\n\n### 3. Keep UI Lowercase\nUser-facing strings can remain lowercase for display:\n```typescript\nconst displayName = provider.toLowerCase(); // 'youtube'\n```\n\n## Files to Modify\n- `packages/shared/src/types/domain.ts` - Add normalizer\n- `apps/mobile/**/*.tsx` - Update comparisons\n- `apps/mobile/**/*.ts` - Update comparisons\n\n## Acceptance Criteria\n- [ ] All provider comparisons use uppercase\n- [ ] Shared type enforces uppercase\n- [ ] Display strings can be lowercase\n- [ ] No case-related bugs\n\n## Estimated Effort\n2-3 hours","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-28T09:49:27.329067-06:00","updated_at":"2025-12-28T09:56:02.995805-06:00","dependencies":[{"issue_id":"zine-b4h.25","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:27.329508-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.26","title":"P3.3: Unify error boundary components","description":"# P3.3: Unify Error Boundary Components\n\n## Problem Statement\nThe mobile app has 4 separate error boundary components:\n- `components/error-boundary.tsx` - Base error boundary\n- `components/subscription-error-boundary.tsx` - Subscription-specific\n- `components/oauth-error-boundary.tsx` - OAuth-specific\n- `components/query-error-boundary.tsx` - React Query integration\n\nWhile specialized boundaries have value, they share significant code and could be consolidated.\n\n## Current Duplication\nEach boundary has:\n- Class component with `getDerivedStateFromError`\n- Reset logic\n- Styled fallback UI\n- Button handlers\n\n~60% of code is identical across all four.\n\n## Proposed Consolidation\n\n### Option A: Base + Specialized Rendering\nKeep one ErrorBoundary class, pass specialized render props:\n\n```typescript\n\u003cErrorBoundary\n  fallbackRender={({ error, reset }) =\u003e (\n    \u003cSubscriptionErrorFallback error={error} onReset={reset} /\u003e\n  )}\n\u003e\n  {children}\n\u003c/ErrorBoundary\u003e\n```\n\n### Option B: Base with Error Type Detection\nSingle boundary that detects error type and renders appropriately:\n\n```typescript\nfunction UnifiedErrorBoundary({ children }: Props) {\n  return (\n    \u003cErrorBoundary\n      fallbackRender={({ error, reset }) =\u003e {\n        if (isOAuthError(error)) {\n          return \u003cOAuthFallback error={error} onReset={reset} /\u003e;\n        }\n        if (isQueryError(error)) {\n          return \u003cQueryFallback error={error} onReset={reset} /\u003e;\n        }\n        return \u003cGenericFallback error={error} onReset={reset} /\u003e;\n      }}\n    /\u003e\n  );\n}\n```\n\n## Files to Modify\n- `apps/mobile/components/error-boundary.tsx` - Enhance base\n- `apps/mobile/components/subscription-error-boundary.tsx` - Simplify or delete\n- `apps/mobile/components/oauth-error-boundary.tsx` - Simplify or delete\n- `apps/mobile/components/query-error-boundary.tsx` - Simplify or delete\n\n## Acceptance Criteria\n- [ ] Single error boundary class component\n- [ ] Specialized fallbacks as functional components\n- [ ] Error type detection logic centralized\n- [ ] Same behavior as before\n\n## Estimated Effort\n2-3 hours","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-28T09:49:27.522096-06:00","updated_at":"2025-12-28T09:56:14.028747-06:00","dependencies":[{"issue_id":"zine-b4h.26","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:27.522517-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.27","title":"P3.4: Add input validation for route params","description":"# P3.4: Add Input Validation for Route Params\n\n## Problem Statement\nRoute parameters are used without validation:\n\n```typescript\n// app/item/[id].tsx:120\nconst { id } = useLocalSearchParams\u003c{ id: string }\u003e();\n// id could be undefined, empty, or invalid\n\n// app/onboarding/select-channels.tsx:243\nconst provider = params.provider as 'youtube' | 'spotify';\n// Unsafe cast - provider could be anything\n```\n\n## Why This Matters (P3)\n\n### Type Safety\nTypeScript types don't enforce runtime validity.\n\n### Error Handling\nInvalid params cause unclear errors deep in the code.\n\n### Security\nUnsanitized params could be used in API calls.\n\n## Implementation\n\n### 1. Validate at Route Entry\n```typescript\n// app/item/[id].tsx\nexport default function ItemDetailScreen() {\n  const { id } = useLocalSearchParams\u003c{ id: string }\u003e();\n  \n  // Validate early\n  if (!id || typeof id !== 'string') {\n    return \u003cInvalidParamScreen param=\"id\" /\u003e;\n  }\n  \n  // Now id is guaranteed to be a non-empty string\n  const { data, isLoading, error } = useItem(id);\n  // ...\n}\n```\n\n### 2. Provider Param Validation\n```typescript\n// app/onboarding/select-channels.tsx\nconst VALID_PROVIDERS = ['youtube', 'spotify'] as const;\n\nfunction isValidProvider(p: unknown): p is 'youtube' | 'spotify' {\n  return typeof p === 'string' \u0026\u0026 VALID_PROVIDERS.includes(p as any);\n}\n\nexport default function SelectChannelsScreen() {\n  const { provider } = useLocalSearchParams();\n  \n  if (!isValidProvider(provider)) {\n    return \u003cNavigate to=\"/onboarding\" replace /\u003e;\n  }\n  \n  // provider is now typed as 'youtube' | 'spotify'\n}\n```\n\n### 3. Create Reusable Validator\n```typescript\n// apps/mobile/lib/route-validation.ts\nimport { z } from 'zod';\n\nexport const ItemIdSchema = z.string().min(1).max(100);\nexport const ProviderSchema = z.enum(['youtube', 'spotify']);\n\nexport function validateRouteParams\u003cT\u003e(\n  params: Record\u003cstring, unknown\u003e,\n  schema: z.Schema\u003cT\u003e\n): { success: true; data: T } | { success: false; error: z.ZodError } {\n  return schema.safeParse(params);\n}\n```\n\n## Files to Create\n- `apps/mobile/lib/route-validation.ts`\n\n## Files to Modify\n- `apps/mobile/app/item/[id].tsx`\n- `apps/mobile/app/onboarding/select-channels.tsx`\n- `apps/mobile/app/subscriptions/discover/[provider].tsx`\n- `apps/mobile/app/subscriptions/connect/[provider].tsx`\n\n## Acceptance Criteria\n- [ ] All dynamic route params validated\n- [ ] Invalid params show appropriate UI\n- [ ] Type narrowing after validation\n- [ ] Zod schemas for common params\n\n## Estimated Effort\n2-3 hours","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-28T09:49:27.721527-06:00","updated_at":"2025-12-28T09:56:27.570182-06:00","dependencies":[{"issue_id":"zine-b4h.27","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:27.721985-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.3","title":"P0.3: Set up mobile test infrastructure (Jest + RNTL)","description":"# P0.3: Set Up Mobile Test Infrastructure (Jest + React Native Testing Library)\n\n## Problem Statement\nThe entire `apps/mobile/` directory has **zero test files**. This is blocking:\n- Safe refactoring (P1 tasks)\n- Confidence in hook behavior\n- Regression prevention\n\n## Current State\n```bash\n$ find apps/mobile -name \"*.test.ts\" -o -name \"*.test.tsx\"\n# (no output)\n```\n\nThe worker already has Vitest configured with 3 test files:\n- `apps/worker/src/polling/scheduler.test.ts` (27KB)\n- `apps/worker/src/polling/adaptive.test.ts` (11KB)\n- `apps/worker/src/ingestion/transformers.test.ts`\n\n## Implementation Plan\n\n### 1. Install Dependencies\n```bash\ncd apps/mobile\nbun add -D jest jest-expo @types/jest \\\n  @testing-library/react-native @testing-library/jest-native \\\n  react-test-renderer @types/react-test-renderer\n```\n\nNote: Use `jest-expo` preset for Expo projects (handles transformers automatically).\n\n### 2. Create Jest Configuration\n```javascript\n// apps/mobile/jest.config.js\nmodule.exports = {\n  preset: 'jest-expo',\n  setupFilesAfterEnv: [\n    '@testing-library/jest-native/extend-expect',\n    '\u003crootDir\u003e/jest.setup.js'\n  ],\n  moduleNameMapper: {\n    '^@/(.*)$': '\u003crootDir\u003e/$1',\n  },\n  collectCoverageFrom: [\n    'lib/**/*.{ts,tsx}',\n    'hooks/**/*.{ts,tsx}',\n    '!**/*.d.ts',\n  ],\n  testMatch: ['**/*.test.{ts,tsx}'],\n};\n```\n\n### 3. Create Test Setup\n```typescript\n// apps/mobile/jest.setup.js\nimport '@testing-library/jest-native/extend-expect';\n\n// Mock expo-secure-store\njest.mock('expo-secure-store', () =\u003e ({\n  getItemAsync: jest.fn(),\n  setItemAsync: jest.fn(),\n  deleteItemAsync: jest.fn(),\n}));\n\n// Mock AsyncStorage\njest.mock('@react-native-async-storage/async-storage', () =\u003e\n  require('@react-native-async-storage/async-storage/jest/async-storage-mock')\n);\n\n// Mock NetInfo\njest.mock('@react-native-community/netinfo', () =\u003e ({\n  fetch: jest.fn(() =\u003e Promise.resolve({ isConnected: true, isInternetReachable: true })),\n  addEventListener: jest.fn(() =\u003e jest.fn()),\n}));\n```\n\n### 4. Add npm Scripts\n```json\n// apps/mobile/package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  }\n}\n```\n\n### 5. Create First Test (Smoke Test)\n```typescript\n// apps/mobile/lib/format.test.ts\nimport { formatDuration, formatRelativeTime } from './format';\n\ndescribe('formatDuration', () =\u003e {\n  it('formats hours and minutes', () =\u003e {\n    expect(formatDuration(3723)).toBe('1h 2m');\n  });\n  \n  it('handles null', () =\u003e {\n    expect(formatDuration(null)).toBe('');\n  });\n});\n```\n\n### 6. Update CI (if not already)\n```yaml\n# .github/workflows/ci.yml\nmobile-test:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - uses: oven-sh/setup-bun@v1\n    - run: bun install\n    - run: bun run test\n      working-directory: apps/mobile\n```\n\n## Files to Create\n- `apps/mobile/jest.config.js`\n- `apps/mobile/jest.setup.js`\n- `apps/mobile/lib/format.test.ts` (smoke test)\n\n## Files to Modify\n- `apps/mobile/package.json` (add dependencies and scripts)\n- `.github/workflows/ci.yml` (add test job if not present)\n\n## Acceptance Criteria\n- [ ] `bun run test` runs in apps/mobile\n- [ ] Jest configured with jest-expo preset\n- [ ] Expo modules properly mocked\n- [ ] AsyncStorage mock working\n- [ ] NetInfo mock working\n- [ ] At least one passing test (format.test.ts)\n- [ ] CI runs mobile tests\n\n## Blocking Tasks\nThis task blocks:\n- P1.1: Home screen split (needs tests before refactoring)\n- P2.1-P2.4: All mobile test tasks\n- P2.10: processQueue refactor (needs tests first)\n\n## Estimated Effort\n2-3 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-28T09:49:22.985543-06:00","updated_at":"2025-12-28T12:14:07.889621-06:00","closed_at":"2025-12-28T12:14:07.889621-06:00","close_reason":"Set up mobile test infrastructure with Jest + ts-jest. Configured for pure TypeScript utility tests (lib/format.test.ts passes with 41 tests). Note: React Native component/hook tests require additional work due to bun+jest-expo compatibility issues.","dependencies":[{"issue_id":"zine-b4h.3","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:22.98592-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.4","title":"P0.4: Implement items.toggleFinished tRPC mutation","description":"# P0.4: Implement items.toggleFinished tRPC Mutation\n\n## Problem Statement\nThe Item Detail Page (`apps/mobile/app/item/[id].tsx`) has a \"Mark as Finished\" button that currently logs a TODO comment instead of working:\n\n```typescript\n// Line 157 in app/item/[id].tsx\n// TODO: Implement when items.toggleFinished endpoint is available\nconsole.log('Toggle finished:', item.id);\n```\n\n## Why This Must Be Fixed (P0)\n\n### Core UX Feature\n\"Mark as Finished\" is one of the **four primary actions** on the Item Detail Page:\n1. ✅ Open in native app (implemented)\n2. ✅ Bookmark/Unbookmark (partially - see P0.5)\n3. ❌ Mark as Finished (THIS TASK)\n4. ⏸️ Share (out of scope)\n\n### User Value\nUsers want to track what they've consumed vs what's pending. Without this:\n- No way to distinguish watched/unfinished videos\n- Library becomes a pile of undifferentiated bookmarks\n- Progress tracking impossible\n\n### Database Schema Ready\nThe `isFinished` and `finishedAt` columns were added in a previous epic (zine-qch.8, zine-qch.9). The backend mutation is missing.\n\n## Implementation Design\n\n### API Contract\n```typescript\n// items.toggleFinished\nInput: { id: string }  // UserItem ID\nOutput: {\n  success: boolean;\n  isFinished: boolean;    // New state after toggle\n  finishedAt: string | null;  // ISO 8601 timestamp or null\n}\n```\n\n### Behavior\n1. Find UserItem by id where userId = ctx.userId\n2. Toggle isFinished: `false → true` or `true → false`\n3. Set finishedAt: `null → now()` or `timestamp → null`\n4. Return new state for optimistic update confirmation\n\n### Error Cases\n| Scenario | Error Code | Message |\n|----------|------------|---------|\n| Item not found | NOT_FOUND | \"Item not found\" |\n| Wrong user | NOT_FOUND | \"Item not found\" (don't leak existence) |\n\n## Implementation\n\n### tRPC Procedure\n```typescript\n// apps/worker/src/trpc/routers/items.ts\ntoggleFinished: protectedProcedure\n  .input(z.object({\n    id: z.string(), // UserItem ID\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Find the user item\n    const userItem = await ctx.db.query.userItems.findFirst({\n      where: and(\n        eq(userItems.id, input.id),\n        eq(userItems.userId, ctx.userId),\n      ),\n    });\n    \n    if (!userItem) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Item not found',\n      });\n    }\n    \n    // 2. Calculate new state\n    const newIsFinished = !userItem.isFinished;\n    const newFinishedAt = newIsFinished \n      ? new Date().toISOString() \n      : null;\n    \n    // 3. Update\n    await ctx.db\n      .update(userItems)\n      .set({\n        isFinished: newIsFinished,\n        finishedAt: newFinishedAt,\n        updatedAt: new Date().toISOString(),\n      })\n      .where(eq(userItems.id, input.id));\n    \n    return {\n      success: true,\n      isFinished: newIsFinished,\n      finishedAt: newFinishedAt,\n    };\n  }),\n```\n\n### Frontend Hook (use-items-trpc.ts)\n```typescript\nexport function useToggleFinished() {\n  const utils = trpc.useUtils();\n  \n  return trpc.items.toggleFinished.useMutation({\n    onMutate: async ({ id }) =\u003e {\n      // Cancel related queries\n      await utils.items.get.cancel({ id });\n      await utils.items.library.cancel();\n      \n      // Snapshot current data\n      const previousItem = utils.items.get.getData({ id });\n      \n      // Optimistic update\n      if (previousItem) {\n        const newIsFinished = !previousItem.isFinished;\n        utils.items.get.setData({ id }, {\n          ...previousItem,\n          isFinished: newIsFinished,\n          finishedAt: newIsFinished ? new Date().toISOString() : null,\n        });\n      }\n      \n      return { previousItem };\n    },\n    onError: (err, { id }, context) =\u003e {\n      // Rollback on error\n      if (context?.previousItem) {\n        utils.items.get.setData({ id }, context.previousItem);\n      }\n    },\n    onSettled: (_, __, { id }) =\u003e {\n      // Refetch to ensure consistency\n      utils.items.get.invalidate({ id });\n      utils.items.library.invalidate();\n    },\n  });\n}\n```\n\n## Files to Modify\n- `apps/worker/src/trpc/routers/items.ts` - Add toggleFinished procedure\n- `apps/mobile/hooks/use-items-trpc.ts` - Add useToggleFinished hook\n- `apps/mobile/app/item/[id].tsx` - Wire up the button\n\n## Dependencies\n- Schema columns already exist (zine-qch.8, zine-qch.9 - completed)\n- P0.2 (tRPC types) should be done first for proper typing\n\n## Acceptance Criteria\n- [ ] `items.toggleFinished` procedure exists and returns correct shape\n- [ ] Mutation validates userId ownership\n- [ ] Optimistic update provides instant UI feedback\n- [ ] Library list reflects isFinished state\n- [ ] Item Detail Page button works without TODO comment\n\n## Testing Plan\n1. Toggle finished on item in INBOX state\n2. Toggle finished on item in BOOKMARKED state\n3. Toggle back to unfinished\n4. Verify optimistic update (UI changes before server responds)\n5. Verify rollback on network error\n\n## Estimated Effort\n2-3 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-28T09:49:23.182139-06:00","updated_at":"2025-12-28T10:31:33.272034-06:00","closed_at":"2025-12-28T10:31:33.272034-06:00","dependencies":[{"issue_id":"zine-b4h.4","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:23.182583-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.4","depends_on_id":"zine-b4h.2","type":"blocks","created_at":"2025-12-28T09:58:09.306182-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.5","title":"P0.5: Implement items.unbookmark tRPC mutation","description":"# P0.5: Implement items.unbookmark tRPC Mutation\n\n## Problem Statement\nThe Item Detail Page has no way to move an item from BOOKMARKED state back to INBOX. Currently, bookmark is a one-way operation:\n\n```typescript\n// Line 163 in app/item/[id].tsx  \n// TODO: Implement when items.unbookmark endpoint is available\nconsole.log('Unbookmark:', item.id);\n```\n\n## Why This Must Be Fixed (P0)\n\n### User Flexibility\nUsers change their mind. A bookmarked item may become irrelevant, or they may have bookmarked by accident. Without unbookmark:\n- Items stuck in Library forever\n- Only option is to archive (loses from everywhere)\n- Poor UX for accidental bookmarks\n\n### Reversibility Principle\nGood UX requires that user actions be reversible. Bookmark without unbookmark violates this.\n\n### Detail Page Feature Gap\nThe bookmark toggle button shows \"Saved\" when bookmarked but can't be clicked to unsave.\n\n## Implementation Design\n\n### API Contract\n```typescript\n// items.unbookmark\nInput: { id: string }  // UserItem ID\nOutput: { success: boolean }\n```\n\n### Behavior\n1. Find UserItem by id where userId = ctx.userId\n2. Verify current state = BOOKMARKED\n3. Update state to INBOX\n4. Clear bookmarkedAt timestamp\n5. Return success\n\n### Error Cases\n| Scenario | Error Code | Message |\n|----------|------------|---------|\n| Item not found | NOT_FOUND | \"Item not found\" |\n| Wrong user | NOT_FOUND | \"Item not found\" (don't leak) |\n| Not bookmarked | BAD_REQUEST | \"Item is not bookmarked\" |\n\n## Implementation\n\n### tRPC Procedure\n```typescript\n// apps/worker/src/trpc/routers/items.ts\nunbookmark: protectedProcedure\n  .input(z.object({\n    id: z.string(), // UserItem ID\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Find the user item\n    const userItem = await ctx.db.query.userItems.findFirst({\n      where: and(\n        eq(userItems.id, input.id),\n        eq(userItems.userId, ctx.userId),\n      ),\n    });\n    \n    if (!userItem) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Item not found',\n      });\n    }\n    \n    // 2. Verify bookmarked state\n    if (userItem.state !== 'BOOKMARKED') {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: 'Item is not bookmarked',\n      });\n    }\n    \n    // 3. Update to INBOX state\n    await ctx.db\n      .update(userItems)\n      .set({\n        state: 'INBOX',\n        bookmarkedAt: null,\n        updatedAt: new Date().toISOString(),\n      })\n      .where(eq(userItems.id, input.id));\n    \n    return { success: true };\n  }),\n```\n\n### Frontend Hook\n```typescript\n// apps/mobile/hooks/use-items-trpc.ts\nexport function useUnbookmarkItem() {\n  const utils = trpc.useUtils();\n  \n  return trpc.items.unbookmark.useMutation({\n    onMutate: async ({ id }) =\u003e {\n      // 1. Cancel outgoing queries\n      await utils.items.library.cancel();\n      await utils.items.inbox.cancel();\n      \n      // 2. Snapshot current data\n      const previousLibrary = utils.items.library.getData();\n      const previousInbox = utils.items.inbox.getData();\n      \n      // 3. Optimistically remove from library\n      utils.items.library.setData(undefined, (old) =\u003e ({\n        ...old,\n        items: old?.items.filter((item) =\u003e item.id !== id) ?? [],\n      }));\n      \n      // Note: We don't have full item data to add to inbox,\n      // so inbox will refresh on settle\n      \n      return { previousLibrary, previousInbox };\n    },\n    onError: (err, { id }, context) =\u003e {\n      // Rollback on error\n      if (context?.previousLibrary) {\n        utils.items.library.setData(undefined, context.previousLibrary);\n      }\n    },\n    onSettled: () =\u003e {\n      // Refresh both lists\n      utils.items.library.invalidate();\n      utils.items.inbox.invalidate();\n    },\n  });\n}\n```\n\n## Files to Modify\n- `apps/worker/src/trpc/routers/items.ts` - Add unbookmark procedure\n- `apps/mobile/hooks/use-items-trpc.ts` - Add useUnbookmarkItem hook\n- `apps/mobile/app/item/[id].tsx` - Wire up bookmark toggle\n\n## Dependencies\n- P0.2 (tRPC types) should be done first for proper typing\n\n## Acceptance Criteria\n- [ ] `items.unbookmark` procedure exists\n- [ ] Returns error if item not in BOOKMARKED state\n- [ ] Item moves from Library back to Inbox\n- [ ] bookmarkedAt is cleared\n- [ ] Detail Page bookmark toggle works bidirectionally\n- [ ] Optimistic update removes from library immediately\n\n## State Machine Context\n```\nINBOX ←→ BOOKMARKED → ARCHIVED\n  ↓\nARCHIVED\n```\n\nThis task enables the `BOOKMARKED → INBOX` transition.\n\n## Estimated Effort\n1-2 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-28T09:49:23.376373-06:00","updated_at":"2025-12-28T10:31:34.128693-06:00","closed_at":"2025-12-28T10:31:34.128693-06:00","dependencies":[{"issue_id":"zine-b4h.5","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:23.376778-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.5","depends_on_id":"zine-b4h.2","type":"blocks","created_at":"2025-12-28T09:58:09.471196-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.6","title":"P1.1: Split index.tsx Home screen into components (~1040 lines)","description":"# P1.1: Split index.tsx Home Screen into Components (~1041 lines)\n\n## Problem Statement\n`apps/mobile/app/(tabs)/index.tsx` is **1,041 lines** containing:\n- 8 inline icon definitions (lines 38-100) duplicating `/components/icons/`\n- Mock data arrays (lines 157-242)\n- 5 inline components (PressableScale, SectionHeader, FeaturedCard, ContentCard, QuickStats)\n- Helper functions mixed with JSX\n- ~180-line HomeScreen component\n- ~370-line StyleSheet with some unused styles\n\n## Why This Matters (P1)\n\n### Code Organization Issues\n- Every change requires understanding 1000+ lines\n- Components can't be reused elsewhere\n- Testing individual pieces is impossible\n\n### Existing Shared Components Not Used\nThe file defines inline icons when `/components/icons/` already has:\n- PlayIcon, BookmarkIcon, HeadphonesIcon, VideoIcon, ArticleIcon\n- ChevronRightIcon, SettingsIcon, SparklesIcon\n\n## Proposed Structure\n```\napps/mobile/\n├── app/(tabs)/index.tsx              # ~150 lines (composition only)\n└── components/home/\n    ├── index.tsx                     # Barrel exports\n    ├── featured-card.tsx             # Hero card with gradient\n    ├── section-header.tsx            # \"Jump Back In\" headers\n    ├── content-card.tsx              # Standard content cards\n    ├── quick-stats.tsx               # Stats row\n    ├── pressable-scale.tsx           # Animated pressable wrapper\n    └── home.styles.ts                # Shared styles\n```\n\n## Implementation Strategy\n\n### Phase 1: Extract Without Changing\n1. Create `/components/home/` directory\n2. Move inline components verbatim to new files\n3. Update imports in index.tsx\n4. Verify no visual changes\n\n### Phase 2: Use Shared Icons\nReplace inline icon definitions with imports from `/components/icons/`\n\n### Phase 3: Clean Up\n- Remove mock data (podcasts, videos arrays) or move to fixtures\n- Remove unused styles\n- Extract constants (SCREEN_WIDTH, CARD_WIDTH, HERO_CARD_HEIGHT)\n\n## Extraction Order (by dependencies)\n1. `pressable-scale.tsx` - No dependencies\n2. `section-header.tsx` - Uses ChevronRightIcon\n3. `quick-stats.tsx` - Uses icons from /components/icons\n4. `content-card.tsx` - Uses icons, PressableScale\n5. `featured-card.tsx` - Uses icons\n6. Update index.tsx to import all\n\n## Files to Create\n- `apps/mobile/components/home/index.tsx`\n- `apps/mobile/components/home/pressable-scale.tsx`\n- `apps/mobile/components/home/section-header.tsx`\n- `apps/mobile/components/home/featured-card.tsx`\n- `apps/mobile/components/home/content-card.tsx`\n- `apps/mobile/components/home/quick-stats.tsx`\n- `apps/mobile/components/home/home.styles.ts` (optional)\n\n## Files to Modify\n- `apps/mobile/app/(tabs)/index.tsx` (reduce to ~150 lines)\n\n## Dependencies\n- P1.2 (Icon consolidation) - Should consolidate icons first for cleaner refactor\n- P0.3 (Test infrastructure) - Ideally have tests before refactoring\n\n## Acceptance Criteria\n- [ ] index.tsx under 200 lines\n- [ ] Each component in its own file\n- [ ] No inline icon definitions\n- [ ] No visual changes (screenshot comparison)\n- [ ] Mock data removed or isolated\n- [ ] Unused styles removed\n- [ ] Each component independently importable\n\n## Risk Mitigation\n- Screenshot before/after\n- Incremental commits per component\n- Keep StyleSheet initially, extract after components work\n\n## Estimated Effort\n4-5 hours","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:23.573612-06:00","updated_at":"2025-12-28T12:14:42.455508-06:00","dependencies":[{"issue_id":"zine-b4h.6","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:23.574006-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.6","depends_on_id":"zine-b4h.3","type":"blocks","created_at":"2025-12-28T10:31:58.56874-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-b4h.6","depends_on_id":"zine-b4h.7","type":"blocks","created_at":"2025-12-28T10:53:43.807022-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.7","title":"P1.2: Consolidate duplicate icon definitions","description":"# P1.2: Consolidate Duplicate Icon Definitions\n\n## Problem Statement\nSVG icons are defined inline in `index.tsx` (lines 38-100) instead of using the existing centralized `/components/icons/` folder.\n\n## Evidence from Code Review\n\n### Already in /components/icons/ (18 files):\n```\narchive-icon.tsx    check-icon.tsx       headphones-icon.tsx  play-icon.tsx     share-icon.tsx\narticle-icon.tsx    chevron-right-icon.tsx  inbox-arrow-icon.tsx  plus-icon.tsx    sparkles-icon.tsx\nbookmark-icon.tsx   filter-icon.tsx      index.tsx            search-icon.tsx   video-icon.tsx\n                                                              settings-icon.tsx\n```\n\n### Inline in index.tsx (lines 38-100):\n- PlayIcon, BookmarkIcon, HeadphonesIcon, VideoIcon, ArticleIcon\n- ChevronRightIcon, SettingsIcon, SparklesIcon\n\n**All 8 inline icons already exist in /components/icons/!**\n\n## Additional Duplicates to Check\nFiles that may also have inline icons:\n- `apps/mobile/app/(tabs)/library.tsx`\n- `apps/mobile/app/(tabs)/inbox.tsx`\n- `apps/mobile/app/item/[id].tsx`\n- `apps/mobile/app/onboarding/select-channels.tsx`\n\n## Implementation\n\n### Step 1: Update index.tsx imports\n```typescript\n// Before (inline definitions)\nfunction PlayIcon({ size = 24, color = '#fff' }) { ... }\n\n// After (import from components/icons)\nimport { \n  PlayIcon, \n  BookmarkIcon, \n  HeadphonesIcon, \n  VideoIcon, \n  ArticleIcon,\n  ChevronRightIcon,\n  SettingsIcon,\n  SparklesIcon \n} from '@/components/icons';\n```\n\n### Step 2: Remove inline definitions\nDelete lines 38-100 from index.tsx (all 8 icon components)\n\n### Step 3: Audit other files\n```bash\ngrep -r \"function.*Icon\" apps/mobile/app --include=\"*.tsx\" | grep -v node_modules\n```\nFix any other inline icon definitions found.\n\n### Step 4: Verify icon props match\nEnsure all icons in /components/icons/ accept:\n```typescript\ninterface IconProps {\n  size?: number;\n  color?: string;\n}\n```\n\n## Files to Modify\n- `apps/mobile/app/(tabs)/index.tsx` - Remove inline icons (lines 38-100), add imports\n- Potentially other files found in audit\n\n## Files Already Complete (no changes needed)\n- `apps/mobile/components/icons/*.tsx` - Already contains all needed icons\n\n## Acceptance Criteria\n- [ ] Zero inline icon definitions in app/ directory\n- [ ] All icons imported from components/icons/\n- [ ] No visual changes to icons\n- [ ] Icons barrel exported from components/icons/index.tsx\n- [ ] Consistent IconProps interface across all icons\n\n## Dependencies\n- None - this should be done early as other tasks benefit from it\n\n## Estimated Effort\n1-2 hours (mainly mechanical replacement)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:23.772363-06:00","updated_at":"2025-12-28T12:08:44.986572-06:00","closed_at":"2025-12-28T12:08:44.986572-06:00","close_reason":"Completed: Consolidated duplicate icons in index.tsx, inbox.tsx, library.tsx, and connect.tsx. Provider-specific icons (YouTube, Spotify) kept local as they're screen-specific.","dependencies":[{"issue_id":"zine-b4h.7","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:23.772798-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.8","title":"P1.3: Consolidate duplicate UIContentType and mapContentType","description":"# P1.3: Consolidate duplicate UIContentType and mapContentType\n\n## Problem Statement\nTwo files define `UIContentType` and `mapContentType()`:\n- `apps/mobile/hooks/use-items-trpc.ts` (lines 18-41)\n- `apps/mobile/lib/content-utils.ts` (lines 20-67)\n\n## Evidence After Code Review\n\n### In use-items-trpc.ts (lines 18-41):\n```typescript\nexport type UIContentType = 'video' | 'podcast' | 'article' | 'post';\nexport function mapContentType(contentType: ContentType): UIContentType {\n  return contentType.toLowerCase() as UIContentType;\n}\n```\n\n### In lib/content-utils.ts (lines 20-67):\n```typescript\nexport type UIContentType = 'video' | 'podcast' | 'article' | 'post';\nexport function mapContentType(apiType: ContentType): UIContentType {\n  return apiType.toLowerCase() as UIContentType;\n}\n```\n\n**Implementations are identical.**\n\n## Why This Matters\n\n### Confusion Risk\nDevelopers import from different locations inconsistently.\n\n### Single Source of Truth\n`lib/content-utils.ts` is the canonical location - it has:\n- Full documentation\n- Additional helper functions (getContentIcon, getContentColor, etc.)\n- Clear module purpose\n\n## Implementation\n\n1. **Remove from use-items-trpc.ts:**\n   - Delete `UIContentType` type (lines 18-19)\n   - Delete `mapContentType` function (lines 39-41)\n   - Add import from content-utils\n\n2. **Update imports:**\n   ```typescript\n   // hooks/use-items-trpc.ts\n   import { mapContentType, type UIContentType } from '@/lib/content-utils';\n   ```\n\n3. **Verify no other duplicates:**\n   ```bash\n   grep -r \"type UIContentType\" apps/mobile\n   grep -r \"function mapContentType\" apps/mobile\n   ```\n\n## Files to Modify\n- `apps/mobile/hooks/use-items-trpc.ts` - Remove duplicates, add import\n- `apps/mobile/lib/content-utils.ts` - Already correct (no changes needed)\n\n## Acceptance Criteria\n- [ ] Single definition of UIContentType in lib/content-utils.ts\n- [ ] Single definition of mapContentType in lib/content-utils.ts\n- [ ] use-items-trpc.ts imports from content-utils\n- [ ] No duplicate type/function definitions\n- [ ] All usages compile correctly\n\n## Estimated Effort\n15-20 minutes (simpler than originally estimated)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:23.969794-06:00","updated_at":"2025-12-28T12:10:47.351627-06:00","closed_at":"2025-12-28T12:10:47.351627-06:00","close_reason":"Consolidated UIContentType, UIProvider, mapContentType, and mapProvider to lib/content-utils.ts. Updated use-items-trpc.ts and use-items.ts to import from the canonical location. All typechecks and tests pass.","dependencies":[{"issue_id":"zine-b4h.8","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:23.970243-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-b4h.9","title":"P1.4: Consolidate duplicate formatDuration implementations","description":"# P1.4: Consolidate duplicate formatDuration implementations\n\n## Problem Statement\n`formatDuration()` is implemented in two places:\n- `apps/mobile/hooks/use-items-trpc.ts` (lines 69-81)\n- `apps/mobile/lib/format.ts` (lines 28-40)\n\n## Evidence After Code Review\n\n### In use-items-trpc.ts:\n```typescript\nexport function formatDuration(seconds?: number | null): string | undefined {\n  if (seconds === undefined || seconds === null) return undefined;\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = seconds % 60;\n  if (hours \u003e 0) {\n    return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;\n  }\n  return `${minutes}:${String(secs).padStart(2, '0')}`;\n}\n```\nReturns timestamp format like \"1:02:05\" or \"2:05\"\n\n### In lib/format.ts:\n```typescript\nexport function formatDuration(seconds: number | null | undefined): string {\n  if (seconds === null || seconds === undefined) return '';\n  if (seconds \u003c 0) return '';\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  if (hours \u003e 0) { return `${hours}h ${minutes}m`; }\n  return `${minutes}m`;\n}\n```\nReturns friendly format like \"1h 2m\" or \"45m\"\n\n**IMPORTANT: These are DIFFERENT implementations with different purposes!**\n\n## Analysis\n- **use-items-trpc.ts version**: Timestamp format for video players (\"1:02:05\")\n- **lib/format.ts version**: Friendly format for cards (\"1h 2m\")\n\nThe lib/format.ts file also has `formatDurationTimestamp()` which serves the same purpose as the use-items-trpc.ts version.\n\n## Correct Solution\n\n1. **Keep both formats in lib/format.ts** (already there):\n   - `formatDuration()` - friendly \"1h 2m\" format\n   - `formatDurationTimestamp()` - player \"1:02:05\" format\n\n2. **Update use-items-trpc.ts to import from format.ts:**\n   ```typescript\n   import { formatDurationTimestamp } from '@/lib/format';\n   // Use formatDurationTimestamp where timestamp format is needed\n   ```\n\n3. **Rename or alias as needed for backward compatibility**\n\n## Files to Modify\n- `apps/mobile/hooks/use-items-trpc.ts` - Remove duplicate, import from format.ts\n- `apps/mobile/lib/format.ts` - Already has both versions (no changes needed)\n\n## Acceptance Criteria\n- [ ] Single source of truth for duration formatting in lib/format.ts\n- [ ] use-items-trpc.ts imports formatDurationTimestamp from format.ts\n- [ ] No duplicate implementations\n- [ ] Correct format used in correct contexts (friendly vs timestamp)\n\n## Estimated Effort\n20-30 minutes\n\n## Note\nOriginal bead assumed implementations were identical - they are NOT. The consolidation still makes sense but requires using the correct function for each use case.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:24.165937-06:00","updated_at":"2025-12-28T12:13:19.985041-06:00","closed_at":"2025-12-28T12:13:19.985041-06:00","close_reason":"Consolidated formatDuration to lib/format.ts. Removed duplicate wrapper from use-items-trpc.ts. format.ts has both formatDuration (friendly: 1h 23m) and formatDurationTimestamp (player: 1:23:45). All typechecks pass, format tests pass.","dependencies":[{"issue_id":"zine-b4h.9","depends_on_id":"zine-b4h","type":"parent-child","created_at":"2025-12-28T09:49:24.166331-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-cvh","title":"Backend Spec Refinements: Incorporate Review Findings","description":"Incorporate findings from the epic zine-teq review into features/subscriptions/backend-spec.md.\n\n## Overview\nThe review of epic zine-teq identified several gaps, inconsistencies, and missing context in the backend specification. This epic tracks the work to update the spec document to reflect these findings.\n\n## Key Findings to Address\n\n### 1. Schema Conflict with Existing Tables (CRITICAL)\n**Issue**: The spec proposes `provider_items_seen` as a new table, but it already exists in `apps/worker/src/db/schema.ts` with a compatible but slightly different structure.\n\n**Required Changes**:\n- Add a \"Current Schema Analysis\" section documenting existing tables\n- Clarify that `provider_items_seen` is an existing table, not new\n- Document how `sourceId` will store subscription IDs going forward\n\n### 2. Timestamp Format Inconsistency (CRITICAL)\n**Issue**: The spec uses Unix milliseconds for all timestamps, but existing tables use ISO8601 strings.\n\n**Required Changes**:\n- Add explicit \"Timestamp Format Bridge\" section\n- Document the conversion strategy in ingestion pipeline\n- Update code examples to show ISO8601 conversion for existing tables\n\n### 3. Missing user_notifications Table\n**Issue**: Section 6.7 mentions user notifications but doesn't define the schema.\n\n**Required Changes**:\n- Add `user_notifications` table definition to Section 1.2\n- Include notification types enum\n- Document deduplication strategy\n\n### 4. Missing tRPC Input/Output Types\n**Issue**: Frontend spec references tRPC procedures without explicit type definitions.\n\n**Required Changes**:\n- Add \"tRPC Contract\" section with Zod schemas for all inputs\n- Add response type definitions\n- Cross-reference with frontend-spec.md\n\n### 5. Initial Fetch Clarity\n**Issue**: Initial fetch semantics are mentioned but the relationship to subscription creation isn't explicit.\n\n**Required Changes**:\n- Clarify that initial fetch happens during `subscriptions.add`\n- Add sequence diagram showing the flow\n- Document edge cases (empty channels, scheduled content)\n\n### 6. Dependency on Rate Limiter in Polling\n**Issue**: Polling section doesn't explicitly mention rate limiting integration.\n\n**Required Changes**:\n- Add rate limit check to polling batch processing examples\n- Cross-reference Section 3.7 (Rate Limiting Strategy)\n\n## Related Documentation\n- Backend spec: features/subscriptions/backend-spec.md\n- Frontend spec: features/subscriptions/frontend-spec.md\n- Existing schema: apps/worker/src/db/schema.ts\n- Epic zine-teq: Subscriptions Backend Implementation\n- Epic zine-lfp: Frontend Spec Review findings","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T22:28:28.214007-06:00","updated_at":"2025-12-16T22:38:37.824724-06:00","closed_at":"2025-12-16T22:38:37.824724-06:00"}
{"id":"zine-cvh.1","title":"Add Current Schema Analysis section to backend-spec.md","description":"Add a section to backend-spec.md documenting the existing database schema and how the new subscriptions tables interact with it.\n\n## Changes Required\n\n### Add Section 1.0: Current Schema Analysis\nInsert before Section 1.1 (Entity Relationships):\n\n```markdown\n## 1.0 Current Schema Analysis\n\nBefore implementing the subscriptions feature, we must understand the existing database schema in `apps/worker/src/db/schema.ts`.\n\n### Existing Tables\n\n| Table | Purpose | Relevance to Subscriptions |\n|-------|---------|---------------------------|\n| `users` | User accounts (Clerk IDs) | FK target for all subscription tables |\n| `items` | Canonical content (shared across users) | Subscription items write here |\n| `user_items` | User's relationship to content | New inbox items created here |\n| `sources` | Legacy subscriptions (RSS, etc.) | **NOT USED** - new `subscriptions` table instead |\n| `provider_items_seen` | Ingestion idempotency | **REUSED** for subscription deduplication |\n\n### Key Insight: provider_items_seen Already Exists\n\nThe `provider_items_seen` table is already implemented and compatible with our needs:\n\n\\`\\`\\`sql\n-- Existing schema (apps/worker/src/db/schema.ts)\nCREATE TABLE provider_items_seen (\n  id TEXT PRIMARY KEY,           -- ULID\n  user_id TEXT NOT NULL,\n  provider TEXT NOT NULL,\n  provider_item_id TEXT NOT NULL,\n  source_id TEXT,                -- Will store subscription.id going forward\n  first_seen_at TEXT NOT NULL,   -- ISO8601 (existing convention)\n  UNIQUE(user_id, provider, provider_item_id)\n);\n\\`\\`\\`\n\n**Migration Strategy**: No schema changes needed. The `source_id` column will store `subscriptions.id` values instead of the legacy `sources.id`.\n\n### Why Not Use the Existing `sources` Table?\n\nThe `sources` table was designed for RSS/feed-based subscriptions with a `feed_url` column. OAuth-based subscriptions (YouTube, Spotify) require:\n- OAuth credential storage (separate `provider_connections` table)\n- Provider-specific channel/show IDs (not URLs)\n- Polling state management (intervals, last polled timestamps)\n\nA new `subscriptions` table better models these requirements.\n```\n\n## Files to Modify\n- features/subscriptions/backend-spec.md\n\n## Acceptance Criteria\n- [ ] Section 1.0 added before Section 1.1\n- [ ] Existing tables documented with relevance\n- [ ] provider_items_seen reuse explained\n- [ ] Rationale for new subscriptions table vs sources","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:28:58.011445-06:00","updated_at":"2025-12-16T22:32:38.279622-06:00","closed_at":"2025-12-16T22:32:38.279622-06:00","dependencies":[{"issue_id":"zine-cvh.1","depends_on_id":"zine-cvh","type":"parent-child","created_at":"2025-12-16T22:28:58.011792-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-cvh.2","title":"Add Timestamp Format Bridge section to backend-spec.md","description":"Document the timestamp format differences between existing and new tables, with conversion examples.\n\n## Changes Required\n\n### Update Section 1.2.1 (Timestamp Convention)\nReplace the current section with expanded content:\n\n```markdown\n### 1.2.1 Timestamp Convention\n\n**CRITICAL**: The codebase uses TWO different timestamp formats. Understanding this is essential for correct implementation.\n\n#### Format Comparison\n\n| Tables | Format | Example | Why |\n|--------|--------|---------|-----|\n| `items`, `user_items`, `sources`, `provider_items_seen` | ISO8601 strings | `\"2024-01-15T10:00:00.000Z\"` | Legacy format, human-readable |\n| `provider_connections`, `subscriptions`, `subscription_items`, `user_notifications` | Unix milliseconds | `1705312800000` | Matches JS `Date.now()`, efficient comparisons |\n\n#### Conversion Guidelines\n\n**New subscription code → Existing tables**:\n\\`\\`\\`typescript\n// When writing to items, user_items, provider_items_seen\nconst isoTimestamp = new Date(unixMs).toISOString();\n\n// Example in ingestion pipeline\nawait tx.insert(items).values({\n  ...itemData,\n  publishedAt: new Date(transformedItem.publishedAt).toISOString(),\n  createdAt: new Date().toISOString(),\n  updatedAt: new Date().toISOString(),\n});\n\\`\\`\\`\n\n**Reading from existing tables → New code**:\n\\`\\`\\`typescript\n// When reading ISO timestamps into subscription logic\nconst unixMs = new Date(item.publishedAt).getTime();\n\\`\\`\\`\n\n#### Why Two Formats?\n\n1. **Backwards compatibility**: Changing existing tables would require data migration\n2. **New tables optimized for polling**: Unix ms enables efficient `lastPolledAt \u003c now - interval` comparisons\n3. **JavaScript alignment**: New tables use `Date.now()` directly, avoiding string parsing\n\n#### SQL Defaults\n\n**Existing tables** (ISO8601):\n\\`\\`\\`sql\ncreated_at TEXT NOT NULL DEFAULT (datetime('now'))\n\\`\\`\\`\n\n**New tables** (Unix ms):\n\\`\\`\\`sql\ncreated_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000)\n\\`\\`\\`\n```\n\n## Files to Modify\n- features/subscriptions/backend-spec.md\n\n## Acceptance Criteria\n- [ ] Format comparison table added\n- [ ] Conversion code examples included\n- [ ] Rationale for two formats explained\n- [ ] SQL default syntax for both formats documented","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:29:12.463328-06:00","updated_at":"2025-12-16T22:33:56.24912-06:00","closed_at":"2025-12-16T22:33:56.24912-06:00","dependencies":[{"issue_id":"zine-cvh.2","depends_on_id":"zine-cvh","type":"parent-child","created_at":"2025-12-16T22:29:12.463659-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-cvh.3","title":"Add user_notifications table schema to backend-spec.md","description":"Add the user_notifications table definition that Section 6.7 references but doesn't define.\n\n## Changes Required\n\n### Add to Section 1.2 (New Tables)\nAfter `subscription_items`, add:\n\n```markdown\n#### `user_notifications`\n\nSystem notifications for connection health, poll failures, and other alerts.\n\n| Column        | Type        | Description                              |\n| ------------- | ----------- | ---------------------------------------- |\n| `id`          | TEXT (ULID) | Primary key                              |\n| `user_id`     | TEXT        | FK to users                              |\n| `type`        | TEXT        | Notification type (see enum below)       |\n| `provider`    | TEXT        | YOUTUBE, SPOTIFY, or NULL for system     |\n| `title`       | TEXT        | Short title for display                  |\n| `message`     | TEXT        | Full notification message                |\n| `data`        | TEXT        | JSON with additional context             |\n| `read_at`     | INTEGER     | Unix ms when user read notification      |\n| `resolved_at` | INTEGER     | Unix ms when auto-resolved               |\n| `created_at`  | INTEGER     | Unix ms (default: now)                   |\n\n**Unique constraint**: `(user_id, type, provider) WHERE resolved_at IS NULL`\n- Prevents duplicate active notifications of the same type\n\n**Indexes**:\n- `idx_user_notifications_inbox` on `(user_id, resolved_at, created_at DESC)` - for inbox queries\n\n#### Notification Types\n\n| Type | Trigger | Auto-resolves |\n|------|---------|---------------|\n| `connection_expired` | OAuth refresh fails | On successful reconnect |\n| `connection_revoked` | Provider returns 403 | On successful reconnect |\n| `poll_failures` | 3+ consecutive poll errors | On successful poll |\n| `quota_warning` | YouTube quota \u003e 80% | Next day (quota reset) |\n```\n\n### Add to Section 1.4 (Extended Enums)\n\n```typescript\n// Notification types for user alerts\nexport enum NotificationType {\n  CONNECTION_EXPIRED = 'connection_expired',\n  CONNECTION_REVOKED = 'connection_revoked',\n  POLL_FAILURES = 'poll_failures',\n  QUOTA_WARNING = 'quota_warning',\n}\n```\n\n## Files to Modify\n- features/subscriptions/backend-spec.md\n\n## Acceptance Criteria\n- [ ] Table definition added to Section 1.2\n- [ ] NotificationType enum added to Section 1.4\n- [ ] Deduplication constraint explained\n- [ ] Auto-resolution behavior documented","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:29:26.857885-06:00","updated_at":"2025-12-16T22:35:25.649783-06:00","closed_at":"2025-12-16T22:35:25.649783-06:00","dependencies":[{"issue_id":"zine-cvh.3","depends_on_id":"zine-cvh","type":"parent-child","created_at":"2025-12-16T22:29:26.858253-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-cvh.4","title":"Add tRPC Contract section with Zod input/output schemas","description":"Add explicit Zod schemas for all tRPC endpoints to align frontend and backend.\n\n## Changes Required\n\n### Add Section 5.2: tRPC Contract\nAfter Section 5.1 (Router Structure), add:\n\n```markdown\n### 5.2 tRPC Contract (Input/Output Schemas)\n\nThese Zod schemas define the API contract. They should be exported from `packages/shared/src/schemas/index.ts` for use by both frontend and backend.\n\n#### Connection Endpoints\n\n\\`\\`\\`typescript\n// connections.registerState\nexport const RegisterOAuthStateInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n  state: z.string().uuid(),\n});\n// Returns: { success: boolean }\n\n// connections.callback\nexport const OAuthCallbackInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n  code: z.string().min(1),\n  state: z.string().uuid(),\n  codeVerifier: z.string().min(43).max(128),\n});\n// Returns: { success: boolean }\n\n// connections.list\n// Input: none (uses ctx.userId)\n// Returns: { YOUTUBE: ConnectionInfo | null, SPOTIFY: ConnectionInfo | null }\n\nexport const ConnectionInfo = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n  status: z.enum(['ACTIVE', 'EXPIRED', 'REVOKED']),\n  connectedAt: z.number(),\n  lastRefreshedAt: z.number().nullable(),\n});\n\n// connections.disconnect\nexport const DisconnectInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n});\n// Returns: { success: boolean }\n\\`\\`\\`\n\n#### Subscription Endpoints\n\n\\`\\`\\`typescript\n// subscriptions.list\nexport const ListSubscriptionsInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']).optional(),\n  status: z.enum(['ACTIVE', 'PAUSED', 'DISCONNECTED', 'UNSUBSCRIBED']).optional(),\n  limit: z.number().min(1).max(100).default(50),\n  cursor: z.string().optional(),\n});\n\nexport const ListSubscriptionsResponse = z.object({\n  items: z.array(SubscriptionSchema),\n  nextCursor: z.string().nullable(),\n  hasMore: z.boolean(),\n});\n\nexport const SubscriptionSchema = z.object({\n  id: z.string(),\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n  providerChannelId: z.string(),\n  name: z.string(),\n  description: z.string().nullable(),\n  imageUrl: z.string().nullable(),\n  externalUrl: z.string().nullable(),\n  status: z.enum(['ACTIVE', 'PAUSED', 'DISCONNECTED', 'UNSUBSCRIBED']),\n  lastPolledAt: z.number().nullable(),\n  pollIntervalSeconds: z.number(),\n  createdAt: z.number(),\n});\n\n// subscriptions.add\nexport const AddSubscriptionInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n  providerChannelId: z.string().min(1),\n  name: z.string().optional(),\n  imageUrl: z.string().url().optional(),\n});\n// Returns: { subscriptionId: string, name: string, imageUrl: string | null }\n\n// subscriptions.remove\nexport const RemoveSubscriptionInput = z.object({\n  subscriptionId: z.string(),\n});\n// Returns: { success: boolean }\n\n// subscriptions.pause / subscriptions.resume\nexport const PauseResumeInput = z.object({\n  subscriptionId: z.string(),\n});\n// Returns: { success: boolean }\n\n// subscriptions.syncNow\nexport const SyncNowInput = z.object({\n  subscriptionId: z.string(),\n});\n// Returns: { success: boolean, itemsFound: number }\n\\`\\`\\`\n\n#### Discovery Endpoints\n\n\\`\\`\\`typescript\n// discover.available\nexport const DiscoverAvailableInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n});\n\nexport const DiscoverAvailableResponse = z.array(z.object({\n  providerChannelId: z.string(),\n  name: z.string(),\n  description: z.string().nullable(),\n  imageUrl: z.string().nullable(),\n  subscriberCount: z.number().nullable(),\n  isSubscribed: z.boolean(),\n}));\n\n// discover.search\nexport const SearchChannelsInput = z.object({\n  provider: z.enum(['YOUTUBE', 'SPOTIFY']),\n  query: z.string().min(1).max(100),\n  limit: z.number().min(1).max(50).default(20),\n});\n// Returns: same shape as DiscoverAvailableResponse\n\\`\\`\\`\n```\n\n## Files to Modify\n- features/subscriptions/backend-spec.md\n- (Reference) features/subscriptions/frontend-spec.md - for alignment verification\n\n## Acceptance Criteria\n- [ ] All endpoint inputs have Zod schemas\n- [ ] Response types documented\n- [ ] Schemas match frontend-spec.md usage\n- [ ] Note about shared package export location","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:29:46.658558-06:00","updated_at":"2025-12-16T22:37:08.042424-06:00","closed_at":"2025-12-16T22:37:08.042424-06:00","dependencies":[{"issue_id":"zine-cvh.4","depends_on_id":"zine-cvh","type":"parent-child","created_at":"2025-12-16T22:29:46.658944-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-cvh.5","title":"Clarify initial fetch flow in subscription creation","description":"Make it explicit that initial fetch happens during subscription creation, with a sequence diagram.\n\n## Changes Required\n\n### Update Section 4.4 (Initial Fetch Semantics)\nExpand with sequence diagram and explicit timing:\n\n```markdown\n### 4.4 Initial Fetch Semantics\n\nInitial fetch happens **synchronously during `subscriptions.add()`**, not as a separate background job.\n\n#### Sequence Diagram\n\n\\`\\`\\`\nClient                    Server                    Provider API\n   |                         |                           |\n   |-- add(channelId) ------\u003e|                           |\n   |                         |-- validate connection ---\u003e|\n   |                         |\u003c-- connection OK ---------|\n   |                         |                           |\n   |                         |-- fetch latest item -----\u003e|\n   |                         |\u003c-- video/episode data ----|\n   |                         |                           |\n   |                         |-- BEGIN TRANSACTION       |\n   |                         |   - create subscription   |\n   |                         |   - ingest item (if any)  |\n   |                         |   - mark as seen          |\n   |                         |-- COMMIT                  |\n   |                         |                           |\n   |\u003c-- { subscriptionId } --|                           |\n\\`\\`\\`\n\n#### Why Synchronous?\n\n1. **User feedback**: User sees immediate confirmation that subscription worked\n2. **Inbox population**: At least one item appears in inbox right away\n3. **Error handling**: If provider API fails, subscription still created (graceful degradation)\n4. **Timestamp anchor**: `lastPolledAt` is set, so next poll knows where to start\n\n#### Error Handling\n\n| Scenario | Behavior |\n|----------|----------|\n| Provider API error | Log error, subscription created, no initial item |\n| Empty channel | Subscription created, no initial item |\n| Only scheduled content | Subscription created, no initial item |\n| Item already seen | Subscription created, item not duplicated |\n\nThe `add` mutation should **never fail** due to initial fetch errors. The subscription is the primary outcome; the initial item is a bonus.\n```\n\n## Files to Modify\n- features/subscriptions/backend-spec.md\n\n## Acceptance Criteria\n- [ ] Sequence diagram added showing flow\n- [ ] Synchronous timing explicitly stated\n- [ ] Error handling table included\n- [ ] Rationale for design choice documented","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:30:01.770371-06:00","updated_at":"2025-12-17T19:55:38.326225-06:00","closed_at":"2025-12-17T19:55:38.326225-06:00","dependencies":[{"issue_id":"zine-cvh.5","depends_on_id":"zine-cvh","type":"parent-child","created_at":"2025-12-16T22:30:01.770743-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-cvh.6","title":"Add rate limiter integration to polling examples","description":"Update the polling batch processing examples to show rate limiter integration.\n\n## Changes Required\n\n### Update Section 3.2 (Batch Processing Logic)\nAdd rate limit check to the example code:\n\n```typescript\nexport async function pollSubscriptions(env: Env) {\n  const now = Date.now();\n  const batchSize = 50;\n\n  const dueSubscriptions = await db.query.subscriptions.findMany({\n    where: and(\n      eq(subscriptions.status, 'ACTIVE'),\n      or(\n        isNull(subscriptions.lastPolledAt),\n        lt(subscriptions.lastPolledAt, sql`${now} - (${subscriptions.pollIntervalSeconds} * 1000)`)\n      )\n    ),\n    orderBy: [asc(subscriptions.lastPolledAt)],\n    limit: batchSize,\n  });\n\n  const byProvider = groupBy(dueSubscriptions, 'provider');\n  await Promise.all([\n    processYouTubeBatch(byProvider.YOUTUBE || [], env),\n    processSpotifyBatch(byProvider.SPOTIFY || [], env),\n  ]);\n}\n\nasync function processYouTubeBatch(subscriptions: Subscription[], env: Env) {\n  const byUser = groupBy(subscriptions, 'userId');\n  \n  for (const [userId, userSubs] of Object.entries(byUser)) {\n    // CHECK RATE LIMIT BEFORE PROCESSING\n    const rateCheck = await isRateLimited('YOUTUBE', userId, env.KV);\n    if (rateCheck.limited) {\n      console.log(`Skipping user ${userId}: rate limited for ${rateCheck.retryInMs}ms`);\n      continue;\n    }\n    \n    // ... rest of processing\n  }\n}\n```\n\n### Add Cross-Reference\nAdd note pointing to Section 3.7:\n\n```markdown\n\u003e **Rate Limiting**: Before processing any user's subscriptions, check if they're rate limited. See [Section 3.7: Rate Limiting Strategy](#37-rate-limiting-strategy) for the `isRateLimited()` implementation.\n```\n\n## Files to Modify\n- features/subscriptions/backend-spec.md\n\n## Acceptance Criteria\n- [ ] Rate limit check added to batch processing example\n- [ ] Cross-reference to Section 3.7 added\n- [ ] Clear comment explaining the check","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:30:14.095304-06:00","updated_at":"2025-12-16T22:38:12.254997-06:00","closed_at":"2025-12-16T22:38:12.254997-06:00","dependencies":[{"issue_id":"zine-cvh.6","depends_on_id":"zine-cvh","type":"parent-child","created_at":"2025-12-16T22:30:14.095666-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp","title":"Frontend Spec Review: Gaps, Inconsistencies, and Refinements","description":"Comprehensive review of features/subscriptions/frontend-spec.md identifying gaps, inconsistencies, missing context, and areas needing refinement. This epic tracks all findings from the spec proofreading and polish session.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T22:03:05.293187-06:00","updated_at":"2025-12-17T18:24:29.057831-06:00","closed_at":"2025-12-17T18:24:29.057831-06:00"}
{"id":"zine-lfp.1","title":"Missing hook implementations referenced in Settings screen","description":"**Issue**: The Settings screen (Section 3) references hooks that are not defined anywhere in the spec:\n- `useConnections()` - returns `{ data: connections }`\n- `useSubscriptions()` - returns `{ data: subscriptions }`\n\n**Location**: Lines 281-286 in frontend-spec.md\n\n**Problem**: These hooks are used to fetch provider connections and subscriptions, but there's no definition of:\n1. The hook implementation\n2. The tRPC endpoints they call\n3. The return type shape\n\n**Fix Required**: Add a dedicated \"Data Hooks\" section defining:\n```typescript\n// apps/mobile/hooks/use-connections.ts\nexport function useConnections() {\n  return trpc.subscriptions.connections.list.useQuery();\n}\n```\n\nAnd document the expected return types from the backend.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.366678-06:00","updated_at":"2025-12-16T22:48:21.481014-06:00","closed_at":"2025-12-16T22:48:21.481014-06:00","dependencies":[{"issue_id":"zine-lfp.1","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.367044-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.10","title":"Navigation structure missing settings layout file","description":"**Issue**: The navigation structure (Section 2) shows `settings/` as a route group but Expo Router requires a `_layout.tsx` file for navigation configuration.\n\n**Current structure** (lines 191-205):\n```\nsettings/\n├── index.tsx        # Settings main screen\n├── connections.tsx  # Manage connected providers\n├── account.tsx      # Account settings\n└── about.tsx        # App info, version, etc.\n```\n\n**Missing**:\n- `settings/_layout.tsx` - Required for:\n  - Stack navigator configuration\n  - Header styling\n  - Back navigation behavior\n  - Screen transition animations\n\n**Fix Required**: Add layout file specification:\n```typescript\n// apps/mobile/app/settings/_layout.tsx\nimport { Stack } from 'expo-router';\n\nexport default function SettingsLayout() {\n  return (\n    \u003cStack\n      screenOptions={{\n        headerBackTitle: 'Settings',\n        headerStyle: { backgroundColor: colors.background },\n        headerTintColor: colors.text,\n      }}\n    \u003e\n      \u003cStack.Screen name=\"index\" options={{ title: 'Settings' }} /\u003e\n      \u003cStack.Screen name=\"connections\" options={{ title: 'Connected Accounts' }} /\u003e\n      \u003cStack.Screen name=\"account\" options={{ title: 'Account' }} /\u003e\n      \u003cStack.Screen name=\"about\" options={{ title: 'About' }} /\u003e\n    \u003c/Stack\u003e\n  );\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.008989-06:00","updated_at":"2025-12-17T18:05:53.490781-06:00","closed_at":"2025-12-17T18:05:53.490781-06:00","dependencies":[{"issue_id":"zine-lfp.10","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.009344-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.11","title":"Error boundary examples mix Tailwind classes with StyleSheet","description":"**Issue**: Error boundary components (Section 8) mix Tailwind/NativeWind className syntax with React Native's StyleSheet approach, creating inconsistent and potentially non-functional code.\n\n**Examples**:\n- Line 1147: `\u003cView className=\"flex-1 items-center justify-center p-6\"\u003e`\n- Line 1149: `\u003cText className=\"text-xl font-semibold mb-2 text-gray-900 dark:text-white\"\u003e`\n- Line 1155: `\u003cPressable onPress={this.handleReset} className=\"bg-blue-500 px-6 py-3 rounded-lg\"\u003e`\n\n**Problem**: \n1. The codebase doesn't appear to use NativeWind (not in package.json, no nativewind config visible)\n2. Even if using NativeWind, dark mode classes (`dark:text-white`) require additional configuration\n3. Mixing approaches makes code harder to maintain\n\n**The Settings screen example** (Section 3) correctly uses StyleSheet:\n```typescript\nconst styles = StyleSheet.create({\n  sectionTitle: { fontSize: 12, fontWeight: '600', ... },\n});\n```\n\n**Fix Required**: Convert all className usage to StyleSheet, using the design system tokens:\n```typescript\n\u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n  \u003cText style={[styles.heading, { color: colors.text }]}\u003eSomething went wrong\u003c/Text\u003e\n\u003c/View\u003e\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.07911-06:00","updated_at":"2025-12-17T18:23:26.362951-06:00","closed_at":"2025-12-17T18:23:26.362951-06:00","dependencies":[{"issue_id":"zine-lfp.11","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.079441-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.12","title":"Missing TypeScript interface for InboxItem used in renderItem","description":"Added InboxItem TypeScript interface definition in Section 6.2 of frontend-spec.md","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.148812-06:00","updated_at":"2025-12-17T18:09:27.308761-06:00","closed_at":"2025-12-17T18:09:27.308761-06:00","dependencies":[{"issue_id":"zine-lfp.12","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.149133-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.13","title":"Offline queue retry logic lacks error type discrimination","description":"Added error type discrimination to offline queue retry logic in Section 9.3 of frontend-spec.md","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.22131-06:00","updated_at":"2025-12-17T18:05:54.629016-06:00","closed_at":"2025-12-17T18:05:54.629016-06:00","dependencies":[{"issue_id":"zine-lfp.13","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.221636-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.14","title":"Deep linking configuration references incorrect plugin syntax","description":"Fixed incorrect Expo plugin syntax in Section 7.1 of frontend-spec.md. Removed invalid `[\"expo-linking\", { \"scheme\": \"zine\" }]` plugin config and added `expo-web-browser`. Added explanatory note about why the configuration is correct for Expo SDK 50+.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:06.291247-06:00","updated_at":"2025-12-17T06:37:04.116413-06:00","closed_at":"2025-12-17T06:37:04.116413-06:00","dependencies":[{"issue_id":"zine-lfp.14","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.291614-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.15","title":"Missing Replicache integration context from local-first architecture","description":"**Issue**: The frontend spec's offline handling (Section 9) doesn't integrate with the local-first architecture documented in `docs/zine-sync-local-first.md`.\n\n**Architecture doc states**:\n- Replicache is the sync protocol\n- Client data is denormalized KV store\n- Server-authoritative truth via Durable Objects\n- Index strategy: `item/{id}`, `state/{id}`, `idx/list/{state}/{timeKey}/{id}`\n\n**Frontend spec states**:\n- Uses `AsyncStorage` for offline queue (line 1425)\n- Uses React Query for caching (`staleTime`, `gcTime`)\n- Uses tRPC directly with `fetch` under the hood\n\n**Disconnect**:\n1. If using Replicache, mutations should go through Replicache mutators, not tRPC directly\n2. Offline queue duplicates what Replicache provides natively\n3. React Query caching conflicts with Replicache's local KV store\n\n**Fix Required**: Clarify the architecture choice:\n- **Option A**: Remove offline queue, use Replicache for all data sync (aligns with local-first doc)\n- **Option B**: Clarify that subscriptions feature uses tRPC directly (not Replicache) and update local-first doc\n- **Option C**: Document hybrid approach where subscription metadata uses tRPC but inbox items use Replicache\n\nAdd a \"Data Architecture\" section to frontend spec explaining the relationship.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:06.36168-06:00","updated_at":"2025-12-17T06:42:39.074974-06:00","closed_at":"2025-12-17T06:42:39.074974-06:00","dependencies":[{"issue_id":"zine-lfp.15","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.36203-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.16","title":"SyncStatusIndicator animation may cause memory leak","description":"Fixed animation memory leak in SyncStatusIndicator component in frontend-spec.md","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.432299-06:00","updated_at":"2025-12-17T18:05:55.574088-06:00","closed_at":"2025-12-17T18:05:55.574088-06:00","dependencies":[{"issue_id":"zine-lfp.16","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.432672-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.17","title":"OAuth error handler completeOAuthFlow function not defined","description":"**Issue**: The `OAuthCallbackHandler` component (Section 7.6) calls `completeOAuthFlow` (line 943) which is dynamically imported but never defined anywhere in the spec.\n\n**Code reference**:\n```typescript\nconst { completeOAuthFlow } = await import('../lib/oauth');\nconst result = await completeOAuthFlow(params.code, params.state);\n```\n\n**Expected function signature**:\n```typescript\ninterface OAuthFlowResult {\n  success: boolean;\n  provider?: 'YOUTUBE' | 'SPOTIFY';\n  error?: string;\n}\n\nasync function completeOAuthFlow(code: string, state: string): Promise\u003cOAuthFlowResult\u003e\n```\n\n**Required implementation**:\n1. Parse provider from state (see bead zine-lfp.7)\n2. Retrieve PKCE verifier from SecureStore\n3. Call `trpc.subscriptions.connections.callback.mutate()`\n4. Clean up SecureStore entries\n5. Return success/failure with provider info\n\n**Fix Required**: Add complete function definition to Section 1 (OAuth Configuration):\n```typescript\nexport async function completeOAuthFlow(code: string, state: string): Promise\u003cOAuthFlowResult\u003e {\n  const [provider, stateId] = state.split(':') as ['YOUTUBE' | 'SPOTIFY', string];\n  \n  const storedState = await SecureStore.getItemAsync(`${provider.toLowerCase()}_oauth_state`);\n  if (storedState !== state) {\n    return { success: false, error: 'State mismatch' };\n  }\n  \n  const verifier = await SecureStore.getItemAsync(`${provider.toLowerCase()}_code_verifier`);\n  if (!verifier) {\n    return { success: false, error: 'Verifier not found' };\n  }\n  \n  try {\n    await trpc.subscriptions.connections.callback.mutate({ provider, code, state: stateId, codeVerifier: verifier });\n    await SecureStore.deleteItemAsync(`${provider.toLowerCase()}_code_verifier`);\n    await SecureStore.deleteItemAsync(`${provider.toLowerCase()}_oauth_state`);\n    return { success: true, provider };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:06.504364-06:00","updated_at":"2025-12-17T06:44:29.254966-06:00","closed_at":"2025-12-17T06:44:29.254966-06:00","dependencies":[{"issue_id":"zine-lfp.17","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.504695-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.18","title":"Missing Surface component import in inbox screen example","description":"Fixed: Replaced undefined `Surface` component with `View` and added proper imports for all React Native components used in the inbox screen example.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.579381-06:00","updated_at":"2025-12-17T18:09:28.189696-06:00","closed_at":"2025-12-17T18:09:28.189696-06:00","dependencies":[{"issue_id":"zine-lfp.18","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.579749-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.19","title":"Inconsistent RefreshControl props between empty and populated states","description":"**Issue**: The inbox screen's RefreshControl props differ between the empty state ScrollView and the populated FlatList, leading to inconsistent behavior.\n\n**Empty state** (lines 595-600):\n```typescript\n\u003cRefreshControl\n  refreshing={isRefreshing}\n  onRefresh={handleRefresh}\n  tintColor={colors.primary}\n/\u003e\n```\n\n**Populated state** (lines 611-618):\n```typescript\n\u003cRefreshControl\n  refreshing={isRefreshing}\n  onRefresh={handleRefresh}\n  tintColor={colors.primary}\n  colors={[colors.primary]}  // Android-specific, missing from empty state\n  progressBackgroundColor={colors.background}  // Android-specific, missing from empty state\n/\u003e\n```\n\n**Problems**:\n1. Android users will see different refresh indicator styling between empty and populated states\n2. The `colors` prop is an array (Android uses multiple colors in sequence)\n3. Missing `progressViewOffset` for consistent positioning\n\n**Fix Required**: Create a shared RefreshControl configuration:\n```typescript\nconst refreshControlProps = {\n  refreshing: isRefreshing,\n  onRefresh: handleRefresh,\n  tintColor: colors.primary,\n  colors: [colors.primary],\n  progressBackgroundColor: colors.background,\n  progressViewOffset: 0,\n};\n\n// Usage:\n\u003cRefreshControl {...refreshControlProps} /\u003e\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.650037-06:00","updated_at":"2025-12-17T18:09:29.008223-06:00","closed_at":"2025-12-17T18:09:29.008223-06:00","dependencies":[{"issue_id":"zine-lfp.19","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.650378-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.2","title":"Inconsistent theme token usage across code examples","description":"Added styling convention notes and theme token reference. Enhanced top-level Styling Convention with emoji warning, explicit \"MUST\" language, and theme token reference table. Added styling notes to SyncNowButton (6.3) and OfflineBanner (9.2) sections. SyncStatusIndicator was already converted to StyleSheet by another agent.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:05.437392-06:00","updated_at":"2025-12-17T18:05:56.356694-06:00","closed_at":"2025-12-17T18:05:56.356694-06:00","dependencies":[{"issue_id":"zine-lfp.2","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.437755-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.20","title":"Settings screen missing imports section and hook definitions","description":"**Issue**: The Settings screen code (Section 3) jumps directly into the component without showing necessary imports, making it incomplete as a reference implementation.\n\n**Missing imports**:\n```typescript\n// Required imports not shown:\nimport { View, Text, ScrollView, Pressable, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Colors, Typography, Spacing, Radius } from '@/constants/theme';\nimport { useColorScheme } from '@/hooks/use-color-scheme';\nimport { useAuth } from '@/providers/auth-provider';\n\n// These hooks are used but not defined:\nimport { useConnections } from '@/hooks/use-connections';\nimport { useSubscriptions } from '@/hooks/use-subscriptions';\n```\n\n**Missing hook definitions**:\n1. `useConnections()` - Should return provider connection status\n2. `useSubscriptions()` - Should return subscription list with count\n\n**Fix Required**: \n1. Add imports section at top of code block\n2. Add \"Prerequisites\" callout noting dependent hooks\n3. Either inline simple hook implementations or reference a \"Data Hooks\" section:\n\n```typescript\n// apps/mobile/hooks/use-connections.ts\nexport function useConnections() {\n  return trpc.subscriptions.connections.list.useQuery();\n}\n\n// apps/mobile/hooks/use-subscriptions.ts  \nexport function useSubscriptions() {\n  return trpc.subscriptions.list.useQuery({});\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:06.720179-06:00","updated_at":"2025-12-17T18:10:53.652461-06:00","closed_at":"2025-12-17T18:10:53.652461-06:00","dependencies":[{"issue_id":"zine-lfp.20","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:06.720517-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.3","title":"PKCE generatePKCE function has incorrect base64URLEncode logic","description":"**Issue**: The PKCE `base64URLEncode` function (lines 163-166) has incorrect logic that will produce invalid challenges.\n\n**Current code**:\n```typescript\nfunction base64URLEncode(input: Uint8Array | string): string {\n  const base64 = typeof input === 'string' ? input : btoa(String.fromCharCode(...input));\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n```\n\n**Problems**:\n1. When `input` is already a base64 string (from `Crypto.digestStringAsync`), the function doesn't re-encode it - it just does URL-safe replacement. But the digest result needs different handling.\n2. `Crypto.digestStringAsync` with `BASE64` encoding returns standard base64, but the verifier encoding from `Uint8Array` uses a different path.\n3. The verifier should be base64url-encoded from raw bytes, but the challenge is SHA256(verifier) encoded to base64url.\n\n**Correct implementation**:\n```typescript\nfunction base64URLEncode(buffer: Uint8Array): string {\n  return btoa(String.fromCharCode(...buffer))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nasync function generatePKCE() {\n  const randomBytes = await Crypto.getRandomBytesAsync(32);\n  const verifier = base64URLEncode(randomBytes);\n  \n  const digestBuffer = await Crypto.digest(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    new TextEncoder().encode(verifier)\n  );\n  const challenge = base64URLEncode(new Uint8Array(digestBuffer));\n  \n  return { verifier, challenge };\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.510528-06:00","updated_at":"2025-12-17T06:16:59.140447-06:00","closed_at":"2025-12-17T06:16:59.140447-06:00","dependencies":[{"issue_id":"zine-lfp.3","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.510895-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.4","title":"Missing tRPC procedure definitions referenced in frontend","description":"**Issue**: The frontend spec references tRPC procedures that aren't fully aligned with the backend spec's API design.\n\n**Frontend references**:\n- `trpc.subscriptions.connections.registerState.mutate()` (line 74)\n- `trpc.subscriptions.connections.callback.mutate()` (line 128)\n- `trpc.subscriptions.add.mutate()` (line 1524)\n- `trpc.subscriptions.remove.mutate()` (line 1526)\n- `trpc.subscriptions.pause.mutate()` (line 1528)\n- `trpc.subscriptions.resume.mutate()` (line 1534)\n\n**Backend spec defines** (Section 5.1):\n- `subscriptions.connections.list` - Query\n- `subscriptions.connections.registerState` - Mutation\n- `subscriptions.connections.callback` - Mutation\n- `subscriptions.connections.disconnect` - Mutation\n- `subscriptions.add` - Mutation\n- `subscriptions.remove` - Mutation\n- `subscriptions.pause` - Mutation\n- `subscriptions.resume` - Mutation\n- `subscriptions.syncNow` - Mutation\n\n**Missing from backend spec**:\n- Input/output type definitions for each procedure\n- Full procedure signatures with Zod schemas\n\n**Fix Required**: Add a \"tRPC Contract\" section to frontend spec that explicitly lists all procedures with their input/output types, OR add these to backend spec and cross-reference.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.580958-06:00","updated_at":"2025-12-17T06:19:34.121507-06:00","closed_at":"2025-12-17T06:19:34.121507-06:00","dependencies":[{"issue_id":"zine-lfp.4","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.58132-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.5","title":"Inbox screen code example imports non-existent components","description":"**Issue**: The Inbox screen code example (Section 6.2, lines 553-625) imports/uses components that aren't defined anywhere:\n- `Surface` - used as root container, never imported or defined\n- `LoadingState` - referenced but not defined\n- `ErrorState` - referenced but not defined  \n- `EmptyState` - referenced but not defined\n- `useInboxItems` - different signature than the one in apps/mobile/hooks/use-items.ts\n\n**The actual codebase** (apps/mobile/hooks/use-items.ts) shows `useInboxItems()` returns `ItemWithUserState[]`, not `{ data, isLoading, error, refetch }`.\n\n**Fix Required**:\n1. Define or import `Surface`, `LoadingState`, `ErrorState`, `EmptyState` components\n2. Align the hook signature - either update the spec to match existing code, or document that this is a new API\n3. Add imports section to the code example","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:05.653456-06:00","updated_at":"2025-12-17T18:09:26.547648-06:00","closed_at":"2025-12-17T18:09:26.547648-06:00","dependencies":[{"issue_id":"zine-lfp.5","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.653815-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.6","title":"useSyncNow hook referenced but not defined in spec","description":"Added Section 6.4 useSyncNow Hook to frontend-spec.md with complete hook implementation, usage example, and return value documentation.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.724523-06:00","updated_at":"2025-12-17T06:21:36.647885-06:00","closed_at":"2025-12-17T06:21:36.647885-06:00","dependencies":[{"issue_id":"zine-lfp.6","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.724888-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.7","title":"OAuth callback handler lacks provider identification logic","description":"**Issue**: The OAuth callback handler (Section 7.6, lines 896-976) parses the callback URL but doesn't determine which provider the callback is for.\n\n**Current code** (line 943):\n```typescript\nconst result = await completeOAuthFlow(params.code, params.state);\n```\n\n**Problem**: The `completeOAuthFlow` function needs to know the provider to:\n1. Retrieve the correct PKCE verifier from SecureStore (`${provider}_code_verifier`)\n2. Retrieve the correct state from SecureStore (`${provider}_oauth_state`)\n3. Call the correct tRPC procedure\n\nBut the callback URL `zine://oauth/callback?code=xxx\u0026state=yyy` doesn't include the provider.\n\n**Solutions**:\n1. **Encode provider in state**: Make state = `${provider}:${uuid}` and parse it\n2. **Use provider-specific callback URLs**: `zine://oauth/youtube/callback` vs `zine://oauth/spotify/callback`\n3. **Lookup state in SecureStore**: Try both providers' stored states to find a match\n\n**Fix Required**: Implement provider identification. Recommended approach is option 1 (encode in state) as it's simplest and aligns with common OAuth patterns:\n```typescript\nconst state = `${provider}:${crypto.randomUUID()}`;\n// Later: const [provider, stateId] = returnedState.split(':');\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.796803-06:00","updated_at":"2025-12-17T06:33:44.212303-06:00","closed_at":"2025-12-17T06:33:44.212303-06:00","dependencies":[{"issue_id":"zine-lfp.7","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.797124-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.8","title":"Missing connection between offline queue and tRPC client","description":"**Issue**: The offline queue (Section 9.3) stores actions but the tRPC client isn't configured to use it. There's a disconnect between the queue and actual mutation execution.\n\n**Current architecture**:\n1. `useOfflineMutation` checks `isOnline` and queues if offline\n2. `offlineQueue.processQueue()` calls tRPC endpoints directly via dynamic import\n\n**Problems**:\n1. The queue imports tRPC client dynamically (line 1520): `const { trpc } = await import('./trpc')` - this creates a new client instance\n2. No integration with React Query's mutation cache\n3. Optimistic updates in `useOfflineMutation` won't sync with the actual tRPC query cache when queue processes\n\n**Missing integration points**:\n1. Configure `trpc.subscriptions.add` to automatically queue when offline instead of requiring a wrapper hook\n2. Sync queue processing results back to React Query cache\n3. Handle conflicts when queue processes (e.g., subscription was already added on another device)\n\n**Fix Required**: Document integration pattern between offline queue and tRPC client, potentially using tRPC's `links` feature for offline-first behavior:\n```typescript\n// trpc.ts\nconst offlineLink = () =\u003e {\n  return ({ op, next }) =\u003e {\n    if (!isOnline() \u0026\u0026 op.type === 'mutation') {\n      return offlineQueue.enqueue(op);\n    }\n    return next(op);\n  };\n};\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:03:05.869323-06:00","updated_at":"2025-12-17T18:20:34.999877-06:00","closed_at":"2025-12-17T18:20:34.999877-06:00","dependencies":[{"issue_id":"zine-lfp.8","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.869673-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-lfp.9","title":"useSubscriptions hook references non-existent tRPC endpoints","description":"Fixed useSubscriptions hook to properly handle paginated tRPC response. Updated Section 9.5 with proper pagination params, response shape handling, and added useInfiniteSubscriptions hook.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T22:03:05.938273-06:00","updated_at":"2025-12-17T06:35:45.087255-06:00","closed_at":"2025-12-17T06:35:45.087255-06:00","dependencies":[{"issue_id":"zine-lfp.9","depends_on_id":"zine-lfp","type":"parent-child","created_at":"2025-12-16T22:03:05.938617-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb","title":"Subscriptions Feature: Frontend Implementation","description":"# Subscriptions Feature: Frontend Implementation\n\n## Overview\nThis epic encompasses the complete React Native/Expo mobile app implementation for the Zine subscriptions feature. Users will be able to connect their YouTube and Spotify accounts via OAuth, selectively subscribe to channels/podcasts, and receive new content directly in their inbox.\n\n## Key Principles (from spec)\n1. **User-controlled subscriptions** - Users explicitly choose which channels/shows to follow (not auto-import)\n2. **Inbox-first flow** - New content lands in inbox for triage, not directly in library\n3. **Initial fetch limitation** - Only pull the latest episode/video when first subscribing\n4. **Offline-first with queue** - Actions work offline and sync when reconnected\n\n## Architecture Decisions\n- **Styling**: React Native StyleSheet with theme tokens from `@/constants/theme` (NOT NativeWind/Tailwind)\n- **State Management**: tRPC + React Query for server state, offline queue for mutations\n- **OAuth**: PKCE flow with client-side verifier/challenge generation (security requirement)\n- **Deep Linking**: Custom scheme `zine://` + Universal Links for OAuth callbacks\n\n## Dependencies\n- Backend tRPC endpoints must be implemented (see backend-spec.md)\n- Theme tokens in `@/constants/theme` must include new colors (primaryLight, warningText, etc.)\n\n## Files to be Created/Modified\n### New Files\n- `apps/mobile/lib/oauth.ts` - OAuth configuration and PKCE flow\n- `apps/mobile/lib/oauth-errors.ts` - Error types and parsing\n- `apps/mobile/lib/offline-queue.ts` - Offline action queue\n- `apps/mobile/lib/trpc-offline-client.ts` - Singleton tRPC client for queue\n- `apps/mobile/hooks/use-connections.ts` - Provider connections hook\n- `apps/mobile/hooks/use-subscriptions.ts` - Full subscriptions hook with offline support\n- `apps/mobile/hooks/use-subscriptions-query.ts` - Simple query-only hook\n- `apps/mobile/hooks/use-network-status.ts` - Network detection hook\n- `apps/mobile/hooks/use-offline-mutation.ts` - Offline mutation wrapper\n- `apps/mobile/hooks/use-sync-now.ts` - Manual sync hook\n- `apps/mobile/hooks/use-sync-recovery.ts` - Sync recovery on app resume\n- `apps/mobile/types/inbox.ts` - InboxItem type with source attribution\n- `apps/mobile/app/settings/_layout.tsx` - Settings stack navigator\n- `apps/mobile/app/settings/index.tsx` - Settings main screen\n- `apps/mobile/app/settings/connections.tsx` - Manage connected providers\n- `apps/mobile/app/subscriptions/index.tsx` - Subscription management\n- `apps/mobile/app/subscriptions/connect/*.tsx` - OAuth flow screens\n- `apps/mobile/app/subscriptions/discover/*.tsx` - Channel discovery\n- `apps/mobile/components/error-boundary.tsx` - Base error boundary\n- `apps/mobile/components/subscription-error-boundary.tsx` - Subscription-specific\n- `apps/mobile/components/oauth-error-boundary.tsx` - OAuth-specific\n- `apps/mobile/components/query-error-boundary.tsx` - React Query integration\n- `apps/mobile/components/offline-banner.tsx` - Offline status banner\n- `apps/mobile/components/sync-status-indicator.tsx` - Pending changes indicator\n- `apps/mobile/components/sync-now-button.tsx` - Manual sync button\n- `apps/mobile/providers/oauth-callback-handler.tsx` - Deep link handler\n\n### Modified Files\n- `apps/mobile/app.json` - Deep linking configuration\n- `apps/mobile/app/(tabs)/index.tsx` - Add settings gear icon\n- `apps/mobile/app/(tabs)/inbox.tsx` - Add source attribution, pull-to-refresh\n- `apps/mobile/app/_layout.tsx` - Add OAuth callback handler provider\n- `apps/mobile/providers/trpc-provider.tsx` - Register queue callback\n\n## Testing Strategy\n- Unit tests for PKCE generation and OAuth error parsing\n- Integration tests for offline queue behavior\n- E2E tests for OAuth flow (requires test accounts)\n- Manual testing for deep links (iOS Simulator + Android Emulator commands in spec)\n\n## Reference Documentation\n- Frontend Spec: `features/subscriptions/frontend-spec.md`\n- Backend Spec: `features/subscriptions/backend-spec.md`\n- Overview Spec: `features/subscriptions/spec.md`","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T21:18:27.681776-06:00","updated_at":"2025-12-17T23:03:53.876885-06:00","closed_at":"2025-12-17T23:03:53.876885-06:00"}
{"id":"zine-nnb.1","title":"1.1 Create OAuth configuration and PKCE generation utilities","description":"# 1.1 Create OAuth configuration and PKCE generation utilities\n\n## File\n`apps/mobile/lib/oauth.ts`\n\n## Background \u0026 Rationale\nPKCE (Proof Key for Code Exchange) is a security extension to OAuth 2.0 specifically designed for public clients like mobile apps that cannot securely store client secrets. The **critical security requirement** is that PKCE values MUST be generated on the client side - if the server generated these, it would defeat the entire purpose of PKCE.\n\n## What This Task Creates\n\n### 1. OAuth Configuration Constants\n```typescript\nconst OAUTH_CONFIG = {\n  YOUTUBE: {\n    clientId: process.env.EXPO_PUBLIC_YOUTUBE_CLIENT_ID!,\n    authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n    scopes: ['https://www.googleapis.com/auth/youtube.readonly'],\n  },\n  SPOTIFY: {\n    clientId: process.env.EXPO_PUBLIC_SPOTIFY_CLIENT_ID!,\n    authUrl: 'https://accounts.spotify.com/authorize',\n    scopes: ['user-library-read'],\n  },\n} as const;\n\nconst REDIRECT_URI = 'zine://oauth/callback';\n```\n\n### 2. PKCE Generation Functions\n- `base64URLEncode(buffer: Uint8Array): string` - Convert bytes to base64url (URL-safe base64)\n- `generatePKCE(): Promise\u003c{ verifier: string; challenge: string }\u003e` - Generate cryptographically secure verifier and SHA-256 challenge\n\n### 3. Helper Functions\n- `getRedirectUri(): string` - Returns appropriate redirect URI for dev vs prod\n\n## Security Considerations (CRITICAL)\n- Verifier MUST be 43-128 characters (we generate 43 from 32 random bytes)\n- Challenge is SHA-256 hash of verifier, base64url encoded\n- Uses expo-crypto for cryptographically secure random bytes\n- Verifier is stored in SecureStore (encrypted on device), never sent to server until exchange\n\n## Dependencies\n- `expo-crypto` - For secure random bytes and SHA-256 hashing\n- `expo-secure-store` - For encrypted storage of verifier\n\n## Acceptance Criteria\n- [ ] PKCE verifier is exactly 43 characters (base64url encoded 32 bytes)\n- [ ] Challenge is valid SHA-256 hash of verifier\n- [ ] base64url encoding is correct (+ → -, / → _, no padding)\n- [ ] Configuration uses environment variables\n- [ ] Unit tests pass for PKCE generation\n\n## Reference\n- Frontend Spec Section 1.3: PKCE Generation\n- RFC 7636: Proof Key for Code Exchange","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:27.74566-06:00","updated_at":"2025-12-17T21:36:28.265078-06:00","closed_at":"2025-12-17T21:36:28.265078-06:00","dependencies":[{"issue_id":"zine-nnb.1","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:27.746003-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.10","title":"3.2 Create useSubscriptions query-only hook","description":"# 3.2 Create useSubscriptions query-only hook\n\n## File\n`apps/mobile/hooks/use-subscriptions-query.ts`\n\n## Background \u0026 Rationale\nThis is a **simple, query-only** version of the subscriptions hook used for read-only scenarios like the Settings screen's subscription count. The full `useSubscriptions` hook (Task 5.4) includes offline mutation support and is more complex.\n\n## Why Two Hooks?\n| Hook | Use Case | Complexity |\n|------|----------|------------|\n| `use-subscriptions-query.ts` | Read-only (Settings count) | Simple |\n| `use-subscriptions.ts` | Full CRUD with offline | Complex |\n\nHaving a simple hook avoids pulling in offline queue dependencies where they're not needed.\n\n## What This Task Creates\n\n### Types\n```typescript\nexport interface Subscription {\n  id: string;\n  provider: 'YOUTUBE' | 'SPOTIFY';\n  providerChannelId: string;\n  name: string;\n  imageUrl: string | null;\n  status: 'ACTIVE' | 'PAUSED';\n  createdAt: string;\n  lastItemAt: string | null;\n}\n\nexport interface SubscriptionsResponse {\n  items: Subscription[];\n  nextCursor?: string;\n}\n```\n\n### Hook\n```typescript\nexport function useSubscriptions() {\n  return trpc.subscriptions.list.useQuery({}, {\n    staleTime: 5 * 60 * 1000,\n    gcTime: 24 * 60 * 60 * 1000,\n  });\n}\n```\n\n## Usage\n```typescript\n// Settings screen - just need count\nconst { data: subscriptions } = useSubscriptions();\nconst count = subscriptions?.items?.length ?? 0;\n```\n\n## Cache Strategy\nSame as connections - subscriptions change infrequently and can be cached for minutes.\n\n## Dependencies\n- tRPC client\n- Backend `subscriptions.list` endpoint\n\n## Acceptance Criteria\n- [ ] Returns paginated response with items array\n- [ ] Types match backend contract\n- [ ] Appropriate cache settings\n- [ ] No offline queue dependencies\n\n## Reference\n- Frontend Spec Section 3.1.2: useSubscriptions Hook (Query-only)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.325588-06:00","updated_at":"2025-12-17T22:33:00.210583-06:00","closed_at":"2025-12-17T22:33:00.210583-06:00","dependencies":[{"issue_id":"zine-nnb.10","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.325933-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.11","title":"3.3 Create useNetworkStatus hook for connectivity detection","description":"Implemented useNetworkStatus hook with reactive and imperative network status checking. Added @react-native-community/netinfo dependency.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.385131-06:00","updated_at":"2025-12-17T21:36:29.60864-06:00","closed_at":"2025-12-17T21:36:29.60864-06:00","dependencies":[{"issue_id":"zine-nnb.11","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.385446-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.12","title":"3.4 Create useSyncNow hook for manual sync","description":"# 3.4 Create useSyncNow hook for manual sync\n\n## File\n`apps/mobile/hooks/use-sync-now.ts`\n\n## Background \u0026 Rationale\nUsers sometimes want to force-check a subscription for new content rather than waiting for the next poll. This hook provides manual sync functionality with rate limiting awareness and user feedback.\n\n## What This Task Creates\n\n### SyncResult Type\n```typescript\ninterface SyncResult {\n  success: boolean;\n  itemsFound?: number;\n  message: string;\n}\n```\n\n### Hook Interface\n```typescript\nexport function useSyncNow(subscriptionId: string) {\n  return {\n    syncNow: () =\u003e void,\n    isLoading: boolean,\n    cooldownSeconds: number,\n    lastResult: SyncResult | null,\n  };\n}\n```\n\n### Features\n1. **Rate Limiting** - Backend enforces 5-minute cooldown per subscription\n2. **Countdown Timer** - Shows remaining cooldown time\n3. **Result Feedback** - \"Found 3 new items\" or \"No new content\"\n4. **TOO_MANY_REQUESTS Handling** - Parses retry-after from error\n\n### Implementation Flow\n```typescript\nconst mutation = trpc.subscriptions.syncNow.useMutation({\n  onSuccess: (data) =\u003e {\n    setLastResult({\n      success: true,\n      itemsFound: data.itemsFound,\n      message: data.itemsFound \u003e 0 \n        ? `Found ${data.itemsFound} new items`\n        : 'No new content',\n    });\n    setCooldownSeconds(300); // 5 minutes\n  },\n  onError: (error) =\u003e {\n    if (error.data?.code === 'TOO_MANY_REQUESTS') {\n      // Parse cooldown from error\n      setCooldownSeconds(parseCooldown(error.message));\n    }\n    setLastResult({ success: false, message: error.message });\n  },\n});\n```\n\n### Countdown Effect\n```typescript\nuseEffect(() =\u003e {\n  if (cooldownSeconds \u003c= 0) return;\n  const timer = setInterval(() =\u003e {\n    setCooldownSeconds(prev =\u003e Math.max(0, prev - 1));\n  }, 1000);\n  return () =\u003e clearInterval(timer);\n}, [cooldownSeconds]);\n```\n\n## Dependencies\n- tRPC client\n- Backend `subscriptions.syncNow` endpoint\n\n## Acceptance Criteria\n- [ ] Calls syncNow mutation correctly\n- [ ] Handles success with item count\n- [ ] Handles rate limit errors gracefully\n- [ ] Countdown timer works\n- [ ] Disabled state when cooling down\n- [ ] Result message for UI feedback\n\n## Reference\n- Frontend Spec Section 6.5: useSyncNow Hook","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:28.445335-06:00","updated_at":"2025-12-17T22:50:51.580807-06:00","closed_at":"2025-12-17T22:50:51.580807-06:00","dependencies":[{"issue_id":"zine-nnb.12","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.445641-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.13","title":"4.1 Configure app.json deep linking (scheme, intent filters)","description":"Configured app.json for OAuth deep linking: iOS bundleIdentifier + associatedDomains, Android package + intentFilters (Universal Links + custom scheme), added expo-web-browser plugin.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.503497-06:00","updated_at":"2025-12-17T22:33:01.393789-06:00","closed_at":"2025-12-17T22:33:01.393789-06:00","dependencies":[{"issue_id":"zine-nnb.13","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.503843-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.14","title":"4.2 Create OAuthCallbackHandler provider component","description":"# 4.2 Create OAuthCallbackHandler provider component\n\n## File\n`apps/mobile/providers/oauth-callback-handler.tsx`\n\n## Background \u0026 Rationale\nThe OAuth callback handler intercepts deep links to `zine://oauth/callback` and completes the OAuth flow. It must handle both \"warm\" scenarios (app in background) and \"cold start\" scenarios (app was killed).\n\n## What This Task Creates\n\n### Provider Component\n```typescript\nexport function OAuthCallbackHandler({\n  onSuccess,\n  onError,\n  children,\n}: OAuthCallbackHandlerProps) {\n  // Handle deep links\n  // Process OAuth callbacks\n  // Navigate after completion\n}\n```\n\n### Core Logic\n\n#### 1. URL Parsing\n```typescript\nconst parseOAuthCallback = (url: string): {\n  code: string;\n  state: string;\n  provider: 'YOUTUBE' | 'SPOTIFY';\n} | null =\u003e {\n  // Extract code and state from URL\n  // Parse provider from state (format: \"PROVIDER:uuid\")\n  // Validate provider is known\n}\n```\n\n#### 2. Cold Start Handling\n```typescript\nuseEffect(() =\u003e {\n  // Check initial URL (app launched via deep link)\n  const checkInitialUrl = async () =\u003e {\n    const initialUrl = await Linking.getInitialURL();\n    if (initialUrl) await processCallback(initialUrl);\n  };\n  checkInitialUrl();\n\n  // Subscribe to URL events (app in background)\n  const subscription = Linking.addEventListener('url', (event) =\u003e {\n    processCallback(event.url);\n  });\n\n  return () =\u003e subscription.remove();\n}, []);\n```\n\n#### 3. Callback Processing\n```typescript\nconst processCallback = async (url: string) =\u003e {\n  // Prevent duplicate processing\n  if (processedUrls.current.has(url)) return;\n  processedUrls.current.add(url);\n\n  const params = parseOAuthCallback(url);\n  if (!params) return;\n\n  const result = await completeOAuthFlow(params.code, params.state, params.provider);\n  \n  if (result.success) {\n    onSuccess?.(params.provider);\n    router.replace('/subscriptions');\n  } else {\n    onError?.(result.error);\n    router.replace({ pathname: '/subscriptions/connect/error', params: { error: result.error } });\n  }\n};\n```\n\n### State Format Explanation\nThe state parameter format `PROVIDER:uuid` serves two purposes:\n1. **CSRF protection** - UUID validated by server\n2. **Provider identification** - Callback handler knows which SecureStore keys to use\n\n## Dependencies\n- Task 1.4 (completeOAuthFlow function)\n- `expo-linking` for deep link handling\n- `expo-router` for navigation\n\n## Acceptance Criteria\n- [ ] Handles cold start (getInitialURL)\n- [ ] Handles warm start (addEventListener)\n- [ ] Parses provider from state correctly\n- [ ] Prevents duplicate processing\n- [ ] Navigates on success/error\n- [ ] Calls appropriate callbacks\n\n## Reference\n- Frontend Spec Section 7.6: Cold Start Handler","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.565837-06:00","updated_at":"2025-12-17T22:36:57.317245-06:00","closed_at":"2025-12-17T22:36:57.317245-06:00","dependencies":[{"issue_id":"zine-nnb.14","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.566166-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.15","title":"4.3 Integrate OAuthCallbackHandler into app root layout","description":"Integrated OAuthCallbackHandler into app root layout. Added import and wrapped navigation tree following provider order: AuthProvider \u003e TRPCProvider \u003e OAuthCallbackHandler \u003e ThemeProvider \u003e Stack.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.627497-06:00","updated_at":"2025-12-17T22:43:27.739082-06:00","closed_at":"2025-12-17T22:43:27.739082-06:00","dependencies":[{"issue_id":"zine-nnb.15","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.627814-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.16","title":"5.1 Create offline action queue with AsyncStorage persistence","description":"# 5.1 Create offline action queue with AsyncStorage persistence\n\n## File\n`apps/mobile/lib/offline-queue.ts`\n\n## Background \u0026 Rationale\nThe offline queue is central to the offline-first architecture. When users perform actions while offline, they're queued and persisted to AsyncStorage, then executed when connectivity returns. This provides a seamless UX where actions \"just work\" regardless of connectivity.\n\n## What This Task Creates\n\n### Action Types\n```typescript\nexport type OfflineActionType =\n  | 'SUBSCRIBE'\n  | 'UNSUBSCRIBE'\n  | 'PAUSE_SUBSCRIPTION'\n  | 'RESUME_SUBSCRIPTION';\n```\n\n### Action Interface\n```typescript\nexport interface OfflineAction {\n  id: string;              // ULID for ordering\n  type: OfflineActionType;\n  payload: Record\u003cstring, unknown\u003e;\n  createdAt: number;\n  retryCount: number;\n  authRetryCount: number;\n  lastError?: string;\n  lastErrorType?: ErrorClassification;\n}\n```\n\n### Error Classification\n```typescript\nexport type ErrorClassification =\n  | 'NETWORK'   // Retry with backoff\n  | 'AUTH'      // Refresh token and retry once\n  | 'CONFLICT'  // Already succeeded (409)\n  | 'CLIENT'    // Permanent failure (4xx)\n  | 'SERVER'    // Retry with backoff (5xx)\n  | 'UNKNOWN';\n```\n\n### Queue Class\n```typescript\nclass OfflineActionQueue {\n  async enqueue(action): Promise\u003cstring\u003e\n  async getQueue(): Promise\u003cOfflineAction[]\u003e\n  async getPendingCount(): Promise\u003cnumber\u003e\n  async processQueue(): Promise\u003cvoid\u003e\n  subscribe(listener: () =\u003e void): () =\u003e void\n}\n```\n\n### Key Features\n\n#### 1. Persistence\n- Stored in AsyncStorage under `zine:offline_action_queue`\n- Survives app restarts\n- ULID IDs ensure ordering\n\n#### 2. Smart Retry Logic\n```typescript\nfunction isRetryableError(errorType, action): boolean {\n  switch (errorType) {\n    case 'NETWORK':\n    case 'SERVER':\n      return action.retryCount \u003c MAX_RETRIES;\n    case 'AUTH':\n      return action.authRetryCount \u003c 1;\n    case 'CONFLICT':\n      return false; // Already succeeded!\n    case 'CLIENT':\n      return false; // Permanent failure\n  }\n}\n```\n\n#### 3. Auth Token Refresh\nWhen 401 is encountered, attempts to refresh auth token before retrying.\n\n#### 4. Conflict Handling\n409 Conflict means the action already succeeded (e.g., already subscribed). This is treated as success, not error.\n\n## NetInfo Integration\n```typescript\nNetInfo.addEventListener((state) =\u003e {\n  if (state.isConnected \u0026\u0026 state.isInternetReachable !== false) {\n    offlineQueue.processQueue();\n  }\n});\n```\n\n## Dependencies\n- `@react-native-async-storage/async-storage`\n- `@react-native-community/netinfo`\n- `ulid` package for IDs\n\n## Acceptance Criteria\n- [ ] Queue persists across app restarts\n- [ ] Actions processed in order (ULID)\n- [ ] Network errors trigger retry with backoff\n- [ ] Auth errors trigger token refresh\n- [ ] Conflict (409) treated as success\n- [ ] Client errors (4xx) removed without retry\n- [ ] Listeners notified on queue changes\n- [ ] Processes automatically when online\n\n## Reference\n- Frontend Spec Section 9.3: Offline Action Queue","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.685855-06:00","updated_at":"2025-12-17T22:40:26.840403-06:00","closed_at":"2025-12-17T22:40:26.840403-06:00","dependencies":[{"issue_id":"zine-nnb.16","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.68617-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.17","title":"5.2 Create singleton tRPC client for offline queue","description":"# 5.2 Create singleton tRPC client for offline queue\n\n## File\n`apps/mobile/lib/trpc-offline-client.ts`\n\n## Background \u0026 Rationale\nThe offline queue needs to execute tRPC mutations when processing queued actions, but it runs outside of React's component tree. A naive approach of dynamically importing the tRPC client would create disconnected instances. This singleton provides a consistent client that can notify React Query when mutations complete.\n\n## The Problem\n\n```typescript\n// BAD: Creates new client each time, disconnected from React Query\nconst { trpc } = await import('./trpc');\nawait trpc.subscriptions.add.mutate(payload);\n// React Query cache NOT updated!\n```\n\n## The Solution\n\n### 1. Singleton Client\n```typescript\nlet offlineClient: ReturnType\u003ctypeof createOfflineTRPCClient\u003e | null = null;\n\nexport function getOfflineTRPCClient() {\n  if (!offlineClient) {\n    offlineClient = createTRPCClient\u003cAppRouter\u003e({\n      links: [\n        httpBatchLink({\n          url: process.env.EXPO_PUBLIC_API_URL + '/trpc',\n          headers: async () =\u003e {\n            const { getAuthHeaders } = await import('./auth');\n            return getAuthHeaders();\n          },\n        }),\n      ],\n    });\n  }\n  return offlineClient;\n}\n```\n\n### 2. Callback Registration\n```typescript\nlet queueProcessedCallback: (() =\u003e void) | null = null;\n\nexport function setQueueProcessedCallback(callback: () =\u003e void): void {\n  queueProcessedCallback = callback;\n}\n\nexport function notifyQueueProcessed(): void {\n  queueProcessedCallback?.();\n}\n```\n\n### 3. TRPCProvider Integration\n```typescript\n// In trpc-provider.tsx\nuseEffect(() =\u003e {\n  setQueueProcessedCallback(() =\u003e {\n    utils.subscriptions.list.invalidate();\n    utils.subscriptions.connections.list.invalidate();\n    utils.items.inbox.invalidate();\n  });\n}, [utils]);\n```\n\n## Why Not Use the React Hooks Client?\n- The queue runs outside React component lifecycle\n- Can't use hooks in non-component code\n- Need imperative API (`mutate()`) not hook pattern\n\n## Why Invalidate, Not Update Cache?\nAfter queue processing, we invalidate rather than manually update because:\n- Server may have applied business logic\n- Timestamps and IDs assigned by server\n- Simpler and more reliable\n\n## Dependencies\n- `@trpc/client`\n- Auth utilities for headers\n\n## Acceptance Criteria\n- [ ] Singleton returns same instance\n- [ ] Auth headers included in requests\n- [ ] Callback registration works\n- [ ] notifyQueueProcessed triggers callback\n- [ ] Works outside React component tree\n\n## Reference\n- Frontend Spec Section 9.3.0: tRPC Client Integration","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.744895-06:00","updated_at":"2025-12-17T22:40:27.380328-06:00","closed_at":"2025-12-17T22:40:27.380328-06:00","dependencies":[{"issue_id":"zine-nnb.17","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.745191-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.18","title":"5.3 Create useOfflineMutation hook wrapper","description":"# 5.3 Create useOfflineMutation hook wrapper\n\n## File\n`apps/mobile/hooks/use-offline-mutation.ts`\n\n## Background \u0026 Rationale\nThis hook wraps any mutation to make it offline-capable. It handles the complexity of checking network status, enqueueing when offline, and providing optimistic updates - so individual hooks don't need to duplicate this logic.\n\n## What This Task Creates\n\n### Hook Interface\n```typescript\ninterface UseOfflineMutationOptions\u003cTPayload\u003e {\n  actionType: OfflineActionType;\n  mutationFn: (payload: TPayload) =\u003e Promise\u003cvoid\u003e;\n  onOptimisticUpdate?: (payload: TPayload) =\u003e void;\n  onRollback?: (payload: TPayload) =\u003e void;\n  onSuccess?: (payload: TPayload) =\u003e void;\n  onError?: (error: Error, payload: TPayload) =\u003e void;\n}\n\nexport function useOfflineMutation\u003cTPayload\u003e({...}): {\n  mutate: (payload: TPayload) =\u003e Promise\u003cvoid\u003e;\n  isPending: boolean;\n  isQueued: boolean;\n  isOnline: boolean;\n}\n```\n\n### Implementation Logic\n\n```typescript\nconst mutate = useCallback(async (payload: TPayload) =\u003e {\n  setIsPending(true);\n  onOptimisticUpdate?.(payload);\n\n  if (!isOnline) {\n    // OFFLINE: Queue the action\n    await offlineQueue.enqueue({ type: actionType, payload });\n    setIsQueued(true);\n    setIsPending(false);\n    return;\n  }\n\n  // ONLINE: Execute immediately\n  try {\n    await mutationFn(payload);\n    onSuccess?.(payload);\n  } catch (error) {\n    onRollback?.(payload);\n    onError?.(error as Error, payload);\n  } finally {\n    setIsPending(false);\n  }\n}, [isOnline, ...]);\n```\n\n### Key Features\n\n1. **Optimistic Updates** - UI updates immediately, rollback on failure\n2. **Automatic Queueing** - When offline, action is queued\n3. **Status Flags** - `isPending`, `isQueued`, `isOnline` for UI states\n4. **Consistent Interface** - Same API whether online or offline\n\n## Usage Example\n```typescript\nconst { mutate: subscribe } = useOfflineMutation\u003cSubscribePayload\u003e({\n  actionType: 'SUBSCRIBE',\n  mutationFn: (payload) =\u003e trpc.subscriptions.add.mutate(payload),\n  onOptimisticUpdate: (payload) =\u003e {\n    // Add to local cache immediately\n    queryClient.setQueryData(['subscriptions'], (old) =\u003e [...old, payload]);\n  },\n  onRollback: (payload) =\u003e {\n    // Remove from cache on failure\n    queryClient.setQueryData(['subscriptions'], (old) =\u003e \n      old.filter(s =\u003e s.id !== payload.id)\n    );\n  },\n});\n```\n\n## Dependencies\n- Task 5.1 (offline queue)\n- Task 3.3 (useNetworkStatus)\n\n## Acceptance Criteria\n- [ ] Online mutations execute immediately\n- [ ] Offline mutations queued correctly\n- [ ] Optimistic updates applied\n- [ ] Rollback on error\n- [ ] Status flags update correctly\n- [ ] Generic payload type works\n\n## Reference\n- Frontend Spec Section 9.4: Offline Mutation Hook","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.807661-06:00","updated_at":"2025-12-17T22:43:26.063875-06:00","closed_at":"2025-12-17T22:43:26.063875-06:00","dependencies":[{"issue_id":"zine-nnb.18","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.807956-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.19","title":"5.4 Create full useSubscriptions hook with offline mutation support","description":"Completed: Created full useSubscriptions hook with offline mutation support","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.867847-06:00","updated_at":"2025-12-17T22:43:27.07916-06:00","closed_at":"2025-12-17T22:43:27.07916-06:00","dependencies":[{"issue_id":"zine-nnb.19","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.868176-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.2","title":"1.2 Create OAuth error types and parsing utilities","description":"# 1.2 Create OAuth error types and parsing utilities\n\n## File\n`apps/mobile/lib/oauth-errors.ts`\n\n## Background \u0026 Rationale\nOAuth flows can fail in many ways - user cancellation, network errors, token exchange failures, provider errors, etc. Having structured error types allows the UI to:\n1. Show appropriate user-facing messages\n2. Determine if an error is recoverable (retry vs. re-auth)\n3. Log detailed information for debugging\n\n## What This Task Creates\n\n### 1. Error Code Enum\n```typescript\nexport enum OAuthErrorCode {\n  USER_CANCELLED = 'user_cancelled',\n  USER_DENIED = 'access_denied',\n  STATE_EXPIRED = 'state_expired',\n  STATE_MISMATCH = 'state_mismatch',\n  VERIFIER_NOT_FOUND = 'verifier_not_found',\n  NETWORK_ERROR = 'network_error',\n  TOKEN_EXCHANGE_FAILED = 'token_exchange_failed',\n  PROVIDER_ERROR = 'provider_error',\n  INVALID_GRANT = 'invalid_grant',\n  // ... etc\n}\n```\n\n### 2. OAuthError Interface\n```typescript\nexport interface OAuthError {\n  code: OAuthErrorCode;\n  message: string;\n  recoverable: boolean;\n  action?: 'retry' | 'reauthorize' | 'contact_support';\n}\n```\n\n### 3. Error Parser\n`parseOAuthError(error: unknown): OAuthError` - Converts raw errors from various sources (provider, network, WebBrowser) into structured OAuthError objects.\n\n## Error Categories\n\n| Category | Examples | Recoverable? | Action |\n|----------|----------|--------------|--------|\n| User Actions | cancelled, denied | Yes | retry |\n| Security | state mismatch, verifier missing | Yes | retry |\n| Network | timeout, fetch failed | Yes | retry |\n| Auth | invalid_grant, token expired | Yes | reauthorize |\n| Provider | server error, quota exceeded | Maybe | contact_support |\n\n## Why This Matters\nWithout proper error handling, users see generic \"Something went wrong\" messages. With structured errors, we can show \"Authorization was cancelled. Tap to try again.\" - much better UX.\n\n## Dependencies\n- None (pure TypeScript utilities)\n\n## Acceptance Criteria\n- [ ] All error codes from spec are covered\n- [ ] parseOAuthError handles all known error shapes\n- [ ] Each error has appropriate recoverable flag\n- [ ] Unit tests cover all error parsing paths\n\n## Reference\n- Frontend Spec Section 7.7: OAuth Error Handling","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:27.80756-06:00","updated_at":"2025-12-25T22:52:41.870053-06:00","closed_at":"2025-12-25T22:52:41.870053-06:00","dependencies":[{"issue_id":"zine-nnb.2","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:27.807871-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.20","title":"5.5 Register queue processed callback in TRPCProvider","description":"Completed: Registered queue processed callback in TRPCProvider","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:28.926989-06:00","updated_at":"2025-12-17T22:53:56.440773-06:00","closed_at":"2025-12-17T22:53:56.440773-06:00","dependencies":[{"issue_id":"zine-nnb.20","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.927339-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.21","title":"5.6 Create useSyncRecovery hook for app resume sync","description":"# 5.6 Create useSyncRecovery hook for app resume sync\n\n## File\n`apps/mobile/hooks/use-sync-recovery.ts`\n\n## Background \u0026 Rationale\nWhen the app comes back to foreground after being backgrounded, we should check for pending offline actions and process them. This ensures that actions queued while offline don't sit indefinitely waiting for a network change event.\n\n## What This Task Creates\n\n### Hook Implementation\n```typescript\nimport { useEffect, useRef } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport NetInfo from '@react-native-community/netinfo';\nimport { offlineQueue } from '@/lib/offline-queue';\n\nexport function useSyncRecovery() {\n  const appState = useRef(AppState.currentState);\n  const lastSyncAttempt = useRef\u003cnumber\u003e(0);\n  const MIN_SYNC_INTERVAL = 30_000; // 30 seconds\n\n  useEffect(() =\u003e {\n    const handleAppStateChange = async (nextAppState: AppStateStatus) =\u003e {\n      // Only trigger on foreground transition\n      if (\n        appState.current.match(/inactive|background/) \u0026\u0026\n        nextAppState === 'active'\n      ) {\n        console.log('[SyncRecovery] App came to foreground');\n        \n        // Debounce: Don't sync if we just synced\n        const now = Date.now();\n        if (now - lastSyncAttempt.current \u003c MIN_SYNC_INTERVAL) {\n          console.log('[SyncRecovery] Skipping, synced recently');\n          return;\n        }\n\n        // Check network status\n        const netState = await NetInfo.fetch();\n        if (!netState.isConnected || netState.isInternetReachable === false) {\n          console.log('[SyncRecovery] No network, skipping');\n          return;\n        }\n\n        // Check if queue has items\n        const pendingCount = await offlineQueue.getPendingCount();\n        if (pendingCount === 0) {\n          console.log('[SyncRecovery] Queue empty, skipping');\n          return;\n        }\n\n        // Process queue\n        console.log(`[SyncRecovery] Processing ${pendingCount} queued actions`);\n        lastSyncAttempt.current = now;\n        await offlineQueue.processQueue();\n      }\n\n      appState.current = nextAppState;\n    };\n\n    const subscription = AppState.addEventListener('change', handleAppStateChange);\n    return () =\u003e subscription.remove();\n  }, []);\n}\n```\n\n### Usage\n```typescript\n// In root layout or app entry point\nexport default function RootLayout() {\n  useSyncRecovery(); // Just call it, no return value needed\n\n  return (\n    \u003cProviders\u003e\n      \u003cStack /\u003e\n    \u003c/Providers\u003e\n  );\n}\n```\n\n### Scenarios Handled\n\n| Scenario | Behavior |\n|----------|----------|\n| App foregrounded, has network, has queue | Process queue |\n| App foregrounded, no network | Skip (NetInfo handles reconnect) |\n| App foregrounded, empty queue | Skip |\n| App foregrounded twice quickly | Skip (debounce) |\n| App stayed in foreground | No action (only triggers on transition) |\n\n### Why 30 Second Debounce?\n- Prevents rapid sync attempts if user quickly backgrounds/foregrounds\n- Queue processing can take time; don't want to interrupt\n- Network events handle most reconnection cases anyway\n\n### Logging\nConsole logs help with debugging:\n```\n[SyncRecovery] App came to foreground\n[SyncRecovery] Processing 3 queued actions\n```\n\nIn production, these could be sent to a logging service for monitoring queue health.\n\n## Dependencies\n- Task 5.1 (offline queue)\n- `@react-native-community/netinfo`\n- React Native AppState API\n\n## Acceptance Criteria\n- [ ] Triggers on foreground transition only\n- [ ] Checks network before processing\n- [ ] Checks queue has items\n- [ ] Debounces rapid transitions\n- [ ] Logs for debugging\n- [ ] Cleanup removes listener\n\n## Reference\n- Frontend Spec Section 9.7: App Resume Recovery","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:28.985116-06:00","updated_at":"2025-12-17T22:53:57.566121-06:00","closed_at":"2025-12-17T22:53:57.566121-06:00","dependencies":[{"issue_id":"zine-nnb.21","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.985431-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.22","title":"6.1 Create OfflineBanner component","description":"# 6.1 Create OfflineBanner component\n\n## File\n`apps/mobile/components/offline-banner.tsx`\n\n## Background \u0026 Rationale\nWhen users go offline, they should be informed but not alarmed. The offline banner slides in from the top with a friendly message explaining that changes will sync when reconnected.\n\n## What This Task Creates\n\n### Component\n```typescript\nexport function OfflineBanner() {\n  const { isConnected, isInternetReachable } = useNetworkStatus();\n  const slideAnim = useRef(new Animated.Value(-50)).current;\n\n  const isOffline = !isConnected || isInternetReachable === false;\n\n  useEffect(() =\u003e {\n    Animated.timing(slideAnim, {\n      toValue: isOffline ? 0 : -50,\n      duration: 300,\n      useNativeDriver: true,\n    }).start();\n  }, [isOffline]);\n\n  if (!isOffline) return null;\n\n  return (\n    \u003cAnimated.View style={[styles.container, { transform: [{ translateY: slideAnim }] }]}\u003e\n      \u003cText style={styles.text}\u003e\n        You're offline. Changes will sync when you reconnect.\n      \u003c/Text\u003e\n    \u003c/Animated.View\u003e\n  );\n}\n```\n\n### Styling\n```typescript\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    backgroundColor: Colors.light.warning,  // Yellow\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    zIndex: 50,\n  },\n  text: {\n    textAlign: 'center',\n    color: Colors.light.warningText,  // Dark text on yellow\n    fontWeight: '500',\n  },\n});\n```\n\n### Animation\n- Slides down from top when offline\n- Slides up and hides when online\n- Uses native driver for smooth animation\n\n### Placement\nTypically placed at the root layout level so it appears above all screens:\n```typescript\n// app/_layout.tsx\n\u003cView style={{ flex: 1 }}\u003e\n  \u003cOfflineBanner /\u003e\n  \u003cSlot /\u003e\n\u003c/View\u003e\n```\n\n## Theme Requirement\nRequires new theme colors:\n- `warning` - Yellow background\n- `warningText` - Dark text for contrast\n\n## Dependencies\n- Task 3.3 (useNetworkStatus)\n- Theme tokens (may need to add warning colors)\n\n## Acceptance Criteria\n- [ ] Shows when offline\n- [ ] Hides when online\n- [ ] Smooth slide animation\n- [ ] Non-blocking (absolute positioned)\n- [ ] Readable text contrast\n- [ ] Works in light and dark mode\n\n## Reference\n- Frontend Spec Section 9.2: Offline Banner","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.046236-06:00","updated_at":"2025-12-17T22:53:58.485892-06:00","closed_at":"2025-12-17T22:53:58.485892-06:00","dependencies":[{"issue_id":"zine-nnb.22","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.046577-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.23","title":"6.2 Create SyncStatusIndicator component","description":"# 6.2 Create SyncStatusIndicator component\n\n## File\n`apps/mobile/components/sync-status-indicator.tsx`\n\n## Background \u0026 Rationale\nWhen there are pending offline actions, users should see a subtle indicator that changes are queued. This provides confidence that their actions were captured and will sync when possible.\n\n## What This Task Creates\n\n### Component\n```typescript\nimport { useEffect, useState } from 'react';\nimport { View, Text, StyleSheet, Animated } from 'react-native';\nimport { offlineQueue } from '@/lib/offline-queue';\nimport { useColors } from '@/hooks/use-colors';\n\nexport function SyncStatusIndicator() {\n  const [pendingCount, setPendingCount] = useState(0);\n  const pulseAnim = useRef(new Animated.Value(1)).current;\n  const colors = useColors();\n\n  useEffect(() =\u003e {\n    // Subscribe to queue changes\n    const unsubscribe = offlineQueue.subscribe(async () =\u003e {\n      const count = await offlineQueue.getPendingCount();\n      setPendingCount(count);\n    });\n\n    // Initial count\n    offlineQueue.getPendingCount().then(setPendingCount);\n\n    return () =\u003e unsubscribe();\n  }, []);\n\n  // Pulse animation when there are pending items\n  useEffect(() =\u003e {\n    if (pendingCount \u003e 0) {\n      Animated.loop(\n        Animated.sequence([\n          Animated.timing(pulseAnim, {\n            toValue: 0.6,\n            duration: 1000,\n            useNativeDriver: true,\n          }),\n          Animated.timing(pulseAnim, {\n            toValue: 1,\n            duration: 1000,\n            useNativeDriver: true,\n          }),\n        ])\n      ).start();\n    } else {\n      pulseAnim.setValue(1);\n    }\n  }, [pendingCount]);\n\n  if (pendingCount === 0) return null;\n\n  return (\n    \u003cAnimated.View \n      style={[\n        styles.container, \n        { backgroundColor: colors.warningBackground, opacity: pulseAnim }\n      ]}\n    \u003e\n      \u003cView style={[styles.dot, { backgroundColor: colors.warning }]} /\u003e\n      \u003cText style={[styles.text, { color: colors.warningText }]}\u003e\n        {pendingCount} pending\n      \u003c/Text\u003e\n    \u003c/Animated.View\u003e\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    borderRadius: 16,\n  },\n  dot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n    marginRight: 6,\n  },\n  text: {\n    fontSize: 12,\n    fontWeight: '500',\n  },\n});\n```\n\n### Visual Design\n```\n┌─────────────────┐\n│ ● 3 pending     │  ← Yellow/orange badge\n└─────────────────┘\n```\n\n- **Dot**: Pulsing indicator (catches attention)\n- **Count**: Number of pending actions\n- **Background**: Subtle warning color\n- **Animation**: Gentle pulse when active\n\n### Placement Options\n1. **Header**: Next to settings gear icon\n2. **Tab bar**: Badge on Inbox tab\n3. **Floating**: Bottom of screen\n\nRecommended: In the header of screens that have queued actions (Settings, Subscriptions).\n\n```typescript\n// In Settings header\n\u003cStack.Screen\n  name=\"index\"\n  options={{\n    title: 'Settings',\n    headerRight: () =\u003e \u003cSyncStatusIndicator /\u003e,\n  }}\n/\u003e\n```\n\n### States\n| State | Display |\n|-------|---------|\n| 0 pending | Hidden (returns null) |\n| 1 pending | \"1 pending\" with pulse |\n| N pending | \"N pending\" with pulse |\n\n## Dependencies\n- Task 5.1 (offline queue with subscribe method)\n- Theme colors (warning colors)\n\n## Acceptance Criteria\n- [ ] Shows count when queue has items\n- [ ] Hidden when queue empty\n- [ ] Pulse animation active\n- [ ] Updates reactively\n- [ ] Correct theme colors\n- [ ] Accessible (role=\"status\")\n\n## Reference\n- Frontend Spec Section 9.2.2: Sync Status Indicator","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T21:18:29.104817-06:00","updated_at":"2025-12-17T23:00:43.075225-06:00","closed_at":"2025-12-17T23:00:43.075225-06:00","dependencies":[{"issue_id":"zine-nnb.23","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.10517-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.24","title":"6.3 Create SyncNowButton component","description":"# 6.3 Create SyncNowButton component\n\n## File\n`apps/mobile/components/sync-now-button.tsx`\n\n## Background \u0026 Rationale\nUsers sometimes want to manually trigger a sync for a subscription rather than waiting for the next automatic poll. This button provides that control with appropriate rate limiting feedback.\n\n## What This Task Creates\n\n### Component\n```typescript\nimport { Pressable, Text, StyleSheet, ActivityIndicator } from 'react-native';\nimport { useSyncNow } from '@/hooks/use-sync-now';\nimport { useColors } from '@/hooks/use-colors';\n\ninterface SyncNowButtonProps {\n  subscriptionId: string;\n  compact?: boolean;\n}\n\nexport function SyncNowButton({ subscriptionId, compact = false }: SyncNowButtonProps) {\n  const { syncNow, isLoading, cooldownSeconds, lastResult } = useSyncNow(subscriptionId);\n  const colors = useColors();\n\n  const isDisabled = isLoading || cooldownSeconds \u003e 0;\n\n  const handlePress = () =\u003e {\n    if (!isDisabled) {\n      syncNow();\n    }\n  };\n\n  const getButtonText = () =\u003e {\n    if (isLoading) return 'Syncing...';\n    if (cooldownSeconds \u003e 0) return formatCooldown(cooldownSeconds);\n    return compact ? 'Sync' : 'Sync Now';\n  };\n\n  return (\n    \u003cPressable\n      onPress={handlePress}\n      disabled={isDisabled}\n      style={[\n        styles.button,\n        compact \u0026\u0026 styles.buttonCompact,\n        isDisabled \u0026\u0026 styles.buttonDisabled,\n        { backgroundColor: isDisabled ? colors.disabled : colors.primary },\n      ]}\n    \u003e\n      {isLoading ? (\n        \u003cActivityIndicator size=\"small\" color={colors.buttonText} /\u003e\n      ) : (\n        \u003cText style={[styles.text, { color: colors.buttonText }]}\u003e\n          {getButtonText()}\n        \u003c/Text\u003e\n      )}\n    \u003c/Pressable\u003e\n  );\n}\n\nfunction formatCooldown(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    paddingHorizontal: 16,\n    paddingVertical: 10,\n    borderRadius: 8,\n    alignItems: 'center',\n    justifyContent: 'center',\n    minWidth: 100,\n  },\n  buttonCompact: {\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    minWidth: 60,\n  },\n  buttonDisabled: {\n    opacity: 0.6,\n  },\n  text: {\n    fontWeight: '600',\n    fontSize: 14,\n  },\n});\n```\n\n### Button States\n| State | Display | Interactable |\n|-------|---------|--------------|\n| Ready | \"Sync Now\" (blue) | Yes |\n| Loading | Spinner + \"Syncing...\" | No |\n| Cooldown | \"4:32\" countdown | No |\n| Error | \"Sync Now\" (ready again) | Yes |\n\n### Cooldown Display\nRate limit is 5 minutes per subscription. Shows countdown:\n- `4:59` → `4:58` → ... → `0:01` → \"Sync Now\"\n\n### Result Feedback\nAfter sync completes, show toast or inline feedback:\n- Success: \"Found 3 new items\" or \"No new content\"\n- Error: \"Sync failed. Try again.\"\n\nThis is handled by the parent component using `lastResult` from the hook.\n\n### Usage Examples\n```typescript\n// Full button on subscription detail screen\n\u003cSyncNowButton subscriptionId={subscription.id} /\u003e\n\n// Compact button in subscription list item\n\u003cSyncNowButton subscriptionId={subscription.id} compact /\u003e\n```\n\n## Dependencies\n- Task 3.4 (useSyncNow hook)\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Shows loading state during sync\n- [ ] Disabled during cooldown\n- [ ] Countdown timer updates every second\n- [ ] Correct colors for states\n- [ ] Compact variant works\n- [ ] Accessible (disabled state announced)\n\n## Reference\n- Frontend Spec Section 6.5: Manual Sync Button","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.166198-06:00","updated_at":"2025-12-17T23:00:41.757465-06:00","closed_at":"2025-12-17T23:00:41.757465-06:00","dependencies":[{"issue_id":"zine-nnb.24","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.166523-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.25","title":"7.1 Create InboxItem type with source attribution","description":"# 7.1 Create InboxItem type with source attribution\n\n## File\n`apps/mobile/types/inbox.ts`\n\n## Background \u0026 Rationale\nInbox items from subscriptions need to show where they came from (e.g., \"📺 MKBHD · 2 hours ago\"). This requires extending the base item type with source attribution information.\n\n## What This Task Creates\n\n### SourceAttribution Interface\n```typescript\nexport interface SourceAttribution {\n  /** The subscription that delivered this item */\n  subscriptionId: string;\n  /** Display name of the source (channel/show name) */\n  sourceName: string;\n  /** Provider type for icon/styling purposes */\n  provider: 'YOUTUBE' | 'SPOTIFY';\n  /** Optional thumbnail/avatar URL for the source */\n  sourceImageUrl?: string | null;\n}\n```\n\n### InboxItem Interface\n```typescript\nexport interface InboxItem extends ItemWithUserState {\n  /**\n   * Source attribution for subscription-delivered items.\n   * Present when the item was delivered via a subscription.\n   * May be absent for manually-added items.\n   */\n  source?: SourceAttribution;\n}\n```\n\n### Response Type\n```typescript\nexport interface InboxItemsResponse {\n  items: InboxItem[];\n  nextCursor?: string;\n  hasMore: boolean;\n}\n```\n\n## Type Hierarchy\n```\nInboxItem\n├── extends ItemWithUserState (from hooks/use-items.ts)\n│   ├── item: { id, title, summary, creator, thumbnailUrl, ... }\n│   └── userItem: { id, itemId, state, ingestedAt, ... }\n└── source?: SourceAttribution (NEW)\n```\n\n## Why Optional Source?\n- Subscription-delivered items have source attribution\n- Manually-added items don't have a subscription source\n- Future sources (imports, shares) may not have subscriptions\n\n## Usage in UI\n```typescript\nconst renderItem = ({ item }: { item: InboxItem }) =\u003e (\n  \u003cView\u003e\n    {item.source \u0026\u0026 (\n      \u003cText\u003e\n        {item.source.provider === 'YOUTUBE' ? '📺' : '🎧'} {item.source.sourceName}\n      \u003c/Text\u003e\n    )}\n    \u003cText\u003e{item.item.title}\u003c/Text\u003e\n  \u003c/View\u003e\n);\n```\n\n## Backend Contract\nThe `items.inbox` tRPC endpoint should return `InboxItem[]` with `source` populated for subscription-delivered content.\n\n## Dependencies\n- Existing `ItemWithUserState` from `hooks/use-items.ts`\n\n## Acceptance Criteria\n- [ ] InboxItem extends existing types correctly\n- [ ] Source is optional\n- [ ] Provider enum matches backend\n- [ ] Types exported for use in components\n\n## Reference\n- Frontend Spec Section 6.2: InboxItem Type Definition","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:29.226262-06:00","updated_at":"2025-12-17T22:33:00.832176-06:00","closed_at":"2025-12-17T22:33:00.832176-06:00","dependencies":[{"issue_id":"zine-nnb.25","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.226594-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.26","title":"7.2 Enhance Inbox screen with source attribution display","description":"# 7.2 Enhance Inbox screen with source attribution display\n\n## File\n`apps/mobile/app/(tabs)/inbox.tsx`\n\n## Background \u0026 Rationale\nWhen users see items from subscriptions in their inbox, they should know where each item came from. This provides context and helps with triage decisions.\n\n## What This Task Creates\n\n### Source Attribution Row\nFor each inbox item, display:\n```\n┌─────────────────────────────────────┐\n│ 📺 MKBHD · 2 hours ago              │\n│                                     │\n│ iPhone 16 Review: Everything        │\n│ You Need to Know                    │\n│                                     │\n│ 12:34 · VIDEO                       │\n│     [Archive]  [Bookmark]           │\n└─────────────────────────────────────┘\n```\n\n### Implementation Pattern\n```typescript\nfunction InboxItemCard({ item }: { item: InboxItem }) {\n  return (\n    \u003cView style={styles.card}\u003e\n      {/* Source Attribution */}\n      {item.source \u0026\u0026 (\n        \u003cView style={styles.sourceRow}\u003e\n          \u003cText style={styles.sourceIcon}\u003e\n            {item.source.provider === 'YOUTUBE' ? '📺' : '🎧'}\n          \u003c/Text\u003e\n          \u003cText style={styles.sourceName}\u003e{item.source.sourceName}\u003c/Text\u003e\n          \u003cText style={styles.separator}\u003e·\u003c/Text\u003e\n          \u003cText style={styles.timestamp}\u003e\n            {formatRelativeTime(item.item.publishedAt)}\n          \u003c/Text\u003e\n        \u003c/View\u003e\n      )}\n      \n      {/* Item Content */}\n      \u003cText style={styles.title}\u003e{item.item.title}\u003c/Text\u003e\n      \n      {/* Metadata */}\n      \u003cView style={styles.metaRow}\u003e\n        \u003cText style={styles.duration}\u003e{formatDuration(item.item.duration)}\u003c/Text\u003e\n        \u003cText style={styles.contentType}\u003e{item.item.contentType}\u003c/Text\u003e\n      \u003c/View\u003e\n      \n      {/* Actions */}\n      \u003cView style={styles.actionsRow}\u003e\n        \u003cPressable onPress={() =\u003e handleArchive(item)}\u003e\n          \u003cText\u003eArchive\u003c/Text\u003e\n        \u003c/Pressable\u003e\n        \u003cPressable onPress={() =\u003e handleBookmark(item)}\u003e\n          \u003cText\u003eBookmark\u003c/Text\u003e\n        \u003c/Pressable\u003e\n      \u003c/View\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### Styling\n- Source row: 14px, secondary text color\n- Icon + name: Row layout with small gap\n- Separator (·): Gray\n- Timestamp: Relative format (\"2 hours ago\")\n\n## Provider Icons\n| Provider | Icon | Color Context |\n|----------|------|---------------|\n| YouTube | 📺 | Red accent if needed |\n| Spotify | 🎧 | Green accent if needed |\n\n## Dependencies\n- Task 7.1 (InboxItem type)\n- Relative time formatting utility\n\n## Acceptance Criteria\n- [ ] Source attribution shows when present\n- [ ] Correct icon for each provider\n- [ ] Source name displays\n- [ ] Relative timestamp works\n- [ ] Graceful fallback when no source\n- [ ] Styling matches design system\n\n## Reference\n- Frontend Spec Section 6.1: Item Layout","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.285864-06:00","updated_at":"2025-12-17T22:57:41.118298-06:00","closed_at":"2025-12-17T22:57:41.118298-06:00","dependencies":[{"issue_id":"zine-nnb.26","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.286189-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.27","title":"7.3 Add pull-to-refresh functionality to Inbox","description":"# 7.3 Add pull-to-refresh functionality to Inbox\n\n## File\n`apps/mobile/app/(tabs)/inbox.tsx`\n\n## Background \u0026 Rationale\nUsers expect to be able to pull down to refresh their inbox and check for new items. This is a standard mobile pattern that provides immediate feedback and control.\n\n## What This Task Creates\n\n### RefreshControl Integration\n```typescript\nexport default function InboxScreen() {\n  const { data, isLoading, error, refetch } = useInboxItems();\n  const [isRefreshing, setIsRefreshing] = useState(false);\n\n  const handleRefresh = useCallback(async () =\u003e {\n    setIsRefreshing(true);\n    try {\n      await refetch();\n    } finally {\n      setIsRefreshing(false);\n    }\n  }, [refetch]);\n\n  const refreshControlProps: RefreshControlProps = useMemo(() =\u003e ({\n    refreshing: isRefreshing,\n    onRefresh: handleRefresh,\n    tintColor: colors.primary,      // iOS spinner color\n    colors: [colors.primary],       // Android spinner colors\n    progressBackgroundColor: colors.background,\n  }), [isRefreshing, handleRefresh, colors]);\n\n  return (\n    \u003cFlatList\n      data={data?.items}\n      refreshControl={\u003cRefreshControl {...refreshControlProps} /\u003e}\n      // ...\n    /\u003e\n  );\n}\n```\n\n### Empty State with Refresh\nWhen inbox is empty, still allow pull-to-refresh:\n```typescript\n{data?.items.length === 0 ? (\n  \u003cScrollView\n    contentContainerStyle={styles.emptyScrollContent}\n    refreshControl={\u003cRefreshControl {...refreshControlProps} /\u003e}\n  \u003e\n    \u003cEmptyState colors={colors} /\u003e\n  \u003c/ScrollView\u003e\n) : (\n  \u003cFlatList\n    refreshControl={\u003cRefreshControl {...refreshControlProps} /\u003e}\n    // ...\n  /\u003e\n)}\n```\n\n### Why Separate isRefreshing State?\n- Distinguishes initial load from refresh\n- Prevents showing loading spinner during pull gesture\n- Allows loading indicator in correct position\n\n## Behavior Summary\n\n| Action | Result |\n|--------|--------|\n| Pull down on list | Refetches inbox items |\n| Pull down on empty | Refetches (may show new items) |\n| During refresh | Shows spinner |\n| On success | List updates |\n| On error | Shows toast, list unchanged |\n\n## Dependencies\n- useInboxItems hook\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Pull gesture triggers refresh\n- [ ] Spinner shows during refresh\n- [ ] Works on both populated and empty lists\n- [ ] Correct colors for light/dark mode\n- [ ] Doesn't interfere with normal scrolling\n\n## Reference\n- Frontend Spec Section 6.3: Pull to Refresh","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.347722-06:00","updated_at":"2025-12-17T22:57:41.808245-06:00","closed_at":"2025-12-17T22:57:41.808245-06:00","dependencies":[{"issue_id":"zine-nnb.27","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.348004-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.28","title":"7.4 Create loading, error, and empty state components","description":"Created apps/mobile/components/list-states.tsx with three reusable components: LoadingState, ErrorState, EmptyState","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.406869-06:00","updated_at":"2025-12-17T22:53:59.408045-06:00","closed_at":"2025-12-17T22:53:59.408045-06:00","dependencies":[{"issue_id":"zine-nnb.28","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.407194-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.29","title":"8.1 Create base ErrorBoundary component","description":"Implemented base ErrorBoundary component with all required features","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:29.465795-06:00","updated_at":"2025-12-17T21:36:30.621974-06:00","closed_at":"2025-12-17T21:36:30.621974-06:00","dependencies":[{"issue_id":"zine-nnb.29","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.466097-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.3","title":"1.3 Implement connectProvider OAuth flow function","description":"# 1.3 Implement connectProvider OAuth flow function\n\n## File\n`apps/mobile/lib/oauth.ts`\n\n## Background \u0026 Rationale\nThis is the main entry point for initiating OAuth connections. It orchestrates the complete flow from PKCE generation through browser authentication to state storage. The function is called when a user taps \"Connect YouTube\" or \"Connect Spotify\".\n\n## What This Task Creates\n\n### Main Function\n```typescript\nasync function connectProvider(provider: 'YOUTUBE' | 'SPOTIFY'): Promise\u003cvoid\u003e\n```\n\n### Flow Steps (all client-side except step 3)\n1. **Generate PKCE** - Create verifier and challenge\n2. **Store verifier** - Save to SecureStore for later exchange\n3. **Generate state** - Format: `PROVIDER:uuid` for callback identification\n4. **Register state with server** - tRPC call for CSRF protection\n5. **Build auth URL** - Include client_id, redirect_uri, scopes, challenge, state\n6. **Open browser** - Use `WebBrowser.openAuthSessionAsync()`\n7. **Handle redirect** - Parse code and state from callback URL\n8. **Validate state** - Client-side check before exchange\n9. **Cleanup** - Remove temporary storage\n\n### State Parameter Format\nThe state parameter uses format `PROVIDER:uuid` because:\n- The callback handler needs to know which provider's SecureStore keys to use\n- The UUID portion provides CSRF protection\n- Example: `YOUTUBE:abc-123-def-456`\n\n### YouTube-Specific Parameters\n```typescript\nif (provider === 'YOUTUBE') {\n  authUrl.searchParams.set('access_type', 'offline');  // Get refresh token\n  authUrl.searchParams.set('prompt', 'consent');        // Force consent screen\n}\n```\n\n## Error Handling\n- Throws if WebBrowser returns non-success\n- Throws if state mismatch (possible CSRF)\n- Throws if no code in callback (user denied or error)\n\n## Dependencies\n- Task 1.1 (PKCE generation functions)\n- `expo-web-browser` for browser session\n- `expo-secure-store` for verifier storage\n- tRPC client for state registration\n\n## Acceptance Criteria\n- [ ] PKCE values generated and stored correctly\n- [ ] State includes provider prefix for callback handling\n- [ ] Auth URL includes all required parameters\n- [ ] YouTube includes offline access parameters\n- [ ] Browser opens and returns to app\n- [ ] State validation prevents CSRF attacks\n- [ ] Cleanup removes all temporary storage\n\n## Reference\n- Frontend Spec Section 1.2: Connect Provider Flow","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:27.86808-06:00","updated_at":"2025-12-17T22:36:56.121498-06:00","closed_at":"2025-12-17T22:36:56.121498-06:00","dependencies":[{"issue_id":"zine-nnb.3","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:27.868393-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.30","title":"8.2 Create SubscriptionErrorBoundary component","description":"# 8.2 Create SubscriptionErrorBoundary component\n\n## File\n`apps/mobile/components/subscription-error-boundary.tsx`\n\n## Background \u0026 Rationale\nSubscription-related errors need specialized handling that's different from generic errors. For example, if a subscription fails to load due to a revoked OAuth token, the error message and recovery action should guide the user to reconnect their account.\n\n## What This Task Creates\n\n### Component\n```typescript\nimport { ErrorBoundary } from './error-boundary';\nimport { View, Text, Pressable, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { useColors } from '@/hooks/use-colors';\n\ninterface SubscriptionErrorBoundaryProps {\n  children: ReactNode;\n  subscriptionId?: string;\n  provider?: 'YOUTUBE' | 'SPOTIFY';\n}\n\nexport function SubscriptionErrorBoundary({\n  children,\n  subscriptionId,\n  provider,\n}: SubscriptionErrorBoundaryProps) {\n  const router = useRouter();\n  const colors = useColors();\n\n  const handleReconnect = () =\u003e {\n    if (provider) {\n      router.push(`/subscriptions/connect/${provider.toLowerCase()}`);\n    } else {\n      router.push('/settings/connections');\n    }\n  };\n\n  const renderFallback = (error: Error, reset: () =\u003e void) =\u003e {\n    const isAuthError = isOAuthRelatedError(error);\n    \n    return (\n      \u003cView style={[styles.container, { backgroundColor: colors.errorBackground }]}\u003e\n        \u003cText style={styles.emoji}\u003e{isAuthError ? '🔐' : '⚠️'}\u003c/Text\u003e\n        \u003cText style={[styles.title, { color: colors.text }]}\u003e\n          {isAuthError ? 'Account Reconnection Needed' : 'Subscription Error'}\n        \u003c/Text\u003e\n        \u003cText style={[styles.message, { color: colors.textSecondary }]}\u003e\n          {isAuthError\n            ? `Your ${provider || 'streaming'} account needs to be reconnected.`\n            : 'There was a problem loading this subscription.'}\n        \u003c/Text\u003e\n        \n        \u003cView style={styles.actions}\u003e\n          {isAuthError ? (\n            \u003cPressable\n              style={[styles.button, { backgroundColor: colors.primary }]}\n              onPress={handleReconnect}\n            \u003e\n              \u003cText style={[styles.buttonText, { color: colors.buttonText }]}\u003e\n                Reconnect Account\n              \u003c/Text\u003e\n            \u003c/Pressable\u003e\n          ) : (\n            \u003cPressable\n              style={[styles.button, { backgroundColor: colors.primary }]}\n              onPress={reset}\n            \u003e\n              \u003cText style={[styles.buttonText, { color: colors.buttonText }]}\u003e\n                Try Again\n              \u003c/Text\u003e\n            \u003c/Pressable\u003e\n          )}\n        \u003c/View\u003e\n      \u003c/View\u003e\n    );\n  };\n\n  return (\n    \u003cErrorBoundary\n      fallback={renderFallback}\n      onError={(error, errorInfo) =\u003e {\n        console.error('[SubscriptionError]', {\n          error,\n          subscriptionId,\n          provider,\n          errorInfo,\n        });\n      }}\n    \u003e\n      {children}\n    \u003c/ErrorBoundary\u003e\n  );\n}\n\nfunction isOAuthRelatedError(error: Error): boolean {\n  const message = error.message.toLowerCase();\n  return (\n    message.includes('unauthorized') ||\n    message.includes('token expired') ||\n    message.includes('access revoked') ||\n    message.includes('401')\n  );\n}\n```\n\n### Error Classification\n| Error Type | Detection | Recovery Action |\n|------------|-----------|-----------------|\n| OAuth/Auth | 401, \"token expired\", \"revoked\" | Reconnect Account |\n| Network | \"network\", \"timeout\", \"fetch\" | Try Again |\n| Not Found | 404 | Remove subscription |\n| Generic | Anything else | Try Again |\n\n### Usage\n```typescript\n// Wrap individual subscription cards to isolate failures\n\u003cFlatList\n  data={subscriptions}\n  renderItem={({ item }) =\u003e (\n    \u003cSubscriptionErrorBoundary \n      subscriptionId={item.id}\n      provider={item.provider}\n    \u003e\n      \u003cSubscriptionCard subscription={item} /\u003e\n    \u003c/SubscriptionErrorBoundary\u003e\n  )}\n/\u003e\n```\n\n### Why Isolate Each Subscription?\nIf one subscription fails (e.g., revoked token), we don't want the entire list to crash. Each card has its own error boundary, so failures are isolated and users can still interact with working subscriptions.\n\n## Dependencies\n- Task 8.1 (base ErrorBoundary)\n- Theme colors\n- expo-router for navigation\n\n## Acceptance Criteria\n- [ ] Detects OAuth-related errors\n- [ ] Shows \"Reconnect Account\" for auth errors\n- [ ] Shows \"Try Again\" for generic errors\n- [ ] Provider-aware navigation\n- [ ] Logs error with context\n- [ ] Isolates failures per subscription\n\n## Reference\n- Frontend Spec Section 8.2: Subscription Error Boundary","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.525826-06:00","updated_at":"2025-12-17T22:57:39.578661-06:00","closed_at":"2025-12-17T22:57:39.578661-06:00","dependencies":[{"issue_id":"zine-nnb.30","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.526137-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.31","title":"8.3 Create OAuthErrorBoundary component","description":"# 8.3 Create OAuthErrorBoundary component\n\n## File\n`apps/mobile/components/oauth-error-boundary.tsx`\n\n## Background \u0026 Rationale\nOAuth flows can fail in specific ways that require specialized error handling. This boundary catches errors during the OAuth process and provides appropriate recovery options based on the error type.\n\n## What This Task Creates\n\n### Component\n```typescript\nimport { ErrorBoundary } from './error-boundary';\nimport { View, Text, Pressable, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { useColors } from '@/hooks/use-colors';\nimport { OAuthError, OAuthErrorCode, parseOAuthError } from '@/lib/oauth-errors';\n\ninterface OAuthErrorBoundaryProps {\n  children: ReactNode;\n  provider?: 'YOUTUBE' | 'SPOTIFY';\n  onRetry?: () =\u003e void;\n}\n\nexport function OAuthErrorBoundary({\n  children,\n  provider,\n  onRetry,\n}: OAuthErrorBoundaryProps) {\n  const router = useRouter();\n  const colors = useColors();\n\n  const renderFallback = (error: Error, reset: () =\u003e void) =\u003e {\n    const oauthError = parseOAuthError(error);\n    \n    return (\n      \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n        \u003cText style={styles.emoji}\u003e{getErrorEmoji(oauthError.code)}\u003c/Text\u003e\n        \u003cText style={[styles.title, { color: colors.text }]}\u003e\n          {getErrorTitle(oauthError.code)}\n        \u003c/Text\u003e\n        \u003cText style={[styles.message, { color: colors.textSecondary }]}\u003e\n          {oauthError.message}\n        \u003c/Text\u003e\n        \n        \u003cView style={styles.actions}\u003e\n          {oauthError.recoverable \u0026\u0026 (\n            \u003cPressable\n              style={[styles.primaryButton, { backgroundColor: colors.primary }]}\n              onPress={() =\u003e {\n                reset();\n                onRetry?.();\n              }}\n            \u003e\n              \u003cText style={[styles.buttonText, { color: colors.buttonText }]}\u003e\n                {getActionLabel(oauthError.action)}\n              \u003c/Text\u003e\n            \u003c/Pressable\u003e\n          )}\n          \n          \u003cPressable\n            style={[styles.secondaryButton, { borderColor: colors.border }]}\n            onPress={() =\u003e router.back()}\n          \u003e\n            \u003cText style={[styles.secondaryButtonText, { color: colors.text }]}\u003e\n              Go Back\n            \u003c/Text\u003e\n          \u003c/Pressable\u003e\n        \u003c/View\u003e\n      \u003c/View\u003e\n    );\n  };\n\n  return (\n    \u003cErrorBoundary\n      fallback={renderFallback}\n      onError={(error) =\u003e {\n        console.error('[OAuthError]', { error, provider });\n      }}\n    \u003e\n      {children}\n    \u003c/ErrorBoundary\u003e\n  );\n}\n\nfunction getErrorEmoji(code: OAuthErrorCode): string {\n  switch (code) {\n    case OAuthErrorCode.USER_CANCELLED:\n    case OAuthErrorCode.USER_DENIED:\n      return '🚫';\n    case OAuthErrorCode.NETWORK_ERROR:\n      return '📡';\n    case OAuthErrorCode.STATE_MISMATCH:\n    case OAuthErrorCode.STATE_EXPIRED:\n      return '🔒';\n    default:\n      return '⚠️';\n  }\n}\n\nfunction getErrorTitle(code: OAuthErrorCode): string {\n  switch (code) {\n    case OAuthErrorCode.USER_CANCELLED:\n      return 'Authorization Cancelled';\n    case OAuthErrorCode.USER_DENIED:\n      return 'Access Denied';\n    case OAuthErrorCode.NETWORK_ERROR:\n      return 'Connection Problem';\n    case OAuthErrorCode.STATE_MISMATCH:\n    case OAuthErrorCode.STATE_EXPIRED:\n      return 'Security Error';\n    default:\n      return 'Connection Failed';\n  }\n}\n\nfunction getActionLabel(action?: string): string {\n  switch (action) {\n    case 'retry':\n      return 'Try Again';\n    case 'reauthorize':\n      return 'Reconnect Account';\n    default:\n      return 'Try Again';\n  }\n}\n```\n\n### Error Scenarios\n| Error Code | Emoji | Title | Recoverable | Action |\n|------------|-------|-------|-------------|--------|\n| USER_CANCELLED | 🚫 | Authorization Cancelled | Yes | Try Again |\n| USER_DENIED | 🚫 | Access Denied | Yes | Try Again |\n| NETWORK_ERROR | 📡 | Connection Problem | Yes | Try Again |\n| STATE_MISMATCH | 🔒 | Security Error | Yes | Try Again |\n| STATE_EXPIRED | 🔒 | Security Error | Yes | Try Again |\n| TOKEN_EXCHANGE_FAILED | ⚠️ | Connection Failed | Yes | Reconnect |\n| PROVIDER_ERROR | ⚠️ | Connection Failed | Maybe | Contact Support |\n\n### Usage\n```typescript\n// Wrap OAuth connect screens\nexport default function YouTubeConnectScreen() {\n  const handleConnect = () =\u003e connectProvider('YOUTUBE');\n\n  return (\n    \u003cOAuthErrorBoundary provider=\"YOUTUBE\" onRetry={handleConnect}\u003e\n      \u003cConnectContent onConnect={handleConnect} /\u003e\n    \u003c/OAuthErrorBoundary\u003e\n  );\n}\n```\n\n### Recovery Flow\n1. Error caught by boundary\n2. Error parsed into OAuthError type\n3. Appropriate UI shown based on error code\n4. User can retry (calls reset + onRetry) or go back\n5. On retry, boundary resets and child attempts OAuth again\n\n## Dependencies\n- Task 8.1 (base ErrorBoundary)\n- Task 1.2 (OAuth error types)\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Parses OAuth errors correctly\n- [ ] Shows appropriate emoji/title per error type\n- [ ] Recoverable errors show retry button\n- [ ] Non-recoverable errors show only \"Go Back\"\n- [ ] Reset + retry flow works\n- [ ] Logs with provider context\n\n## Reference\n- Frontend Spec Section 8.3: OAuth Error Boundary","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.584126-06:00","updated_at":"2025-12-17T22:57:40.229866-06:00","closed_at":"2025-12-17T22:57:40.229866-06:00","dependencies":[{"issue_id":"zine-nnb.31","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.584445-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.32","title":"8.4 Create QueryErrorBoundary with React Query integration","description":"# 8.4 Create QueryErrorBoundary with React Query integration\n\n## File\n`apps/mobile/components/query-error-boundary.tsx`\n\n## Background \u0026 Rationale\nReact Query errors (failed fetches) should be handled gracefully with retry capabilities. This boundary integrates with React Query's error handling patterns and provides automatic retry functionality.\n\n## What This Task Creates\n\n### Component\n```typescript\nimport { ErrorBoundary } from './error-boundary';\nimport { View, Text, Pressable, StyleSheet } from 'react-native';\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query';\nimport { useColors } from '@/hooks/use-colors';\n\ninterface QueryErrorBoundaryProps {\n  children: ReactNode;\n  queryKey?: unknown[];\n  fallbackMessage?: string;\n}\n\nexport function QueryErrorBoundary({\n  children,\n  queryKey,\n  fallbackMessage = 'Failed to load data',\n}: QueryErrorBoundaryProps) {\n  const { reset } = useQueryErrorResetBoundary();\n  const colors = useColors();\n\n  const renderFallback = (error: Error, resetBoundary: () =\u003e void) =\u003e {\n    const isNetworkError = isNetworkRelatedError(error);\n    \n    return (\n      \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n        \u003cText style={styles.emoji}\u003e{isNetworkError ? '📡' : '⚠️'}\u003c/Text\u003e\n        \u003cText style={[styles.title, { color: colors.text }]}\u003e\n          {isNetworkError ? 'Connection Problem' : 'Loading Error'}\n        \u003c/Text\u003e\n        \u003cText style={[styles.message, { color: colors.textSecondary }]}\u003e\n          {isNetworkError\n            ? 'Please check your internet connection and try again.'\n            : fallbackMessage}\n        \u003c/Text\u003e\n        \n        \u003cPressable\n          style={[styles.button, { backgroundColor: colors.primary }]}\n          onPress={() =\u003e {\n            // Reset React Query's error state\n            reset();\n            // Reset the error boundary\n            resetBoundary();\n          }}\n        \u003e\n          \u003cText style={[styles.buttonText, { color: colors.buttonText }]}\u003e\n            Try Again\n          \u003c/Text\u003e\n        \u003c/Pressable\u003e\n      \u003c/View\u003e\n    );\n  };\n\n  return (\n    \u003cErrorBoundary\n      fallback={renderFallback}\n      onError={(error) =\u003e {\n        console.error('[QueryError]', { error, queryKey });\n      }}\n      resetKeys={queryKey}\n    \u003e\n      {children}\n    \u003c/ErrorBoundary\u003e\n  );\n}\n\nfunction isNetworkRelatedError(error: Error): boolean {\n  const message = error.message.toLowerCase();\n  return (\n    message.includes('network') ||\n    message.includes('fetch') ||\n    message.includes('timeout') ||\n    message.includes('connection') ||\n    message.includes('offline')\n  );\n}\n```\n\n### React Query Integration\n\n#### useQueryErrorResetBoundary\nReact Query provides this hook to reset error state when the boundary resets. This ensures that:\n1. The query will retry when the boundary resets\n2. React Query's internal error state is cleared\n3. The query doesn't immediately fail again from cached error\n\n#### resetKeys Prop\nWhen `queryKey` changes, the boundary automatically resets. This handles cases where:\n- User navigates to a different item\n- Query parameters change\n- Data should be refetched with new params\n\n### Usage Patterns\n\n#### Wrap a Single Query\n```typescript\n\u003cQueryErrorBoundary queryKey={['subscriptions', 'list']}\u003e\n  \u003cSubscriptionsList /\u003e\n\u003c/QueryErrorBoundary\u003e\n```\n\n#### Wrap Multiple Related Queries\n```typescript\n\u003cQueryErrorBoundary fallbackMessage=\"Failed to load your content\"\u003e\n  \u003cInboxScreen /\u003e\n\u003c/QueryErrorBoundary\u003e\n```\n\n#### With Suspense (Advanced)\n```typescript\n\u003cQueryErrorBoundary queryKey={['items', itemId]}\u003e\n  \u003cSuspense fallback={\u003cLoadingState /\u003e}\u003e\n    \u003cItemDetail /\u003e\n  \u003c/Suspense\u003e\n\u003c/QueryErrorBoundary\u003e\n```\n\n### Error Classification\n| Error Type | Detection | Message |\n|------------|-----------|---------|\n| Network | \"network\", \"fetch\", \"timeout\" | \"Check your internet connection\" |\n| Server | 5xx status codes | \"Server error, try again later\" |\n| Not Found | 404 | Custom per-context |\n| Generic | Fallback | Provided fallbackMessage |\n\n## Dependencies\n- Task 8.1 (base ErrorBoundary)\n- `@tanstack/react-query` (useQueryErrorResetBoundary)\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Integrates with useQueryErrorResetBoundary\n- [ ] Reset clears both boundary and query error state\n- [ ] Detects network-related errors\n- [ ] Shows appropriate message per error type\n- [ ] resetKeys triggers boundary reset on query key change\n- [ ] Logs with query key context\n\n## Reference\n- Frontend Spec Section 8.4: Query Error Boundary\n- React Query Error Boundary docs","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.6447-06:00","updated_at":"2025-12-17T22:40:27.913391-06:00","closed_at":"2025-12-17T22:40:27.913391-06:00","dependencies":[{"issue_id":"zine-nnb.32","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.645043-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.33","title":"9.1 Create Subscription management screen","description":"Created subscription management screen with add subscription buttons (YouTube, Spotify), FlatList for subscriptions, status display (ACTIVE=green, PAUSED=yellow), empty state, and proper theme support.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.704605-06:00","updated_at":"2025-12-17T22:47:25.277465-06:00","closed_at":"2025-12-17T22:47:25.277465-06:00","dependencies":[{"issue_id":"zine-nnb.33","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.706678-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.34","title":"9.2 Create YouTube OAuth connect screen","description":"# 9.2 Create YouTube OAuth connect screen\n\n## File\n`apps/mobile/app/subscriptions/connect/youtube.tsx`\n\n## Background \u0026 Rationale\nThis screen guides users through connecting their YouTube account. It explains what permissions are needed and why, then initiates the OAuth flow when the user is ready.\n\n## What This Task Creates\n\n### Screen Layout\n```\n┌─────────────────────────────────────┐\n│ ← Connect YouTube                   │\n├─────────────────────────────────────┤\n│                                     │\n│            🎬                       │\n│                                     │\n│      Connect YouTube               │\n│                                     │\n│  Subscribe to your favorite        │\n│  YouTube channels and get new      │\n│  videos delivered to your inbox.   │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ ✓ View your subscriptions     │  │\n│  │ ✓ Access channel information  │  │\n│  │ ✗ We never post or modify     │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │     Connect with Google       │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  By connecting, you agree to our   │\n│  Terms of Service and Privacy      │\n│  Policy.                           │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n### Component Implementation\n```typescript\nimport { View, Text, Pressable, StyleSheet, ActivityIndicator } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { useState } from 'react';\nimport { connectProvider } from '@/lib/oauth';\nimport { OAuthErrorBoundary } from '@/components/oauth-error-boundary';\nimport { useColors } from '@/hooks/use-colors';\n\nexport default function YouTubeConnectScreen() {\n  const [isConnecting, setIsConnecting] = useState(false);\n  const router = useRouter();\n  const colors = useColors();\n\n  const handleConnect = async () =\u003e {\n    setIsConnecting(true);\n    try {\n      await connectProvider('YOUTUBE');\n      // Success - OAuthCallbackHandler will navigate\n    } catch (error) {\n      // Error will be caught by OAuthErrorBoundary\n      throw error;\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n\n  return (\n    \u003cOAuthErrorBoundary provider=\"YOUTUBE\" onRetry={handleConnect}\u003e\n      \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n        \u003cText style={styles.emoji}\u003e🎬\u003c/Text\u003e\n        \n        \u003cText style={[styles.title, { color: colors.text }]}\u003e\n          Connect YouTube\n        \u003c/Text\u003e\n        \n        \u003cText style={[styles.description, { color: colors.textSecondary }]}\u003e\n          Subscribe to your favorite YouTube channels and get new videos\n          delivered to your inbox.\n        \u003c/Text\u003e\n\n        \u003cView style={styles.permissions}\u003e\n          \u003cPermissionRow \n            allowed \n            text=\"View your subscriptions\" \n            colors={colors}\n          /\u003e\n          \u003cPermissionRow \n            allowed \n            text=\"Access channel information\" \n            colors={colors}\n          /\u003e\n          \u003cPermissionRow \n            allowed={false} \n            text=\"We never post or modify\" \n            colors={colors}\n          /\u003e\n        \u003c/View\u003e\n\n        \u003cPressable\n          style={[\n            styles.connectButton,\n            { backgroundColor: '#EA4335' }, // YouTube red\n            isConnecting \u0026\u0026 styles.buttonDisabled,\n          ]}\n          onPress={handleConnect}\n          disabled={isConnecting}\n        \u003e\n          {isConnecting ? (\n            \u003cActivityIndicator color=\"#fff\" /\u003e\n          ) : (\n            \u003cText style={styles.connectButtonText}\u003e\n              Connect with Google\n            \u003c/Text\u003e\n          )}\n        \u003c/Pressable\u003e\n\n        \u003cText style={[styles.legal, { color: colors.textTertiary }]}\u003e\n          By connecting, you agree to our{' '}\n          \u003cText style={styles.link}\u003eTerms of Service\u003c/Text\u003e and{' '}\n          \u003cText style={styles.link}\u003ePrivacy Policy\u003c/Text\u003e.\n        \u003c/Text\u003e\n      \u003c/View\u003e\n    \u003c/OAuthErrorBoundary\u003e\n  );\n}\n\nfunction PermissionRow({ allowed, text, colors }) {\n  return (\n    \u003cView style={styles.permissionRow}\u003e\n      \u003cText style={[styles.permissionIcon, { color: allowed ? colors.success : colors.textSecondary }]}\u003e\n        {allowed ? '✓' : '✗'}\n      \u003c/Text\u003e\n      \u003cText style={[styles.permissionText, { color: colors.text }]}\u003e\n        {text}\n      \u003c/Text\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### Permissions Explained\nWe request `youtube.readonly` scope which allows:\n- ✓ View subscriptions list\n- ✓ View channel metadata (name, avatar, etc.)\n- ✓ View video metadata (title, duration, etc.)\n- ✗ Cannot post comments\n- ✗ Cannot like/dislike\n- ✗ Cannot subscribe/unsubscribe on YouTube\n\n### Brand Guidelines\n- Use YouTube red (#EA4335) for connect button\n- \"Connect with Google\" text (YouTube uses Google OAuth)\n- Display YouTube logo or emoji prominently\n\n### Error Handling\nWrapped in OAuthErrorBoundary which handles:\n- User cancelled flow\n- Network errors\n- Token exchange failures\n- State validation failures\n\n## Dependencies\n- Task 1.3 (connectProvider function)\n- Task 8.3 (OAuthErrorBoundary)\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Clear explanation of permissions\n- [ ] YouTube branding on button\n- [ ] Loading state during OAuth\n- [ ] Error boundary catches failures\n- [ ] Legal links to Terms/Privacy\n- [ ] Accessible button states\n\n## Reference\n- Frontend Spec Section 7.3: YouTube Connect Screen\n- Google Sign-In Branding Guidelines","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.769328-06:00","updated_at":"2025-12-17T22:47:25.821329-06:00","closed_at":"2025-12-17T22:47:25.821329-06:00","dependencies":[{"issue_id":"zine-nnb.34","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.770704-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.35","title":"9.3 Create Spotify OAuth connect screen","description":"# 9.3 Create Spotify OAuth connect screen\n\n## File\n`apps/mobile/app/subscriptions/connect/spotify.tsx`\n\n## Background \u0026 Rationale\nThis screen guides users through connecting their Spotify account. Similar to YouTube, it explains permissions and initiates the OAuth flow. Spotify uses different branding and permissions.\n\n## What This Task Creates\n\n### Screen Layout\n```\n┌─────────────────────────────────────┐\n│ ← Connect Spotify                   │\n├─────────────────────────────────────┤\n│                                     │\n│            🎧                       │\n│                                     │\n│      Connect Spotify               │\n│                                     │\n│  Subscribe to your favorite        │\n│  podcasts and get new episodes     │\n│  delivered to your inbox.          │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ ✓ View your saved shows       │  │\n│  │ ✓ Access podcast information  │  │\n│  │ ✗ We never modify your library│  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │     Connect with Spotify      │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  By connecting, you agree to our   │\n│  Terms of Service and Privacy      │\n│  Policy.                           │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n### Component Implementation\n```typescript\nimport { View, Text, Pressable, StyleSheet, ActivityIndicator } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { useState } from 'react';\nimport { connectProvider } from '@/lib/oauth';\nimport { OAuthErrorBoundary } from '@/components/oauth-error-boundary';\nimport { useColors } from '@/hooks/use-colors';\n\nexport default function SpotifyConnectScreen() {\n  const [isConnecting, setIsConnecting] = useState(false);\n  const router = useRouter();\n  const colors = useColors();\n\n  const handleConnect = async () =\u003e {\n    setIsConnecting(true);\n    try {\n      await connectProvider('SPOTIFY');\n      // Success - OAuthCallbackHandler will navigate\n    } catch (error) {\n      throw error;\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n\n  return (\n    \u003cOAuthErrorBoundary provider=\"SPOTIFY\" onRetry={handleConnect}\u003e\n      \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n        \u003cText style={styles.emoji}\u003e🎧\u003c/Text\u003e\n        \n        \u003cText style={[styles.title, { color: colors.text }]}\u003e\n          Connect Spotify\n        \u003c/Text\u003e\n        \n        \u003cText style={[styles.description, { color: colors.textSecondary }]}\u003e\n          Subscribe to your favorite podcasts and get new episodes\n          delivered to your inbox.\n        \u003c/Text\u003e\n\n        \u003cView style={styles.permissions}\u003e\n          \u003cPermissionRow \n            allowed \n            text=\"View your saved shows\" \n            colors={colors}\n          /\u003e\n          \u003cPermissionRow \n            allowed \n            text=\"Access podcast information\" \n            colors={colors}\n          /\u003e\n          \u003cPermissionRow \n            allowed={false} \n            text=\"We never modify your library\" \n            colors={colors}\n          /\u003e\n        \u003c/View\u003e\n\n        \u003cPressable\n          style={[\n            styles.connectButton,\n            { backgroundColor: '#1DB954' }, // Spotify green\n            isConnecting \u0026\u0026 styles.buttonDisabled,\n          ]}\n          onPress={handleConnect}\n          disabled={isConnecting}\n        \u003e\n          {isConnecting ? (\n            \u003cActivityIndicator color=\"#fff\" /\u003e\n          ) : (\n            \u003cText style={styles.connectButtonText}\u003e\n              Connect with Spotify\n            \u003c/Text\u003e\n          )}\n        \u003c/Pressable\u003e\n\n        \u003cText style={[styles.legal, { color: colors.textTertiary }]}\u003e\n          By connecting, you agree to our{' '}\n          \u003cText style={styles.link}\u003eTerms of Service\u003c/Text\u003e and{' '}\n          \u003cText style={styles.link}\u003ePrivacy Policy\u003c/Text\u003e.\n        \u003c/Text\u003e\n      \u003c/View\u003e\n    \u003c/OAuthErrorBoundary\u003e\n  );\n}\n```\n\n### Permissions Explained\nWe request `user-library-read` scope which allows:\n- ✓ View saved shows (podcasts)\n- ✓ View show metadata (name, description, episodes)\n- ✓ View episode metadata (title, duration, release date)\n- ✗ Cannot save/unsave shows\n- ✗ Cannot control playback\n- ✗ Cannot access music library\n\n### Brand Guidelines\n- Use Spotify green (#1DB954) for connect button\n- \"Connect with Spotify\" text\n- White text on green background\n- Display Spotify logo or emoji prominently\n\n### Key Differences from YouTube\n| Aspect | YouTube | Spotify |\n|--------|---------|---------|\n| Brand color | Red (#EA4335) | Green (#1DB954) |\n| OAuth provider | Google | Spotify |\n| Scope | youtube.readonly | user-library-read |\n| Content | Videos, channels | Podcasts, shows |\n| Button text | \"Connect with Google\" | \"Connect with Spotify\" |\n\n### Error Handling\nSame as YouTube - wrapped in OAuthErrorBoundary.\n\n## Dependencies\n- Task 1.3 (connectProvider function)\n- Task 8.3 (OAuthErrorBoundary)\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Clear explanation of permissions\n- [ ] Spotify branding on button\n- [ ] Loading state during OAuth\n- [ ] Error boundary catches failures\n- [ ] Legal links to Terms/Privacy\n- [ ] Accessible button states\n\n## Reference\n- Frontend Spec Section 7.4: Spotify Connect Screen\n- Spotify Design Guidelines","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.829925-06:00","updated_at":"2025-12-17T22:47:26.278371-06:00","closed_at":"2025-12-17T22:47:26.278371-06:00","dependencies":[{"issue_id":"zine-nnb.35","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.830654-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.36","title":"9.4 Create channel/show discovery screen","description":"# 9.4 Create channel/show discovery screen\n\n## File\n`apps/mobile/app/subscriptions/discover/[provider].tsx`\n\n## Background \u0026 Rationale\nAfter connecting a provider, users need a way to discover and subscribe to channels/shows. This screen shows content from their connected account that they can selectively subscribe to in Zine.\n\n## What This Task Creates\n\n### Screen Layout\n```\n┌─────────────────────────────────────┐\n│ ← Discover                    🔍   │\n├─────────────────────────────────────┤\n│                                     │\n│  YOUR YOUTUBE SUBSCRIPTIONS         │\n│                                     │\n│  ┌─────┬───────────────────────┐    │\n│  │     │ MKBHD                 │    │\n│  │ IMG │ Tech reviews          │    │\n│  │     │         [Subscribe]   │    │\n│  └─────┴───────────────────────┘    │\n│                                     │\n│  ┌─────┬───────────────────────┐    │\n│  │     │ Lex Fridman Podcast   │    │\n│  │ IMG │ Long-form interviews  │    │\n│  │     │           [Subscribed]│    │\n│  └─────┴───────────────────────┘    │\n│                                     │\n│  ┌─────┬───────────────────────┐    │\n│  │     │ Veritasium            │    │\n│  │ IMG │ Science \u0026 engineering │    │\n│  │     │         [Subscribe]   │    │\n│  └─────┴───────────────────────┘    │\n│                                     │\n│  Load more...                       │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n### Component Implementation\n```typescript\nimport { View, Text, FlatList, Pressable, Image, StyleSheet, TextInput } from 'react-native';\nimport { useLocalSearchParams } from 'expo-router';\nimport { useState } from 'react';\nimport { trpc } from '@/lib/trpc';\nimport { useSubscriptions } from '@/hooks/use-subscriptions';\nimport { LoadingState, ErrorState, EmptyState } from '@/components/list-states';\nimport { useColors } from '@/hooks/use-colors';\n\nexport default function DiscoverScreen() {\n  const { provider } = useLocalSearchParams\u003c{ provider: string }\u003e();\n  const providerUpper = provider?.toUpperCase() as 'YOUTUBE' | 'SPOTIFY';\n  const [searchQuery, setSearchQuery] = useState('');\n  const colors = useColors();\n\n  // Fetch user's subscriptions from provider (YouTube subs, Spotify saved shows)\n  const { \n    data: providerContent, \n    isLoading, \n    error,\n    fetchNextPage,\n    hasNextPage,\n  } = trpc.sources.listFromProvider.useInfiniteQuery(\n    { provider: providerUpper, limit: 20 },\n    { getNextPageParam: (lastPage) =\u003e lastPage.nextCursor }\n  );\n\n  // Existing Zine subscriptions (to show \"Subscribed\" state)\n  const { subscriptions, subscribe, isSubscribing } = useSubscriptions();\n  \n  const items = providerContent?.pages.flatMap(p =\u003e p.items) ?? [];\n  const filteredItems = searchQuery\n    ? items.filter(item =\u003e \n        item.name.toLowerCase().includes(searchQuery.toLowerCase())\n      )\n    : items;\n\n  const isSubscribed = (providerChannelId: string) =\u003e\n    subscriptions.some(s =\u003e s.providerChannelId === providerChannelId);\n\n  const handleSubscribe = (item: ProviderChannel) =\u003e {\n    subscribe({\n      provider: providerUpper,\n      providerChannelId: item.id,\n      name: item.name,\n      imageUrl: item.imageUrl,\n    });\n  };\n\n  if (isLoading) return \u003cLoadingState message=\"Loading your content...\" /\u003e;\n  if (error) return \u003cErrorState onRetry={() =\u003e {}} /\u003e;\n  if (items.length === 0) {\n    return (\n      \u003cEmptyState\n        emoji={providerUpper === 'YOUTUBE' ? '📺' : '🎧'}\n        title={`No ${providerUpper === 'YOUTUBE' ? 'subscriptions' : 'saved shows'} found`}\n        message={`Subscribe to content on ${provider} first, then come back to add them here.`}\n      /\u003e\n    );\n  }\n\n  return (\n    \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n      \u003cTextInput\n        style={[styles.searchInput, { backgroundColor: colors.inputBackground }]}\n        placeholder=\"Search...\"\n        value={searchQuery}\n        onChangeText={setSearchQuery}\n        placeholderTextColor={colors.textTertiary}\n      /\u003e\n\n      \u003cFlatList\n        data={filteredItems}\n        keyExtractor={(item) =\u003e item.id}\n        renderItem={({ item }) =\u003e (\n          \u003cChannelRow\n            item={item}\n            isSubscribed={isSubscribed(item.id)}\n            onSubscribe={() =\u003e handleSubscribe(item)}\n            colors={colors}\n          /\u003e\n        )}\n        onEndReached={() =\u003e hasNextPage \u0026\u0026 fetchNextPage()}\n        onEndReachedThreshold={0.5}\n        ListFooterComponent={hasNextPage ? \u003cLoadingState /\u003e : null}\n      /\u003e\n    \u003c/View\u003e\n  );\n}\n\nfunction ChannelRow({ item, isSubscribed, onSubscribe, colors }) {\n  return (\n    \u003cView style={styles.row}\u003e\n      \u003cImage source={{ uri: item.imageUrl }} style={styles.avatar} /\u003e\n      \u003cView style={styles.info}\u003e\n        \u003cText style={[styles.name, { color: colors.text }]}\u003e{item.name}\u003c/Text\u003e\n        \u003cText style={[styles.description, { color: colors.textSecondary }]} numberOfLines={1}\u003e\n          {item.description}\n        \u003c/Text\u003e\n      \u003c/View\u003e\n      \u003cPressable\n        style={[\n          styles.subscribeButton,\n          isSubscribed\n            ? { backgroundColor: colors.successBackground }\n            : { backgroundColor: colors.primary },\n        ]}\n        onPress={onSubscribe}\n        disabled={isSubscribed}\n      \u003e\n        \u003cText style={styles.subscribeText}\u003e\n          {isSubscribed ? 'Subscribed' : 'Subscribe'}\n        \u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### Features\n\n1. **Search/Filter** - Filter displayed list by name\n2. **Infinite Scroll** - Load more content as user scrolls\n3. **Subscribe State** - Show \"Subscribed\" for already-added channels\n4. **Optimistic UI** - Button updates immediately when subscribing\n\n### Data Flow\n```\n1. User opens discover screen\n2. Fetch user's subscriptions from provider API\n3. Also fetch existing Zine subscriptions\n4. Display provider content with subscribe/subscribed state\n5. On subscribe: optimistic update + queue if offline\n```\n\n### Provider-Specific Content\n| Provider | API Endpoint | Content Type |\n|----------|--------------|--------------|\n| YouTube | youtube.readonly | Subscribed channels |\n| Spotify | user-library-read | Saved shows (podcasts) |\n\n## Dependencies\n- Task 5.4 (useSubscriptions with mutations)\n- Task 7.4 (list state components)\n- tRPC sources.listFromProvider endpoint\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Shows content from connected provider\n- [ ] Search/filter works\n- [ ] Infinite scroll pagination\n- [ ] Subscribe button works\n- [ ] Shows \"Subscribed\" state correctly\n- [ ] Handles empty state\n- [ ] Loading/error states\n\n## Reference\n- Frontend Spec Section 4: Discovery Screen","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:29.888765-06:00","updated_at":"2025-12-17T22:47:26.852363-06:00","closed_at":"2025-12-17T22:47:26.852363-06:00","dependencies":[{"issue_id":"zine-nnb.36","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.889085-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.37","title":"10.1 Create Onboarding provider connection flow","description":"# 10.1 Create Onboarding provider connection flow\n\n## File\n`apps/mobile/app/onboarding/connect.tsx`\n\n## Background \u0026 Rationale\nNew users need a smooth onboarding experience that guides them to connect at least one provider. This screen is shown after initial signup and encourages users to connect YouTube and/or Spotify.\n\n## What This Task Creates\n\n### Screen Layout\n```\n┌─────────────────────────────────────┐\n│                                     │\n│            📺 🎧                    │\n│                                     │\n│    Connect Your Accounts            │\n│                                     │\n│  Get new videos and podcast         │\n│  episodes delivered to your inbox.  │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ 🎬 Connect YouTube            │  │\n│  │    Subscribe to channels      │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ 🎧 Connect Spotify            │  │\n│  │    Subscribe to podcasts      │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│                                     │\n│         Skip for now →              │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n### Component Implementation\n```typescript\nimport { View, Text, Pressable, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { useConnections } from '@/hooks/use-connections';\nimport { useColors } from '@/hooks/use-colors';\n\nexport default function OnboardingConnectScreen() {\n  const router = useRouter();\n  const { data: connections } = useConnections();\n  const colors = useColors();\n\n  const hasYoutube = connections?.some(c =\u003e c.provider === 'YOUTUBE' \u0026\u0026 c.status === 'ACTIVE');\n  const hasSpotify = connections?.some(c =\u003e c.provider === 'SPOTIFY' \u0026\u0026 c.status === 'ACTIVE');\n  const hasAnyConnection = hasYoutube || hasSpotify;\n\n  const handleConnectYouTube = () =\u003e {\n    router.push('/subscriptions/connect/youtube');\n  };\n\n  const handleConnectSpotify = () =\u003e {\n    router.push('/subscriptions/connect/spotify');\n  };\n\n  const handleSkip = () =\u003e {\n    router.replace('/(tabs)');\n  };\n\n  const handleContinue = () =\u003e {\n    // After connecting, go to channel selection\n    if (hasYoutube) {\n      router.push('/onboarding/select-channels?provider=youtube');\n    } else if (hasSpotify) {\n      router.push('/onboarding/select-channels?provider=spotify');\n    } else {\n      router.replace('/(tabs)');\n    }\n  };\n\n  return (\n    \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n      \u003cText style={styles.emoji}\u003e📺 🎧\u003c/Text\u003e\n      \n      \u003cText style={[styles.title, { color: colors.text }]}\u003e\n        Connect Your Accounts\n      \u003c/Text\u003e\n      \n      \u003cText style={[styles.description, { color: colors.textSecondary }]}\u003e\n        Get new videos and podcast episodes delivered to your inbox.\n      \u003c/Text\u003e\n\n      \u003cView style={styles.providers}\u003e\n        \u003cProviderButton\n          emoji=\"🎬\"\n          title=\"Connect YouTube\"\n          subtitle={hasYoutube ? 'Connected ✓' : 'Subscribe to channels'}\n          connected={hasYoutube}\n          onPress={handleConnectYouTube}\n          colors={colors}\n        /\u003e\n        \n        \u003cProviderButton\n          emoji=\"🎧\"\n          title=\"Connect Spotify\"\n          subtitle={hasSpotify ? 'Connected ✓' : 'Subscribe to podcasts'}\n          connected={hasSpotify}\n          onPress={handleConnectSpotify}\n          colors={colors}\n        /\u003e\n      \u003c/View\u003e\n\n      \u003cView style={styles.footer}\u003e\n        {hasAnyConnection ? (\n          \u003cPressable\n            style={[styles.continueButton, { backgroundColor: colors.primary }]}\n            onPress={handleContinue}\n          \u003e\n            \u003cText style={[styles.continueText, { color: colors.buttonText }]}\u003e\n              Continue\n            \u003c/Text\u003e\n          \u003c/Pressable\u003e\n        ) : (\n          \u003cPressable onPress={handleSkip}\u003e\n            \u003cText style={[styles.skipText, { color: colors.textSecondary }]}\u003e\n              Skip for now →\n            \u003c/Text\u003e\n          \u003c/Pressable\u003e\n        )}\n      \u003c/View\u003e\n    \u003c/View\u003e\n  );\n}\n\nfunction ProviderButton({ emoji, title, subtitle, connected, onPress, colors }) {\n  return (\n    \u003cPressable\n      style={[\n        styles.providerButton,\n        { backgroundColor: colors.cardBackground },\n        connected \u0026\u0026 { borderColor: colors.success, borderWidth: 2 },\n      ]}\n      onPress={onPress}\n      disabled={connected}\n    \u003e\n      \u003cText style={styles.providerEmoji}\u003e{emoji}\u003c/Text\u003e\n      \u003cView style={styles.providerInfo}\u003e\n        \u003cText style={[styles.providerTitle, { color: colors.text }]}\u003e{title}\u003c/Text\u003e\n        \u003cText style={[styles.providerSubtitle, { color: connected ? colors.success : colors.textSecondary }]}\u003e\n          {subtitle}\n        \u003c/Text\u003e\n      \u003c/View\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Onboarding Flow\n```\n1. User signs up / signs in\n2. Check if any connections exist\n3. If no connections → Show this screen\n4. User connects provider(s)\n5. After connect → Go to channel selection\n6. After selection → Go to main app\n```\n\n### State Transitions\n| State | Display | Primary Action |\n|-------|---------|----------------|\n| No connections | Both buttons active | Connect any |\n| YouTube connected | YouTube shows ✓ | Continue or connect Spotify |\n| Spotify connected | Spotify shows ✓ | Continue or connect YouTube |\n| Both connected | Both show ✓ | Continue |\n\n### Skip Behavior\n- Skip is always available (users can connect later)\n- Skip goes directly to main app\n- Users can connect later from Settings\n\n### Why Separate from Regular Connect Screens?\n- Different context (onboarding vs. settings)\n- Shows both providers on one screen\n- Has skip option\n- Flows to channel selection after\n\n## Dependencies\n- Task 3.1 (useConnections)\n- OAuth connect screens (Tasks 9.2, 9.3)\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Shows both provider options\n- [ ] Updates when connection completes\n- [ ] Continue appears after connection\n- [ ] Skip always available\n- [ ] Correct flow to channel selection\n- [ ] Handles return from OAuth flow\n\n## Reference\n- Frontend Spec Section 5.1: Onboarding Flow","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T21:18:29.949472-06:00","updated_at":"2025-12-17T23:00:43.705388-06:00","closed_at":"2025-12-17T23:00:43.705388-06:00","dependencies":[{"issue_id":"zine-nnb.37","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:29.949792-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.38","title":"10.2 Create Channel selection UI after OAuth","description":"# 10.2 Create Channel selection UI after OAuth\n\n## File\n`apps/mobile/app/onboarding/select-channels.tsx`\n\n## Background \u0026 Rationale\nAfter connecting a provider during onboarding, users should immediately select which channels/shows to subscribe to. This provides a smooth flow and ensures users have content in their inbox right away.\n\n## What This Task Creates\n\n### Screen Layout\n```\n┌─────────────────────────────────────┐\n│              Select Channels        │\n├─────────────────────────────────────┤\n│                                     │\n│  Choose channels to subscribe to.   │\n│  You can always add more later.     │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ [✓] MKBHD                     │  │\n│  │     Tech reviews              │  │\n│  └───────────────────────────────┘  │\n│  ┌───────────────────────────────┐  │\n│  │ [ ] Veritasium                │  │\n│  │     Science videos            │  │\n│  └───────────────────────────────┘  │\n│  ┌───────────────────────────────┐  │\n│  │ [✓] Lex Fridman               │  │\n│  │     Long-form interviews      │  │\n│  └───────────────────────────────┘  │\n│  ┌───────────────────────────────┐  │\n│  │ [ ] 3Blue1Brown               │  │\n│  │     Math visualizations       │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │   Subscribe to 2 channels     │  │\n│  └───────────────────────────────┘  │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n### Component Implementation\n```typescript\nimport { View, Text, FlatList, Pressable, StyleSheet } from 'react-native';\nimport { useLocalSearchParams, useRouter } from 'expo-router';\nimport { useState } from 'react';\nimport { trpc } from '@/lib/trpc';\nimport { useSubscriptions } from '@/hooks/use-subscriptions';\nimport { LoadingState } from '@/components/list-states';\nimport { useColors } from '@/hooks/use-colors';\n\ninterface ProviderChannel {\n  id: string;\n  name: string;\n  description: string;\n  imageUrl: string | null;\n}\n\nexport default function SelectChannelsScreen() {\n  const { provider } = useLocalSearchParams\u003c{ provider: string }\u003e();\n  const providerUpper = provider?.toUpperCase() as 'YOUTUBE' | 'SPOTIFY';\n  const router = useRouter();\n  const colors = useColors();\n\n  const [selected, setSelected] = useState\u003cSet\u003cstring\u003e\u003e(new Set());\n\n  // Fetch channels from provider\n  const { data, isLoading } = trpc.sources.listFromProvider.useQuery({\n    provider: providerUpper,\n    limit: 50,\n  });\n\n  const { subscribe, isSubscribing } = useSubscriptions();\n\n  const toggleSelection = (channelId: string) =\u003e {\n    setSelected(prev =\u003e {\n      const next = new Set(prev);\n      if (next.has(channelId)) {\n        next.delete(channelId);\n      } else {\n        next.add(channelId);\n      }\n      return next;\n    });\n  };\n\n  const handleSubscribe = async () =\u003e {\n    const channels = data?.items.filter(c =\u003e selected.has(c.id)) ?? [];\n    \n    // Subscribe to each selected channel\n    for (const channel of channels) {\n      subscribe({\n        provider: providerUpper,\n        providerChannelId: channel.id,\n        name: channel.name,\n        imageUrl: channel.imageUrl,\n      });\n    }\n\n    // Navigate to main app\n    router.replace('/(tabs)');\n  };\n\n  if (isLoading) {\n    return \u003cLoadingState message=\"Loading your channels...\" /\u003e;\n  }\n\n  const channels = data?.items ?? [];\n  const selectedCount = selected.size;\n\n  return (\n    \u003cView style={[styles.container, { backgroundColor: colors.background }]}\u003e\n      \u003cText style={[styles.title, { color: colors.text }]}\u003e\n        Select {providerUpper === 'YOUTUBE' ? 'Channels' : 'Shows'}\n      \u003c/Text\u003e\n      \n      \u003cText style={[styles.subtitle, { color: colors.textSecondary }]}\u003e\n        Choose what to subscribe to. You can always add more later.\n      \u003c/Text\u003e\n\n      \u003cFlatList\n        data={channels}\n        keyExtractor={(item) =\u003e item.id}\n        renderItem={({ item }) =\u003e (\n          \u003cSelectableRow\n            item={item}\n            isSelected={selected.has(item.id)}\n            onToggle={() =\u003e toggleSelection(item.id)}\n            colors={colors}\n          /\u003e\n        )}\n        style={styles.list}\n      /\u003e\n\n      \u003cPressable\n        style={[\n          styles.subscribeButton,\n          { backgroundColor: selectedCount \u003e 0 ? colors.primary : colors.disabled },\n        ]}\n        onPress={handleSubscribe}\n        disabled={selectedCount === 0 || isSubscribing}\n      \u003e\n        \u003cText style={[styles.subscribeText, { color: colors.buttonText }]}\u003e\n          {selectedCount === 0\n            ? 'Select channels'\n            : `Subscribe to ${selectedCount} ${selectedCount === 1 ? 'channel' : 'channels'}`}\n        \u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n\nfunction SelectableRow({ item, isSelected, onToggle, colors }) {\n  return (\n    \u003cPressable\n      style={[\n        styles.row,\n        { backgroundColor: colors.cardBackground },\n        isSelected \u0026\u0026 { borderColor: colors.primary, borderWidth: 2 },\n      ]}\n      onPress={onToggle}\n    \u003e\n      \u003cView style={[\n        styles.checkbox,\n        { borderColor: isSelected ? colors.primary : colors.border },\n        isSelected \u0026\u0026 { backgroundColor: colors.primary },\n      ]}\u003e\n        {isSelected \u0026\u0026 \u003cText style={styles.checkmark}\u003e✓\u003c/Text\u003e}\n      \u003c/View\u003e\n      \n      \u003cView style={styles.info}\u003e\n        \u003cText style={[styles.name, { color: colors.text }]}\u003e{item.name}\u003c/Text\u003e\n        \u003cText style={[styles.description, { color: colors.textSecondary }]} numberOfLines={1}\u003e\n          {item.description}\n        \u003c/Text\u003e\n      \u003c/View\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Selection UX\n\n1. **Multi-select** - Users can select multiple channels at once\n2. **Visual feedback** - Selected items have highlighted border + checkmark\n3. **Count display** - Button shows \"Subscribe to N channels\"\n4. **Batch subscribe** - All selected channels subscribed at once\n\n### Differences from Discovery Screen\n| Aspect | Discovery | Onboarding Selection |\n|--------|-----------|---------------------|\n| Context | Settings/anytime | First-time setup |\n| Selection | One at a time | Multi-select |\n| Subscribe | Individual buttons | Batch \"Subscribe to N\" |\n| Navigation | Stay on screen | Goes to main app |\n\n### Flow\n```\n1. OAuth completes\n2. Redirect to this screen\n3. User selects channels\n4. Tap \"Subscribe to N channels\"\n5. Batch subscribe (queued if offline)\n6. Navigate to main app (tabs)\n```\n\n### Skip Behavior\n- No explicit skip button (user can go back)\n- Subscribing to 0 channels disabled\n- Can always add more from Settings later\n\n## Dependencies\n- Task 5.4 (useSubscriptions with subscribe mutation)\n- Task 7.4 (LoadingState component)\n- tRPC sources.listFromProvider endpoint\n- Theme colors\n\n## Acceptance Criteria\n- [ ] Shows channels from connected provider\n- [ ] Multi-select with visual feedback\n- [ ] Button shows selected count\n- [ ] Batch subscribe works\n- [ ] Handles empty list\n- [ ] Navigates to main app after\n- [ ] Works offline (queues subscriptions)\n\n## Reference\n- Frontend Spec Section 5.2: Channel Selection","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T21:18:30.008651-06:00","updated_at":"2025-12-17T23:03:47.749025-06:00","closed_at":"2025-12-17T23:03:47.749025-06:00","dependencies":[{"issue_id":"zine-nnb.38","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:30.008963-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.4","title":"1.4 Implement completeOAuthFlow token exchange function","description":"# 1.4 Implement completeOAuthFlow token exchange function\n\n## File\n`apps/mobile/lib/oauth.ts`\n\n## Background \u0026 Rationale\nThis function is called by the OAuthCallbackHandler (Task 4.2) when the app receives a deep link callback from the OAuth provider. It completes the flow by exchanging the authorization code for tokens via the server.\n\n## What This Task Creates\n\n### Function Signature\n```typescript\nexport interface OAuthFlowResult {\n  success: boolean;\n  provider?: 'YOUTUBE' | 'SPOTIFY';\n  error?: string;\n}\n\nexport async function completeOAuthFlow(\n  code: string,\n  state: string,\n  provider: 'YOUTUBE' | 'SPOTIFY'\n): Promise\u003cOAuthFlowResult\u003e\n```\n\n### Flow Steps\n1. **Validate state** - Compare with stored state in SecureStore\n2. **Retrieve PKCE verifier** - Get from SecureStore using provider key\n3. **Extract state UUID** - Split `PROVIDER:uuid` format\n4. **Exchange code for tokens** - tRPC mutation to server\n5. **Cleanup SecureStore** - Remove verifier and state\n6. **Return result** - Success or error with details\n\n### Why Server Handles Token Exchange\n- Server can securely store client_secret (needed for YouTube)\n- Server encrypts and stores tokens in database\n- Server validates state against userId mapping\n- Tokens never touch the mobile device\n\n### Error Scenarios\n- State mismatch → Possible CSRF attack\n- Verifier not found → Flow interrupted or SecureStore cleared\n- Exchange failed → Server or provider error\n\n## Cold Start Handling\nThis function must work even when:\n- App was killed during OAuth flow\n- User took a long time on provider login\n- SecureStore persists across app restarts\n\n## Dependencies\n- Task 1.1 (PKCE utilities)\n- tRPC client for `connections.callback` mutation\n- SecureStore for retrieving stored values\n\n## Acceptance Criteria\n- [ ] Validates state matches stored state\n- [ ] Retrieves verifier from correct SecureStore key\n- [ ] Calls tRPC callback mutation with correct params\n- [ ] Cleans up SecureStore on success\n- [ ] Returns structured result for UI handling\n- [ ] Handles all error cases gracefully\n\n## Reference\n- Frontend Spec Section 1.4: Complete OAuth Flow","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:27.936739-06:00","updated_at":"2025-12-17T22:36:56.821337-06:00","closed_at":"2025-12-17T22:36:56.821337-06:00","dependencies":[{"issue_id":"zine-nnb.4","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:27.937208-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.5","title":"2.1 Create settings stack navigator layout","description":"# 2.1 Create settings stack navigator layout\n\n## File\n`apps/mobile/app/settings/_layout.tsx`\n\n## Background \u0026 Rationale\nSettings screens need their own Stack navigator to provide proper navigation hierarchy with back buttons, titles, and consistent styling. This follows Expo Router's file-based routing conventions.\n\n## What This Task Creates\n\n### Stack Navigator Configuration\n```typescript\nexport default function SettingsLayout() {\n  return (\n    \u003cStack screenOptions={{\n      headerStyle: { backgroundColor: colors.background },\n      headerTintColor: colors.text,\n      headerTitleStyle: { fontWeight: '600' },\n      headerBackTitleVisible: false,\n    }}\u003e\n      \u003cStack.Screen name=\"index\" options={{ title: 'Settings' }} /\u003e\n      \u003cStack.Screen name=\"connections\" options={{ title: 'Connected Accounts' }} /\u003e\n      \u003cStack.Screen name=\"account\" options={{ title: 'Account' }} /\u003e\n      \u003cStack.Screen name=\"about\" options={{ title: 'About' }} /\u003e\n    \u003c/Stack\u003e\n  );\n}\n```\n\n### Screens in Settings Group\n| Screen | Route | Purpose |\n|--------|-------|---------|\n| index | /settings | Main settings menu |\n| connections | /settings/connections | Manage OAuth providers |\n| account | /settings/account | User account settings |\n| about | /settings/about | App info, version, legal |\n\n### Design Decisions\n- **Not a tab**: Settings is accessed via gear icon in Home header, not as a tab\n- **Why?**: Settings is infrequently accessed; saves tab bar space for primary content\n- **Consistent with**: Apple Music, Podcasts, Photos apps\n\n## Theme Integration\nUses `useColorScheme()` hook and `Colors` from theme tokens to support light/dark mode automatically.\n\n## Dependencies\n- Theme tokens from `@/constants/theme`\n- `useColorScheme` hook\n\n## Acceptance Criteria\n- [ ] Stack navigator renders with correct header styling\n- [ ] All screen routes are defined\n- [ ] Back button works correctly\n- [ ] Light/dark mode transitions smoothly\n- [ ] Header styling matches app design system\n\n## Reference\n- Frontend Spec Section 2.1: Settings Layout","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:28.006476-06:00","updated_at":"2025-12-17T22:50:49.998787-06:00","closed_at":"2025-12-17T22:50:49.998787-06:00","dependencies":[{"issue_id":"zine-nnb.5","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.006848-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.6","title":"2.2 Implement Settings main screen with provider status","description":"Created Settings main screen with Connected Accounts (YouTube/Spotify status via useConnections), Subscriptions (count via useSubscriptions), Account (Sign Out), and About (version/terms/privacy) sections. Uses theme tokens and supports light/dark mode.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:28.06762-06:00","updated_at":"2025-12-17T22:50:50.688756-06:00","closed_at":"2025-12-17T22:50:50.688756-06:00","dependencies":[{"issue_id":"zine-nnb.6","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.067967-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.7","title":"2.3 Add settings gear icon to Home screen header","description":"Added settings gear icon to Home screen header. Changes to apps/mobile/app/(tabs)/index.tsx: Added Ionicons import, useRouter hook, settings button with settings-outline icon (24px), hitSlop for 44px touch target, full accessibility labels (accessibilityLabel, accessibilityRole, accessibilityHint), and navigation to /settings on press.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T21:18:28.129247-06:00","updated_at":"2025-12-17T23:00:42.329416-06:00","closed_at":"2025-12-17T23:00:42.329416-06:00","dependencies":[{"issue_id":"zine-nnb.7","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.129587-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.8","title":"2.4 Create Connections management screen","description":"# 2.4 Create Connections management screen\n\n## File\n`apps/mobile/app/settings/connections.tsx`\n\n## Background \u0026 Rationale\nThis screen allows users to manage their OAuth connections to YouTube and Spotify. They can see which accounts are connected, disconnect them, or initiate new connections. It's accessed from the Settings main screen.\n\n## What This Task Creates\n\n### Screen Layout\n```\n┌─────────────────────────────────────┐\n│ ← Connected Accounts                │\n├─────────────────────────────────────┤\n│                                     │\n│  Connect your streaming accounts    │\n│  to subscribe to channels and       │\n│  podcasts.                          │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ 🎬 YouTube                    │  │\n│  │    Not connected              │  │\n│  │              [Connect] button │  │\n│  └───────────────────────────────┘  │\n│                                     │\n│  ┌───────────────────────────────┐  │\n│  │ 🎧 Spotify                    │  │\n│  │    user@email.com             │  │\n│  │    Connected since Dec 2024   │  │\n│  │             [Disconnect] text │  │\n│  └───────────────────────────────┘  │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n### Component Structure\n```typescript\nexport default function ConnectionsScreen() {\n  const { data: connections, isLoading } = useConnections();\n  const disconnectMutation = trpc.subscriptions.connections.disconnect.useMutation();\n\n  const handleConnect = (provider: 'YOUTUBE' | 'SPOTIFY') =\u003e {\n    router.push(`/subscriptions/connect/${provider.toLowerCase()}`);\n  };\n\n  const handleDisconnect = async (connectionId: string) =\u003e {\n    Alert.alert(\n      'Disconnect Account',\n      'This will remove all subscriptions from this provider. Continue?',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        { \n          text: 'Disconnect', \n          style: 'destructive',\n          onPress: () =\u003e disconnectMutation.mutate({ connectionId }),\n        },\n      ]\n    );\n  };\n\n  return (\n    \u003cScrollView style={styles.container}\u003e\n      \u003cText style={styles.description}\u003e\n        Connect your streaming accounts to subscribe to channels and podcasts.\n      \u003c/Text\u003e\n      \n      \u003cProviderCard\n        provider=\"YOUTUBE\"\n        connection={connections?.find(c =\u003e c.provider === 'YOUTUBE')}\n        onConnect={() =\u003e handleConnect('YOUTUBE')}\n        onDisconnect={handleDisconnect}\n      /\u003e\n      \n      \u003cProviderCard\n        provider=\"SPOTIFY\"\n        connection={connections?.find(c =\u003e c.provider === 'SPOTIFY')}\n        onConnect={() =\u003e handleConnect('SPOTIFY')}\n        onDisconnect={handleDisconnect}\n      /\u003e\n    \u003c/ScrollView\u003e\n  );\n}\n```\n\n### ProviderCard Component\n```typescript\nfunction ProviderCard({ provider, connection, onConnect, onDisconnect }) {\n  const isConnected = connection?.status === 'ACTIVE';\n  \n  return (\n    \u003cView style={styles.card}\u003e\n      \u003cView style={styles.cardHeader}\u003e\n        \u003cText style={styles.icon}\u003e{provider === 'YOUTUBE' ? '🎬' : '🎧'}\u003c/Text\u003e\n        \u003cText style={styles.providerName}\u003e{provider}\u003c/Text\u003e\n      \u003c/View\u003e\n      \n      {isConnected ? (\n        \u003c\u003e\n          \u003cText style={styles.connectedEmail}\u003e{connection.providerUserId}\u003c/Text\u003e\n          \u003cText style={styles.connectedSince}\u003e\n            Connected since {formatDate(connection.createdAt)}\n          \u003c/Text\u003e\n          \u003cPressable onPress={() =\u003e onDisconnect(connection.id)}\u003e\n            \u003cText style={styles.disconnectText}\u003eDisconnect\u003c/Text\u003e\n          \u003c/Pressable\u003e\n        \u003c/\u003e\n      ) : (\n        \u003c\u003e\n          \u003cText style={styles.notConnected}\u003eNot connected\u003c/Text\u003e\n          \u003cPressable style={styles.connectButton} onPress={onConnect}\u003e\n            \u003cText style={styles.connectButtonText}\u003eConnect\u003c/Text\u003e\n          \u003c/Pressable\u003e\n        \u003c/\u003e\n      )}\n    \u003c/View\u003e\n  );\n}\n```\n\n### Status States\n| Status | Display | Action Available |\n|--------|---------|------------------|\n| ACTIVE | Email + connected date | Disconnect |\n| EXPIRED | \"Reconnection needed\" (yellow) | Reconnect |\n| REVOKED | \"Access revoked\" (red) | Reconnect |\n| Not connected | \"Not connected\" | Connect |\n\n### Disconnect Confirmation\nAlways confirm before disconnecting because:\n- All subscriptions from that provider will be removed\n- User needs to re-authorize to reconnect\n- Historical items remain but source attribution may break\n\n## Dependencies\n- Task 3.1 (useConnections hook)\n- Task 1.3 (connectProvider function) - for Connect button\n- tRPC disconnect mutation\n\n## Acceptance Criteria\n- [ ] Shows both providers (YouTube, Spotify)\n- [ ] Correct status for each connection\n- [ ] Connect button initiates OAuth flow\n- [ ] Disconnect shows confirmation alert\n- [ ] Disconnect removes connection and subscriptions\n- [ ] Loading state while fetching\n- [ ] Error handling for failed disconnect\n\n## Reference\n- Frontend Spec Section 3.2: Connections Screen","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T21:18:28.192338-06:00","updated_at":"2025-12-17T22:50:51.10634-06:00","closed_at":"2025-12-17T22:50:51.10634-06:00","dependencies":[{"issue_id":"zine-nnb.8","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.19267-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-nnb.9","title":"3.1 Create useConnections hook for provider status","description":"# 3.1 Create useConnections hook for provider status\n\n## File\n`apps/mobile/hooks/use-connections.ts`\n\n## Background \u0026 Rationale\nThis hook provides a simple interface to fetch and access the user's OAuth connection status for each provider. It's used throughout the app to determine if providers are connected, show status indicators, and enable/disable provider-specific features.\n\n## What This Task Creates\n\n### Connection Type\n```typescript\nexport interface Connection {\n  id: string;\n  provider: 'YOUTUBE' | 'SPOTIFY';\n  status: 'ACTIVE' | 'EXPIRED' | 'REVOKED';\n  providerUserId: string | null;\n  createdAt: string;\n  lastSyncAt: string | null;\n}\n```\n\n### Hook Implementation\n```typescript\nexport function useConnections() {\n  return trpc.subscriptions.connections.list.useQuery(undefined, {\n    staleTime: 5 * 60 * 1000,      // 5 minutes - connections rarely change\n    gcTime: 24 * 60 * 60 * 1000,   // 24 hours - keep in cache\n  });\n}\n```\n\n### Usage Pattern\n```typescript\nconst { data: connections, isLoading, error } = useConnections();\nconst youtubeConnection = connections?.find(c =\u003e c.provider === 'YOUTUBE');\nconst isYoutubeConnected = youtubeConnection?.status === 'ACTIVE';\n```\n\n## Cache Strategy\n- **staleTime: 5 minutes** - Connections change infrequently (only when user connects/disconnects)\n- **gcTime: 24 hours** - Keep data cached for app session\n- Invalidated automatically after OAuth flow completion\n\n## Why Not Just Check Backend Every Time?\n- Reduces unnecessary API calls\n- Instant UI updates when navigating\n- Backend state changes rarely (only user-initiated)\n\n## Dependencies\n- tRPC client configured\n- Backend `connections.list` endpoint implemented\n\n## Acceptance Criteria\n- [ ] Returns typed Connection array\n- [ ] Correct cache configuration\n- [ ] Loading state exposed\n- [ ] Error state exposed\n- [ ] Works with React Query devtools\n\n## Reference\n- Frontend Spec Section 3.1.1: useConnections Hook","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-17T21:18:28.260256-06:00","updated_at":"2025-12-17T21:36:28.855053-06:00","closed_at":"2025-12-17T21:36:28.855053-06:00","dependencies":[{"issue_id":"zine-nnb.9","depends_on_id":"zine-nnb","type":"parent-child","created_at":"2025-12-17T21:18:28.260592-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch","title":"Item Detail Page: Display bookmark content (Spotify podcasts, YouTube videos)","description":"# Item Detail Page Feature\n\n## Overview\nBuild the item detail page that displays the full content of a bookmarked item - Spotify podcasts or YouTube videos. This page is accessible from all item cards and list items throughout the app (Inbox, Library, Home).\n\n## Strategic Context \u0026 Motivation\n\n### Why This Feature Matters\nThe Item Detail Page is a **critical missing piece** in the Zine user journey. Currently, users can:\n1. ✅ See items in their Inbox (triage queue)\n2. ✅ Bookmark items to save them for later\n3. ✅ View bookmarked items in the Library\n4. ❌ **Cannot view full item details or take action on individual items**\n\nWithout this page, users must mentally track what they've saved and can't easily:\n- Read full descriptions before deciding to consume content\n- Open items in their native apps (YouTube, Spotify)\n- Mark items as finished/consumed\n- Share content with others\n\n### Product Vision Alignment\nFrom `docs/zine-architecture.md`:\n\u003e \"Zine is a **content capture and curation tool**... Zine does **not** try to consume or play content itself.\"\n\nThis feature embodies that philosophy:\n- We display rich metadata and previews\n- We provide a gateway to native apps (Open button → YouTube/Spotify)\n- We don't try to embed or play content\n\n## Technical Architecture\n\n### Route Structure\n```\napp/\n  item/\n    [id].tsx      # Item detail page - dynamic route by UserItem ID\n```\n\nThe route uses Expo Router's dynamic segments. `id` is the `UserItem.id` (not `Item.id`), which is the user's personal reference to the canonical item.\n\n### Data Model Considerations\n\n#### Why UserItem ID, not Item ID?\nThe `UserItem` represents a user's relationship with content:\n- `UserItem.id` → The user's personal bookmark/inbox entry\n- `UserItem.itemId` → Reference to the canonical `Item`\n- `UserItem.state` → INBOX | BOOKMARKED | ARCHIVED\n- `UserItem.isFinished` → New field for tracking consumption\n\nUsing `UserItem.id` in the route allows:\n1. Direct access to user-specific state (isFinished, bookmarkedAt)\n2. Authorization scoping (users can only access their own UserItems)\n3. Future: per-user notes, tags, or annotations on items\n\n#### New Schema Fields Required\n```sql\n-- Add to user_items table\nisFinished BOOLEAN DEFAULT FALSE,\nfinishedAt TIMESTAMP NULL\n```\n\nThese fields track whether the user has consumed the content, separate from bookmark state.\n\n### API Design\n\n#### Existing Endpoints (No Changes)\n- `items.get({ id })` - Fetch by UserItem ID ✅\n- `items.bookmark({ id })` - Move to BOOKMARKED state ✅\n- `items.archive({ id })` - Move to ARCHIVED state ✅\n\n#### New Endpoints Required\n1. **`items.unbookmark({ id })`**\n   - Moves item from BOOKMARKED → INBOX state\n   - Clears `bookmarkedAt` timestamp\n   - Use case: User changes their mind, wants to re-triage\n\n2. **`items.toggleFinished({ id })`**\n   - Toggles `isFinished` boolean\n   - Sets/clears `finishedAt` timestamp\n   - Use case: Mark podcast as listened, video as watched\n\n### UI/UX Design\n\n#### Screen Layout (Top to Bottom)\n```\n┌─────────────────────────────────────┐\n│ ← Back                              │  ← Native Stack header\n├─────────────────────────────────────┤\n│                                     │\n│     ┌─────────────────────────┐     │\n│     │                         │     │  ← Hero image\n│     │     COVER IMAGE         │     │     - 1:1 for podcasts\n│     │                         │     │     - 16:9 for videos\n│     └─────────────────────────┘     │\n│                                     │\n│  Episode Title Goes Here            │  ← Title\n│  Show/Channel Name                  │  ← Creator (tappable in future)\n│                                     │\n│  ┌─────────────────────────────┐    │\n│  │         Open in App          │    │  ← Primary CTA button\n│  └─────────────────────────────┘    │\n│                                     │\n│   ✓     🔖     📤     +            │  ← Action row (4 icons)\n│  Done  Save  Share  Add            │\n│                                     │\n│  Description                        │\n│  Lorem ipsum dolor sit amet...      │  ← Full description\n│  ...scrollable if long              │\n│                                     │\n└─────────────────────────────────────┘\n```\n\n#### Action Row Semantics\n| Icon | Action | Behavior |\n|------|--------|----------|\n| ✓ Check | Toggle finished | Marks item as consumed/unconsumed |\n| 🔖 Bookmark | Toggle bookmark | Bookmark ↔ Unbookmark |\n| 📤 Share | Native share | Opens system share sheet |\n| + Plus | Add to collection | No-op placeholder for future |\n\n## Component Architecture\n\n### Shared Component Extraction\nBefore building the detail page, we need to extract and unify duplicated components:\n\n1. **Icon Components** (`components/icons/`)\n   - Currently duplicated in inbox.tsx, library.tsx, index.tsx\n   - Extract: BookmarkIcon, ArchiveIcon, CheckIcon, ShareIcon, etc.\n   \n2. **Item Card Variants** (`components/item-card.tsx`)\n   - Compact: Grid/list views (Library)\n   - Full: With action buttons (Inbox)\n   - Large: Featured cards (Home \"Jump Back In\")\n\n3. **Utility Functions** (`lib/format.ts`, `lib/content-utils.ts`)\n   - formatDuration, formatRelativeTime\n   - getContentIcon, getProviderColor\n\nThis extraction reduces code duplication and ensures consistent styling.\n\n## Implementation Phases\n\n### Phase 1: Component Extraction \u0026 Refactoring\nExtract shared components before building new features. This creates a solid foundation and reduces the detail page's complexity.\n\n### Phase 2: Backend Changes\nAdd schema fields and API endpoints. Backend must be ready before frontend can use new features.\n\n### Phase 3: Item Detail Page\nBuild the screen with all UI elements and hook up to existing + new APIs.\n\n### Phase 4: Navigation Integration\nWire up navigation from all entry points (Inbox, Library, Home).\n\n## Dependencies \u0026 Blocking\n- Phase 2 blocks Phase 3 (backend must exist)\n- Phase 1 enables Phase 3 (shared components simplify implementation)\n- Phase 3 blocks Phase 4 (page must exist before navigation)\n\n## Out of Scope (Future Features)\n- Tappable source name → subscription page navigation\n- Playlist/collection feature (+ button is placeholder only)\n- Playback progress tracking\n- In-app media playback\n- Deep linking to native apps (MVP: opens in browser)\n\n## Success Criteria\n- [ ] User can tap any item card to view full details\n- [ ] Cover images display with correct aspect ratio per content type\n- [ ] \"Open\" button successfully opens content in browser\n- [ ] Finished/bookmark toggles update immediately with optimistic UI\n- [ ] Share action opens native share sheet\n- [ ] Loading, error, and empty states handled gracefully\n\n## References\n- GitHub Issue: #1\n- Architecture: docs/zine-architecture.md\n- Tech Stack: docs/zine-tech-stack.md\n- Existing patterns: apps/mobile/app/(tabs)/library.tsx, inbox.tsx","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T22:20:11.932017-06:00","updated_at":"2025-12-25T22:59:54.454178-06:00","closed_at":"2025-12-25T22:59:54.454178-06:00"}
{"id":"zine-qch.1","title":"Phase 1.1: Extract icon components to shared folder","description":"# Phase 1.1: Extract icon components to shared folder\n\n## What This Task Does\nExtract all SVG icon components currently duplicated across inbox.tsx, library.tsx, and index.tsx into a centralized `components/icons/` folder.\n\n## Why This Matters\n- **Code Duplication**: Same icons defined 2-3 times across screens\n- **Consistency**: Centralized icons ensure consistent sizing, colors, and stroke widths\n- **Maintainability**: One place to update icons, propagates everywhere\n- **Item Detail Page Dependency**: The detail page needs these icons for its action row\n\n## Current State Analysis\n\n### Icons in library.tsx (lines 37-79):\n- SearchIcon, HeadphonesIcon, VideoIcon, ArticleIcon, FilterIcon\n\n### Icons in inbox.tsx (lines 27-69):\n- InboxArrowIcon, BookmarkIcon, ArchiveIcon\n\n### Icons in index.tsx (presumed):\n- ChevronRightIcon, potentially others\n\n## Implementation Details\n\n### Folder Structure\n```\napps/mobile/components/icons/\n├── index.tsx              # Barrel export\n├── bookmark-icon.tsx\n├── archive-icon.tsx\n├── check-icon.tsx         # NEW: For \"mark as finished\"\n├── share-icon.tsx         # NEW: For share action\n├── plus-icon.tsx          # NEW: For \"add to collection\"\n├── search-icon.tsx\n├── headphones-icon.tsx\n├── video-icon.tsx\n├── article-icon.tsx\n├── filter-icon.tsx\n├── chevron-right-icon.tsx\n└── inbox-arrow-icon.tsx\n```\n\n### Icon Component Pattern\nEach icon should follow this consistent pattern:\n\n```typescript\n// apps/mobile/components/icons/bookmark-icon.tsx\nimport Svg, { Path } from 'react-native-svg';\n\ninterface IconProps {\n  size?: number;\n  color?: string;\n}\n\nexport function BookmarkIcon({ size = 24, color = '#000' }: IconProps) {\n  return (\n    \u003cSvg width={size} height={size} viewBox=\"0 0 24 24\" fill={color}\u003e\n      \u003cPath d=\"...\" /\u003e\n    \u003c/Svg\u003e\n  );\n}\n```\n\n### Design Decisions\n1. **Default size 24**: Standard touch target friendly size\n2. **Fill vs stroke**: Determined per-icon based on design (filled icons for actions, stroked for navigation)\n3. **No default color**: Let consumers pass theme colors\n4. **Props interface**: Simple {size, color} for consistency\n\n### New Icons Needed for Detail Page\n1. **CheckIcon** - Mark as finished (outline when unfinished, filled when finished)\n2. **ShareIcon** - Native share (iOS share icon style)\n3. **PlusIcon** - Add to collection placeholder\n\n## Acceptance Criteria\n- [ ] All existing icons extracted without visual changes\n- [ ] New icons (Check, Share, Plus) created with consistent style\n- [ ] Barrel export in index.tsx for clean imports\n- [ ] All icons support size and color props\n- [ ] TypeScript types properly defined\n\n## Files to Create/Modify\n- CREATE: apps/mobile/components/icons/*.tsx (all icon files)\n- CREATE: apps/mobile/components/icons/index.tsx (barrel export)\n\n## Testing Notes\nAfter extraction, screens should render identically. Run the app and visually verify:\n1. Library screen icons unchanged\n2. Inbox screen icons unchanged\n3. Home screen icons unchanged","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:12.104751-06:00","updated_at":"2025-12-25T22:44:15.579973-06:00","closed_at":"2025-12-25T22:44:15.579973-06:00","dependencies":[{"issue_id":"zine-qch.1","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:12.105161-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.10","title":"Phase 2.3: Implement items.unbookmark tRPC mutation","description":"# Phase 2.3: Implement items.unbookmark tRPC mutation\n\n## What This Task Does\nAdd a new tRPC mutation to move an item from BOOKMARKED state back to INBOX state.\n\n## Why This Matters\n- **User Flexibility**: Users may change their mind after bookmarking\n- **Reversibility**: Currently bookmark is one-way; this enables undo\n- **Detail Page Feature**: Bookmark toggle needs both directions\n\n## API Design\n\n### Endpoint\n```typescript\nitems.unbookmark({ id: string }) → { success: boolean }\n```\n\n### Behavior\n1. Find UserItem by id where userId = ctx.userId\n2. Verify current state = BOOKMARKED\n3. Update state to INBOX\n4. Clear bookmarkedAt timestamp\n5. Return success\n\n### Error Cases\n| Scenario | Error Code | Message |\n|----------|------------|---------|\n| Item not found | NOT_FOUND | \"Item not found\" |\n| Wrong user | NOT_FOUND | \"Item not found\" (don't leak existence) |\n| Not bookmarked | BAD_REQUEST | \"Item is not bookmarked\" |\n\n## Implementation\n\n### tRPC Procedure\n```typescript\n// apps/worker/src/trpc/routers/items.ts\n\nunbookmark: protectedProcedure\n  .input(z.object({\n    id: z.string(), // UserItem ID\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Find the user item\n    const userItem = await ctx.db.query.userItems.findFirst({\n      where: and(\n        eq(userItems.id, input.id),\n        eq(userItems.userId, ctx.userId),\n      ),\n    });\n    \n    if (!userItem) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Item not found',\n      });\n    }\n    \n    // 2. Verify bookmarked state\n    if (userItem.state !== 'BOOKMARKED') {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: 'Item is not bookmarked',\n      });\n    }\n    \n    // 3. Update to INBOX state\n    await ctx.db\n      .update(userItems)\n      .set({\n        state: 'INBOX',\n        bookmarkedAt: null,\n        updatedAt: new Date().toISOString(),\n      })\n      .where(eq(userItems.id, input.id));\n    \n    return { success: true };\n  }),\n```\n\n### Symmetry with Bookmark\nCompare with existing `bookmark` mutation:\n```typescript\nbookmark: protectedProcedure\n  .input(z.object({ id: z.string() }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // Sets state = BOOKMARKED, bookmarkedAt = now()\n  }),\n```\n\n## Edge Cases\n\n### Item in INBOX State\nIf user somehow calls unbookmark on an INBOX item, return error. This prevents unexpected state transitions.\n\n### Item in ARCHIVED State\nUnbookmark from ARCHIVED doesn't make sense semantically. Return error.\n\n### Race Conditions\nIf two concurrent requests try to unbookmark, the second will fail gracefully (item no longer bookmarked).\n\n## Acceptance Criteria\n- [ ] Mutation moves BOOKMARKED → INBOX\n- [ ] bookmarkedAt cleared to null\n- [ ] updatedAt set to current time\n- [ ] Returns { success: true } on success\n- [ ] Proper error handling for edge cases\n- [ ] Only works for own items (userId check)\n\n## Files to Modify\n- MODIFY: apps/worker/src/trpc/routers/items.ts\n\n## Dependencies\n- None (existing infrastructure)\n\n## Testing Notes\n```typescript\n// Unit test cases:\n1. Happy path: BOOKMARKED → INBOX\n2. Error: item not found\n3. Error: item not bookmarked\n4. Error: item archived\n5. Auth: cannot unbookmark other user's items\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:13.655112-06:00","updated_at":"2025-12-25T22:54:35.291067-06:00","closed_at":"2025-12-25T22:54:35.291067-06:00","dependencies":[{"issue_id":"zine-qch.10","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:13.655443-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.10","depends_on_id":"zine-qch.8","type":"blocks","created_at":"2025-12-25T22:24:18.521677-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.11","title":"Phase 2.4: Implement items.toggleFinished tRPC mutation","description":"# Phase 2.4: Implement items.toggleFinished tRPC mutation\n\n## What This Task Does\nAdd a tRPC mutation to toggle the isFinished state of a user item.\n\n## Why This Matters\n- **Core Feature**: Item Detail Page needs \"Mark as Finished\" action\n- **Consumption Tracking**: Users want to know what they've watched/listened to\n- **Toggle Pattern**: Single action for both marking and unmarking\n\n## API Design\n\n### Endpoint\n```typescript\nitems.toggleFinished({ id: string }) → { \n  success: boolean;\n  isFinished: boolean;  // New state after toggle\n  finishedAt: string | null;\n}\n```\n\n### Behavior\n1. Find UserItem by id where userId = ctx.userId\n2. Toggle isFinished: false → true, true → false\n3. Set finishedAt: null → now(), timestamp → null\n4. Return new state for optimistic update confirmation\n\n## Implementation\n\n### tRPC Procedure\n```typescript\n// apps/worker/src/trpc/routers/items.ts\n\ntoggleFinished: protectedProcedure\n  .input(z.object({\n    id: z.string(), // UserItem ID\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Find the user item\n    const userItem = await ctx.db.query.userItems.findFirst({\n      where: and(\n        eq(userItems.id, input.id),\n        eq(userItems.userId, ctx.userId),\n      ),\n    });\n    \n    if (!userItem) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Item not found',\n      });\n    }\n    \n    // 2. Calculate new state\n    const newIsFinished = !userItem.isFinished;\n    const newFinishedAt = newIsFinished \n      ? new Date().toISOString() \n      : null;\n    \n    // 3. Update\n    await ctx.db\n      .update(userItems)\n      .set({\n        isFinished: newIsFinished,\n        finishedAt: newFinishedAt,\n        updatedAt: new Date().toISOString(),\n      })\n      .where(eq(userItems.id, input.id));\n    \n    return {\n      success: true,\n      isFinished: newIsFinished,\n      finishedAt: newFinishedAt,\n    };\n  }),\n```\n\n## Why Toggle vs Explicit Set?\n\n### Toggle (chosen)\n```typescript\ntoggleFinished({ id })\n```\n- Single action for UI button\n- Matches user mental model (\"tap to toggle\")\n- Reduces API surface\n\n### Explicit (alternative)\n```typescript\nsetFinished({ id, isFinished: boolean })\n```\n- More explicit\n- Enables setting to specific state\n- Better for sync scenarios\n\n**Decision**: Toggle is simpler and matches the UI pattern (single button that changes state).\n\n## Response Shape\n\n### Why Return New State?\nThe response includes `isFinished` and `finishedAt` so the client can:\n1. Confirm optimistic update was correct\n2. Handle race conditions (actual state may differ from assumed)\n3. Update UI if toggle happened from multiple clients\n\n## Edge Cases\n\n### Works in Any State\nUnlike unbookmark, toggleFinished works regardless of item state:\n- INBOX items can be marked finished\n- BOOKMARKED items can be marked finished\n- ARCHIVED items can be marked finished\n\nThis flexibility supports various workflows:\n- \"I listened to this, now archiving\"\n- \"Finished, but keeping bookmarked for reference\"\n\n### Race Conditions\nIf two toggles happen simultaneously:\n- First toggle: false → true\n- Second toggle: true → false\n- Result: back to false\n\nThis is expected behavior. The UI should show accurate state after mutation settles.\n\n## Acceptance Criteria\n- [ ] Toggles isFinished boolean\n- [ ] Sets/clears finishedAt timestamp appropriately\n- [ ] Returns new state in response\n- [ ] Works for INBOX, BOOKMARKED, and ARCHIVED items\n- [ ] Proper error for not found\n- [ ] Only works for own items\n\n## Files to Modify\n- MODIFY: apps/worker/src/trpc/routers/items.ts\n\n## Dependencies\n- Depends on: zine-qch.8, zine-qch.9 (schema must have new columns)\n\n## Testing Notes\n```typescript\n// Test scenarios:\n1. Toggle false → true (sets finishedAt)\n2. Toggle true → false (clears finishedAt)\n3. Toggle on INBOX item (works)\n4. Toggle on BOOKMARKED item (works)\n5. Toggle on ARCHIVED item (works)\n6. Error: item not found\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:13.831133-06:00","updated_at":"2025-12-25T22:54:36.68795-06:00","closed_at":"2025-12-25T22:54:36.68795-06:00","dependencies":[{"issue_id":"zine-qch.11","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:13.831465-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.11","depends_on_id":"zine-qch.8","type":"blocks","created_at":"2025-12-25T22:24:18.684783-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.11","depends_on_id":"zine-qch.9","type":"blocks","created_at":"2025-12-25T22:24:18.851042-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.12","title":"Phase 2.5: Update ItemView type to include isFinished fields","description":"# Phase 2.5: Update ItemView type to include isFinished fields\n\n## What This Task Does\nUpdate the ItemView type definition in shared package and items router to include the new isFinished and finishedAt fields.\n\n## Why This Matters\n- **Type Safety**: Frontend needs typed access to new fields\n- **API Contract**: Clear contract between backend and frontend\n- **Consistency**: Same type used throughout codebase\n\n## Changes Required\n\n### 1. Shared Package Types\n```typescript\n// packages/shared/src/types/domain.ts\n\nexport interface ItemView {\n  // Existing fields...\n  id: string;\n  itemId: string;\n  title: string;\n  summary: string | null;\n  creator: string;\n  // ... etc ...\n  \n  // NEW: Consumption tracking\n  isFinished: boolean;\n  finishedAt: string | null;  // ISO 8601\n}\n```\n\n### 2. Items Router Select\n```typescript\n// apps/worker/src/trpc/routers/items.ts\n\n// Update the select object to include new columns\nconst itemViewSelect = {\n  id: userItems.id,\n  // ... existing fields ...\n  \n  // NEW\n  isFinished: userItems.isFinished,\n  finishedAt: userItems.finishedAt,\n};\n```\n\n### 3. Response Type Validation\nIf using Zod for response validation:\n```typescript\nconst ItemViewSchema = z.object({\n  // ... existing fields ...\n  isFinished: z.boolean(),\n  finishedAt: z.string().nullable(),\n});\n```\n\n## Impact Analysis\n\n### Affected Queries\n- `items.get({ id })` - Single item fetch\n- `items.inbox()` - Inbox list\n- `items.library()` - Library list\n\nAll should now return isFinished and finishedAt.\n\n### Frontend Usage\n```typescript\nconst { data: item } = useItem(id);\n// item.isFinished is now typed as boolean\n// item.finishedAt is now typed as string | null\n```\n\n## Acceptance Criteria\n- [ ] ItemView type includes isFinished: boolean\n- [ ] ItemView type includes finishedAt: string | null\n- [ ] All item queries return new fields\n- [ ] TypeScript compiles without errors\n- [ ] No breaking changes to existing code\n\n## Files to Modify\n- MODIFY: packages/shared/src/types/domain.ts\n- MODIFY: apps/worker/src/trpc/routers/items.ts\n\n## Dependencies\n- Depends on: zine-qch.8 (schema must have new columns)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:14.005656-06:00","updated_at":"2025-12-25T22:54:37.594361-06:00","closed_at":"2025-12-25T22:54:37.594361-06:00","dependencies":[{"issue_id":"zine-qch.12","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:14.005977-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.12","depends_on_id":"zine-qch.8","type":"blocks","created_at":"2025-12-25T22:24:19.020704-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.13","title":"Phase 2.6: Create useUnbookmarkItem hook with optimistic updates","description":"# Phase 2.6: Create useUnbookmarkItem hook with optimistic updates\n\n## What This Task Does\nCreate a React hook that wraps the items.unbookmark tRPC mutation with optimistic updates and proper cache invalidation.\n\n## Why This Matters\n- **UI Responsiveness**: Optimistic updates make the app feel instant\n- **Consistency**: Follows same pattern as useBookmarkItem\n- **Cache Management**: Properly invalidates affected queries\n\n## Implementation\n\n### Hook Structure\n```typescript\n// apps/mobile/hooks/use-items-trpc.ts (add to existing)\n\nexport function useUnbookmarkItem() {\n  const utils = trpc.useUtils();\n  \n  return trpc.items.unbookmark.useMutation({\n    onMutate: async ({ id }) =\u003e {\n      // 1. Cancel outgoing queries\n      await utils.items.library.cancel();\n      await utils.items.inbox.cancel();\n      \n      // 2. Snapshot current data\n      const previousLibrary = utils.items.library.getData();\n      const previousInbox = utils.items.inbox.getData();\n      \n      // 3. Optimistically update library (remove item)\n      utils.items.library.setData(undefined, (old) =\u003e ({\n        ...old,\n        items: old?.items.filter((item) =\u003e item.id !== id) ?? [],\n      }));\n      \n      // 4. Optimistically update inbox (add item back)\n      // Note: We don't have the full item data here, so inbox\n      // will be refreshed on settle\n      \n      return { previousLibrary, previousInbox };\n    },\n    onError: (err, { id }, context) =\u003e {\n      // Rollback on error\n      if (context?.previousLibrary) {\n        utils.items.library.setData(undefined, context.previousLibrary);\n      }\n      if (context?.previousInbox) {\n        utils.items.inbox.setData(undefined, context.previousInbox);\n      }\n    },\n    onSettled: () =\u003e {\n      // Refresh both lists to ensure consistency\n      utils.items.library.invalidate();\n      utils.items.inbox.invalidate();\n    },\n  });\n}\n```\n\n### Usage in Components\n```typescript\nfunction ItemDetailScreen() {\n  const unbookmark = useUnbookmarkItem();\n  \n  const handleUnbookmark = () =\u003e {\n    unbookmark.mutate({ id: item.id });\n  };\n  \n  return (\n    \u003cButton \n      onPress={handleUnbookmark}\n      disabled={unbookmark.isPending}\n    /\u003e\n  );\n}\n```\n\n## Optimistic Update Strategy\n\n### Library Screen\n- Remove item from library list immediately\n- If error, restore it\n\n### Inbox Screen\n- We could add item back, but we don't have full item data in context\n- Instead, invalidate inbox on settle to refresh\n\n### Item Detail Screen\n- Update local item.state to INBOX\n- Update item.bookmarkedAt to null\n\n## Error Handling\n```typescript\nonError: (err) =\u003e {\n  // Could show toast here\n  console.error('Unbookmark failed:', err);\n  // Rollback happens automatically via context\n}\n```\n\n## Acceptance Criteria\n- [ ] Hook wraps items.unbookmark mutation\n- [ ] Optimistic update removes from library\n- [ ] Rollback on error\n- [ ] Cache invalidation on settle\n- [ ] Returns isPending for loading state\n- [ ] Returns mutate function\n\n## Files to Modify\n- MODIFY: apps/mobile/hooks/use-items-trpc.ts\n\n## Dependencies\n- Depends on: zine-qch.10 (backend endpoint must exist)\n- Uses: existing tRPC client setup","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:14.2404-06:00","updated_at":"2025-12-25T22:54:03.225202-06:00","closed_at":"2025-12-25T22:54:03.225202-06:00","dependencies":[{"issue_id":"zine-qch.13","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:14.240731-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.13","depends_on_id":"zine-qch.10","type":"blocks","created_at":"2025-12-25T22:24:19.186495-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.14","title":"Phase 2.7: Create useToggleFinished hook with optimistic updates","description":"# Phase 2.7: Create useToggleFinished hook with optimistic updates\n\n## What This Task Does\nCreate a React hook that wraps the items.toggleFinished tRPC mutation with optimistic updates.\n\n## Why This Matters\n- **UI Responsiveness**: Toggle feedback is instant\n- **State Sync**: Properly updates cached item data\n- **Error Recovery**: Reverts on failure\n\n## Implementation\n\n### Hook Structure\n```typescript\n// apps/mobile/hooks/use-items-trpc.ts (add to existing)\n\nexport function useToggleFinished() {\n  const utils = trpc.useUtils();\n  \n  return trpc.items.toggleFinished.useMutation({\n    onMutate: async ({ id }) =\u003e {\n      // 1. Cancel related queries\n      await utils.items.get.cancel({ id });\n      await utils.items.library.cancel();\n      await utils.items.inbox.cancel();\n      \n      // 2. Snapshot current data\n      const previousItem = utils.items.get.getData({ id });\n      const previousLibrary = utils.items.library.getData();\n      const previousInbox = utils.items.inbox.getData();\n      \n      // 3. Optimistically toggle the item\n      if (previousItem) {\n        const newIsFinished = !previousItem.isFinished;\n        const newFinishedAt = newIsFinished ? new Date().toISOString() : null;\n        \n        utils.items.get.setData({ id }, {\n          ...previousItem,\n          isFinished: newIsFinished,\n          finishedAt: newFinishedAt,\n        });\n      }\n      \n      // 4. Update in list caches too\n      const updateItem = (item: ItemView) =\u003e \n        item.id === id \n          ? { ...item, isFinished: !item.isFinished, finishedAt: !item.isFinished ? new Date().toISOString() : null }\n          : item;\n      \n      if (previousLibrary) {\n        utils.items.library.setData(undefined, {\n          ...previousLibrary,\n          items: previousLibrary.items.map(updateItem),\n        });\n      }\n      \n      if (previousInbox) {\n        utils.items.inbox.setData(undefined, {\n          ...previousInbox,\n          items: previousInbox.items.map(updateItem),\n        });\n      }\n      \n      return { previousItem, previousLibrary, previousInbox };\n    },\n    onError: (err, { id }, context) =\u003e {\n      // Rollback all caches\n      if (context?.previousItem) {\n        utils.items.get.setData({ id }, context.previousItem);\n      }\n      if (context?.previousLibrary) {\n        utils.items.library.setData(undefined, context.previousLibrary);\n      }\n      if (context?.previousInbox) {\n        utils.items.inbox.setData(undefined, context.previousInbox);\n      }\n    },\n    onSettled: (data, error, { id }) =\u003e {\n      // Refresh to ensure consistency\n      utils.items.get.invalidate({ id });\n      // Only invalidate lists if they contain the item\n      utils.items.library.invalidate();\n      utils.items.inbox.invalidate();\n    },\n  });\n}\n```\n\n### Usage\n```typescript\nconst toggleFinished = useToggleFinished();\n\n\u003cActionButton\n  icon={item.isFinished ? \u003cCheckFilled /\u003e : \u003cCheckOutline /\u003e}\n  label={item.isFinished ? \"Done\" : \"Mark done\"}\n  onPress={() =\u003e toggleFinished.mutate({ id: item.id })}\n  isLoading={toggleFinished.isPending}\n/\u003e\n```\n\n## Why Optimistic Updates Are Tricky Here\n\n### The Challenge\nToggle state needs to be updated in:\n1. Single item cache (`items.get`)\n2. Library list cache (`items.library`)\n3. Inbox list cache (`items.inbox`)\n\n### The Solution\nUpdate all caches optimistically, rollback all on error.\n\n## Acceptance Criteria\n- [ ] Hook wraps items.toggleFinished mutation\n- [ ] Optimistic update toggles isFinished\n- [ ] Optimistic update sets/clears finishedAt\n- [ ] Updates single item cache\n- [ ] Updates list caches\n- [ ] Rollback on error\n- [ ] Cache invalidation on settle\n\n## Files to Modify\n- MODIFY: apps/mobile/hooks/use-items-trpc.ts\n\n## Dependencies\n- Depends on: zine-qch.11 (backend endpoint must exist)\n- Depends on: zine-qch.12 (ItemView type must include new fields)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:14.477164-06:00","updated_at":"2025-12-25T22:54:04.640552-06:00","closed_at":"2025-12-25T22:54:04.640552-06:00","dependencies":[{"issue_id":"zine-qch.14","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:14.477555-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.14","depends_on_id":"zine-qch.11","type":"blocks","created_at":"2025-12-25T22:24:19.351671-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.15","title":"Phase 3.1: Create item detail route structure","description":"# Phase 3.1: Create item detail route structure\n\n## What This Task Does\nCreate the foundational file and route structure for the Item Detail Page using Expo Router's dynamic segments.\n\n## Why This Matters\n- **Navigation Foundation**: All item cards will navigate to this route\n- **Dynamic Route**: Uses [id] to handle any UserItem ID\n- **Stack Navigation**: Integrates with native stack for proper back navigation\n\n## Route Design\n\n### File Location\n```\napps/mobile/app/item/[id].tsx\n```\n\n### URL Pattern\n```\n/item/:id\n```\nExample: `/item/01HZXYZ123` where the ID is a ULID (UserItem.id)\n\n### Why [id] and Not [itemId]?\nThe route parameter is `id` because:\n1. Matches REST convention (`/item/:id`)\n2. The ID is the UserItem.id (user's reference to content)\n3. Simpler than `/item/[userItemId]`\n\n## Implementation\n\n### Basic Screen Structure\n```typescript\n// apps/mobile/app/item/[id].tsx\nimport { useLocalSearchParams, Stack } from 'expo-router';\nimport { View, Text, ScrollView, StyleSheet } from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useColorScheme } from '@/hooks/use-color-scheme';\nimport { Colors } from '@/constants/theme';\n\nexport default function ItemDetailScreen() {\n  // 1. Get route params\n  const { id } = useLocalSearchParams\u003c{ id: string }\u003e();\n  \n  // 2. Theme\n  const colorScheme = useColorScheme();\n  const colors = Colors[colorScheme ?? 'light'];\n  \n  // 3. Fetch item data (will be added in later phases)\n  // const { data: item, isLoading, error } = useItem(id);\n  \n  return (\n    \u003c\u003e\n      {/* Native Stack Header */}\n      \u003cStack.Screen\n        options={{\n          title: '', // Will be set dynamically after data loads\n          headerBackTitle: 'Back',\n          headerStyle: { backgroundColor: colors.background },\n          headerTintColor: colors.text,\n        }}\n      /\u003e\n      \n      \u003cSafeAreaView \n        style={[styles.container, { backgroundColor: colors.background }]}\n        edges={['bottom']} // Top handled by Stack header\n      \u003e\n        \u003cScrollView \n          style={styles.scrollView}\n          contentContainerStyle={styles.content}\n        \u003e\n          {/* Content sections will be added in phases 3.2-3.6 */}\n          \u003cText style={{ color: colors.text }}\u003eItem ID: {id}\u003c/Text\u003e\n        \u003c/ScrollView\u003e\n      \u003c/SafeAreaView\u003e\n    \u003c/\u003e\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  content: {\n    paddingBottom: 40, // Bottom padding for scroll\n  },\n});\n```\n\n### Stack Navigation Integration\n\nThe Item Detail screen is a Stack screen that pushes on top of tabs. It needs proper configuration for:\n\n1. **Back Button**: Native iOS/Android back gesture\n2. **Header Title**: Empty initially, set after data loads\n3. **Header Styling**: Match app theme\n\n### Directory Structure\n```\napps/mobile/app/\n├── (tabs)/\n│   ├── _layout.tsx\n│   ├── index.tsx      (Home)\n│   ├── inbox.tsx\n│   └── library.tsx\n├── item/\n│   └── [id].tsx       (NEW)\n└── _layout.tsx        (Root - Stack navigator)\n```\n\n### Root Layout Consideration\nThe root `_layout.tsx` should already have a Stack navigator that includes the tabs as a screen. The new `item/[id]` will be another Stack screen:\n\n```typescript\n// apps/mobile/app/_layout.tsx (verification)\n\u003cStack\u003e\n  \u003cStack.Screen name=\"(tabs)\" options={{ headerShown: false }} /\u003e\n  \u003cStack.Screen name=\"item/[id]\" options={{ headerShown: true }} /\u003e\n  {/* ... other screens ... */}\n\u003c/Stack\u003e\n```\n\n## Acceptance Criteria\n- [ ] Route file created at app/item/[id].tsx\n- [ ] Route accessible via `/item/:id`\n- [ ] Stack navigation with back button works\n- [ ] Header styling matches app theme\n- [ ] Safe area handling correct (bottom only, Stack handles top)\n- [ ] ScrollView ready for content\n\n## Files to Create\n- CREATE: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- None (foundational screen)\n\n## Testing Notes\n1. Navigate to `/item/test-id` manually (or via expo-router link)\n2. Verify back button returns to previous screen\n3. Verify header styling in light and dark mode\n4. Verify safe area insets on notched devices","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:14.675891-06:00","updated_at":"2025-12-25T22:36:01.049147-06:00","closed_at":"2025-12-25T22:36:01.049147-06:00","dependencies":[{"issue_id":"zine-qch.15","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:14.676212-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.15","depends_on_id":"zine-qch.1","type":"blocks","created_at":"2025-12-25T22:24:19.518327-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.16","title":"Phase 3.2: Implement cover image with adaptive aspect ratio","description":"# Phase 3.2: Implement cover image with adaptive aspect ratio\n\n## What This Task Does\nDisplay the item's cover image with aspect ratio that adapts based on content type (1:1 for podcasts, 16:9 for videos).\n\n## Why This Matters\n- **Visual Correctness**: Podcast album art is square, video thumbnails are widescreen\n- **Professional Polish**: Matching native app conventions\n- **User Recognition**: Familiar visual patterns for each content type\n\n## Implementation\n\n### Cover Image Component\n```typescript\nimport { Image } from 'expo-image';\nimport { getContentAspectRatio } from '@/lib/content-utils';\n\ninterface CoverImageProps {\n  thumbnailUrl: string | null;\n  contentType: ContentType;\n}\n\nfunction CoverImage({ thumbnailUrl, contentType }: CoverImageProps) {\n  const colors = useColors();\n  const aspectRatio = getContentAspectRatio(contentType);\n  \n  return (\n    \u003cView style={[styles.coverContainer, { aspectRatio }]}\u003e\n      {thumbnailUrl ? (\n        \u003cImage\n          source={{ uri: thumbnailUrl }}\n          style={styles.coverImage}\n          contentFit=\"cover\"\n          transition={200}\n          placeholder={blurhash}\n        /\u003e\n      ) : (\n        \u003cView style={[styles.placeholder, { backgroundColor: colors.backgroundTertiary }]}\u003e\n          {getContentIcon(contentType, 48, colors.textTertiary)}\n        \u003c/View\u003e\n      )}\n    \u003c/View\u003e\n  );\n}\n```\n\n### Aspect Ratio Logic\n```typescript\n// From content-utils.ts\ngetContentAspectRatio('PODCAST')  // 1 (1:1 square)\ngetContentAspectRatio('VIDEO')    // 1.777 (16:9)\ngetContentAspectRatio('ARTICLE')  // 1.6 (16:10)\n```\n\n### Placeholder Design\nWhen thumbnailUrl is null:\n- Gray background\n- Content type icon centered\n- Same aspect ratio as if image existed\n\n### Styles\n```typescript\nconst styles = StyleSheet.create({\n  coverContainer: {\n    width: '100%',\n    borderRadius: Radius.lg,\n    overflow: 'hidden',\n    marginBottom: Spacing.lg,\n  },\n  coverImage: {\n    width: '100%',\n    height: '100%',\n  },\n  placeholder: {\n    width: '100%',\n    height: '100%',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});\n```\n\n### expo-image Benefits\n- **Blur hash**: Smooth loading placeholder\n- **Transition**: Fade-in animation\n- **Caching**: Automatic disk caching\n- **Performance**: Native implementation\n\n## Acceptance Criteria\n- [ ] Podcasts display 1:1 square images\n- [ ] Videos display 16:9 widescreen images\n- [ ] Placeholder shown when no image\n- [ ] Smooth loading transition\n- [ ] Image fills container with cover fit\n\n## Files to Modify\n- MODIFY: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- Depends on: zine-qch.3 (getContentAspectRatio function)\n- Depends on: zine-qch.15 (route structure exists)\n- Uses: expo-image (already installed)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:14.848748-06:00","updated_at":"2025-12-25T22:36:01.931189-06:00","closed_at":"2025-12-25T22:36:01.931189-06:00","dependencies":[{"issue_id":"zine-qch.16","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:14.849101-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.16","depends_on_id":"zine-qch.3","type":"blocks","created_at":"2025-12-25T22:24:19.685654-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.16","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:19.849761-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.17","title":"Phase 3.3: Implement title and source display","description":"# Phase 3.3: Implement title and source display\n\n## What This Task Does\nDisplay the item title and source (creator/channel name) below the cover image.\n\n## Why This Matters\n- **Identification**: Users need to know what they're looking at\n- **Context**: Source attribution helps with decision making\n- **Future: Tappable source** → Navigate to subscription page (out of scope for MVP)\n\n## Implementation\n\n### Title \u0026 Source Section\n```typescript\nfunction TitleSection({ item }: { item: ItemView }) {\n  const colors = useColors();\n  \n  return (\n    \u003cView style={styles.titleSection}\u003e\n      \u003cText \n        style={[styles.title, { color: colors.text }]}\n        numberOfLines={3}\n      \u003e\n        {item.title}\n      \u003c/Text\u003e\n      \u003cText \n        style={[styles.source, { color: colors.textSecondary }]}\n        numberOfLines={1}\n      \u003e\n        {item.creator}\n      \u003c/Text\u003e\n    \u003c/View\u003e\n  );\n}\n\nconst styles = StyleSheet.create({\n  titleSection: {\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  title: {\n    ...Typography.headlineMedium,\n    marginBottom: Spacing.xs,\n  },\n  source: {\n    ...Typography.bodyLarge,\n  },\n});\n```\n\n### Typography Choices\n- **Title**: headlineMedium - Large, bold, attention-grabbing\n- **Source**: bodyLarge - Readable but secondary\n\n### Text Truncation\n- **Title**: 3 lines max - Long titles are common\n- **Source**: 1 line - Creator names are typically short\n\n## Dynamic Header Title\nUpdate the Stack header title after data loads:\n\n```typescript\nexport default function ItemDetailScreen() {\n  const { id } = useLocalSearchParams\u003c{ id: string }\u003e();\n  const { data: item } = useItem(id);\n  \n  return (\n    \u003c\u003e\n      \u003cStack.Screen\n        options={{\n          title: item?.title ?? '',  // Dynamic title\n          headerBackTitle: 'Back',\n        }}\n      /\u003e\n      {/* ... */}\n    \u003c/\u003e\n  );\n}\n```\n\nNote: Some apps leave header title empty and show full title in body. Either approach works.\n\n## Acceptance Criteria\n- [ ] Title displays prominently below image\n- [ ] Source displays below title\n- [ ] Long titles truncate appropriately\n- [ ] Typography matches design system\n- [ ] Proper spacing and padding\n\n## Files to Modify\n- MODIFY: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- Depends on: zine-qch.15 (route structure exists)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:15.022585-06:00","updated_at":"2025-12-25T22:36:03.057895-06:00","closed_at":"2025-12-25T22:36:03.057895-06:00","dependencies":[{"issue_id":"zine-qch.17","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:15.022914-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.17","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:20.014237-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.18","title":"Phase 3.4: Implement Open Link button with Linking.openURL","description":"# Phase 3.4: Implement Open Link button with Linking.openURL\n\n## What This Task Does\nAdd the primary \"Open\" button that launches the content in the native browser or appropriate app.\n\n## Why This Matters\n- **Primary Action**: This is why users visit the detail page\n- **Gateway to Consumption**: Zine doesn't play content, it links to it\n- **Universal Links**: May open in YouTube/Spotify app if installed\n\n## Implementation\n\n### Open Button Component\n```typescript\nimport { Linking, Pressable, Text, StyleSheet } from 'react-native';\n\ninterface OpenButtonProps {\n  canonicalUrl: string;\n  provider: Provider;\n}\n\nfunction OpenButton({ canonicalUrl, provider }: OpenButtonProps) {\n  const colors = useColors();\n  \n  const handleOpen = async () =\u003e {\n    try {\n      const supported = await Linking.canOpenURL(canonicalUrl);\n      if (supported) {\n        await Linking.openURL(canonicalUrl);\n      } else {\n        console.error('Cannot open URL:', canonicalUrl);\n        // Could show error toast\n      }\n    } catch (error) {\n      console.error('Failed to open URL:', error);\n    }\n  };\n  \n  const buttonLabel = getOpenButtonLabel(provider);\n  \n  return (\n    \u003cPressable\n      onPress={handleOpen}\n      style={({ pressed }) =\u003e [\n        styles.openButton,\n        { backgroundColor: colors.primary },\n        pressed \u0026\u0026 { opacity: 0.9 },\n      ]}\n      accessibilityLabel={buttonLabel}\n      accessibilityRole=\"button\"\n    \u003e\n      \u003cText style={styles.openButtonText}\u003e{buttonLabel}\u003c/Text\u003e\n    \u003c/Pressable\u003e\n  );\n}\n\nfunction getOpenButtonLabel(provider: Provider): string {\n  switch (provider) {\n    case 'YOUTUBE':\n      return 'Watch on YouTube';\n    case 'SPOTIFY':\n      return 'Listen on Spotify';\n    default:\n      return 'Open';\n  }\n}\n```\n\n### Button Styling\n```typescript\nconst styles = StyleSheet.create({\n  openButton: {\n    marginHorizontal: Spacing.xl,\n    paddingVertical: Spacing.md,\n    borderRadius: Radius.lg,\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  openButtonText: {\n    ...Typography.labelLarge,\n    color: '#fff',\n    fontWeight: '600',\n  },\n});\n```\n\n### Universal Links Behavior\nWhen `Linking.openURL()` is called:\n- **YouTube URLs**: Opens in YouTube app if installed, otherwise browser\n- **Spotify URLs**: Opens in Spotify app if installed, otherwise browser\n- **Other URLs**: Opens in default browser\n\nThis is handled by iOS/Android automatically based on Universal Links configuration.\n\n## Why Not Deep Link Explicitly?\nIssue spec says: \"MVP: Opens in browser/default handler (no deep linking to native apps)\"\n\nHowever, `Linking.openURL()` with the canonical URL will trigger Universal Links automatically if:\n1. User has the app installed\n2. App has registered to handle the domain\n\nThis is the correct behavior - we're not explicitly deep linking, but the OS handles it.\n\n## Error Handling\n```typescript\nconst handleOpen = async () =\u003e {\n  try {\n    await Linking.openURL(canonicalUrl);\n  } catch (error) {\n    // Handle various error scenarios\n    if (error.message.includes('unsupported URL')) {\n      Alert.alert('Cannot Open', 'This link cannot be opened on your device.');\n    } else {\n      Alert.alert('Error', 'Failed to open the link. Please try again.');\n    }\n  }\n};\n```\n\n## Acceptance Criteria\n- [ ] Button displays with provider-specific label\n- [ ] Tapping opens URL in browser/native app\n- [ ] Error handling for invalid URLs\n- [ ] Visual feedback on press\n- [ ] Accessibility label set\n\n## Files to Modify\n- MODIFY: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- Depends on: zine-qch.15 (route structure exists)\n- Uses: react-native Linking API (built-in)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:15.191741-06:00","updated_at":"2025-12-25T22:36:04.046088-06:00","closed_at":"2025-12-25T22:36:04.046088-06:00","dependencies":[{"issue_id":"zine-qch.18","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:15.192048-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.18","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:20.18226-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.19","title":"Phase 3.5: Implement action row (finished, bookmark, share, add)","description":"# Phase 3.5: Implement action row (finished, bookmark, share, add)\n\n## What This Task Does\nBuild the horizontal action row with four icon buttons: Mark as Finished, Bookmark/Unbookmark, Share, and Add to Collection.\n\n## Why This Matters\n- **Primary Interactions**: These are the main actions users take on items\n- **Quick Access**: Icon buttons provide fast, single-tap actions\n- **State Visibility**: Icons change appearance based on current state\n\n## UI Design\n\n### Action Row Layout\n```\n┌────────────────────────────────────────────────────┐\n│                                                    │\n│    ✓         🔖         📤         +              │\n│   Done      Save      Share      Add              │\n│                                                    │\n└────────────────────────────────────────────────────┘\n```\n\n### Icon States\n\n#### Mark as Finished (✓)\n| State | Icon | Color | Label |\n|-------|------|-------|-------|\n| Not finished | CheckIcon (outline) | textSecondary | \"Mark done\" |\n| Finished | CheckIcon (filled) | success/green | \"Done\" |\n\n#### Bookmark (🔖)\n| State | Icon | Color | Label |\n|-------|------|-------|-------|\n| Not bookmarked (INBOX) | BookmarkIcon (outline) | textSecondary | \"Save\" |\n| Bookmarked | BookmarkIcon (filled) | primary | \"Saved\" |\n\n#### Share (📤)\n| State | Icon | Color | Label |\n|-------|------|-------|-------|\n| Always | ShareIcon | textSecondary | \"Share\" |\n\n#### Add to Collection (+)\n| State | Icon | Color | Label |\n|-------|------|-------|-------|\n| Always (no-op) | PlusIcon | textSecondary | \"Add\" |\n\n## Implementation\n\n### Action Row Component\n```typescript\ninterface ActionRowProps {\n  item: ItemView;\n  onToggleFinished: () =\u003e void;\n  onToggleBookmark: () =\u003e void;\n  isTogglingFinished: boolean;\n  isTogglingBookmark: boolean;\n}\n\nfunction ActionRow({\n  item,\n  onToggleFinished,\n  onToggleBookmark,\n  isTogglingFinished,\n  isTogglingBookmark,\n}: ActionRowProps) {\n  const colors = useColors();\n  \n  const handleShare = async () =\u003e {\n    await Share.share({\n      title: item.title,\n      url: item.canonicalUrl,\n      message: `Check out \"${item.title}\"`,\n    });\n  };\n  \n  const handleAddToCollection = () =\u003e {\n    // No-op for now - placeholder for future feature\n    // Could show a toast: \"Coming soon!\"\n  };\n  \n  return (\n    \u003cView style={styles.actionRow}\u003e\n      {/* Mark as Finished */}\n      \u003cActionButton\n        icon={item.isFinished ? \u003cCheckIconFilled /\u003e : \u003cCheckIconOutline /\u003e}\n        label={item.isFinished ? 'Done' : 'Mark done'}\n        onPress={onToggleFinished}\n        isLoading={isTogglingFinished}\n        isActive={item.isFinished}\n        activeColor={colors.success}\n      /\u003e\n      \n      {/* Bookmark Toggle */}\n      \u003cActionButton\n        icon={item.state === 'BOOKMARKED' ? \u003cBookmarkIconFilled /\u003e : \u003cBookmarkIconOutline /\u003e}\n        label={item.state === 'BOOKMARKED' ? 'Saved' : 'Save'}\n        onPress={onToggleBookmark}\n        isLoading={isTogglingBookmark}\n        isActive={item.state === 'BOOKMARKED'}\n        activeColor={colors.primary}\n      /\u003e\n      \n      {/* Share */}\n      \u003cActionButton\n        icon={\u003cShareIcon /\u003e}\n        label=\"Share\"\n        onPress={handleShare}\n      /\u003e\n      \n      {/* Add to Collection (Placeholder) */}\n      \u003cActionButton\n        icon={\u003cPlusIcon /\u003e}\n        label=\"Add\"\n        onPress={handleAddToCollection}\n        disabled\n      /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### ActionButton Sub-component\n```typescript\ninterface ActionButtonProps {\n  icon: React.ReactNode;\n  label: string;\n  onPress: () =\u003e void;\n  isLoading?: boolean;\n  isActive?: boolean;\n  activeColor?: string;\n  disabled?: boolean;\n}\n\nfunction ActionButton({\n  icon,\n  label,\n  onPress,\n  isLoading,\n  isActive,\n  activeColor,\n  disabled,\n}: ActionButtonProps) {\n  const colors = useColors();\n  \n  return (\n    \u003cPressable\n      onPress={onPress}\n      disabled={disabled || isLoading}\n      style={({ pressed }) =\u003e [\n        styles.actionButton,\n        pressed \u0026\u0026 { opacity: 0.7 },\n        disabled \u0026\u0026 { opacity: 0.5 },\n      ]}\n      accessibilityLabel={label}\n      accessibilityRole=\"button\"\n    \u003e\n      {isLoading ? (\n        \u003cActivityIndicator size=\"small\" color={colors.primary} /\u003e\n      ) : (\n        \u003cView style={[\n          styles.iconContainer,\n          isActive \u0026\u0026 { backgroundColor: activeColor + '20' }, // 20% opacity bg\n        ]}\u003e\n          {React.cloneElement(icon as React.ReactElement, {\n            color: isActive ? activeColor : colors.textSecondary,\n            size: 24,\n          })}\n        \u003c/View\u003e\n      )}\n      \u003cText style={[\n        styles.actionLabel,\n        { color: isActive ? activeColor : colors.textSecondary },\n      ]}\u003e\n        {label}\n      \u003c/Text\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Styles\n```typescript\nconst styles = StyleSheet.create({\n  actionRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n    paddingVertical: Spacing.lg,\n    paddingHorizontal: Spacing.xl,\n    borderTopWidth: 1,\n    borderBottomWidth: 1,\n    borderColor: colors.borderLight,\n  },\n  actionButton: {\n    alignItems: 'center',\n    minWidth: 60,\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginBottom: Spacing.xs,\n  },\n  actionLabel: {\n    ...Typography.labelSmall,\n  },\n});\n```\n\n## Share Implementation Details\n\n### React Native Share API\n```typescript\nimport { Share } from 'react-native';\n\nconst handleShare = async () =\u003e {\n  try {\n    const result = await Share.share({\n      title: item.title,\n      url: item.canonicalUrl,\n      message: `Check out \"${item.title}\"`,\n    });\n    \n    if (result.action === Share.sharedAction) {\n      // Successfully shared\n      // Could track analytics here\n    }\n  } catch (error) {\n    console.error('Share failed:', error);\n    // Could show error toast\n  }\n};\n```\n\n### Platform Differences\n- **iOS**: Shows native share sheet with AirDrop, Messages, etc.\n- **Android**: Shows native share intent chooser\n- Both handle the `url` and `message` appropriately\n\n## Add to Collection (Placeholder)\n\n### Current Behavior\nNo-op - the button exists for future feature parity.\n\n### Options for User Feedback\n1. **Silent no-op**: Button does nothing (confusing)\n2. **Toast**: \"Collections coming soon!\" (informative)\n3. **Disabled styling**: Grayed out with tooltip (explicit)\n\n**Recommendation**: Option 3 - show disabled state to indicate feature is planned but not available.\n\n## Optimistic Updates\n\n### Finished Toggle\n```typescript\nconst toggleFinished = useToggleFinished();\n\nconst handleToggleFinished = () =\u003e {\n  // Optimistic: flip UI immediately\n  // If mutation fails, UI will revert on error\n  toggleFinished.mutate({ id: item.id });\n};\n```\n\n### Bookmark Toggle\n```typescript\nconst bookmark = useBookmarkItem();\nconst unbookmark = useUnbookmarkItem();\n\nconst handleToggleBookmark = () =\u003e {\n  if (item.state === 'BOOKMARKED') {\n    unbookmark.mutate({ id: item.id });\n  } else {\n    bookmark.mutate({ id: item.id });\n  }\n};\n```\n\n## Acceptance Criteria\n- [ ] Four action buttons in horizontal row\n- [ ] Mark as Finished toggles with visual state change\n- [ ] Bookmark toggle works (bookmark/unbookmark)\n- [ ] Share opens native share sheet\n- [ ] Add button is visually disabled (placeholder)\n- [ ] Loading states for mutations\n- [ ] Accessibility labels on all buttons\n- [ ] Proper spacing and styling\n\n## Files to Modify\n- MODIFY: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- Depends on: zine-qch.1 (icons)\n- Depends on: zine-qch.13 (useUnbookmarkItem hook)\n- Depends on: zine-qch.14 (useToggleFinished hook)\n- Uses: existing useBookmarkItem hook\n\n## Testing Notes\n1. Toggle finished state - verify icon/color change\n2. Toggle bookmark state - verify state changes\n3. Share - verify native sheet opens with correct content\n4. Add button - verify disabled state\n5. Loading states during mutations\n6. Error recovery if mutation fails","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:15.393131-06:00","updated_at":"2025-12-25T22:58:59.33469-06:00","closed_at":"2025-12-25T22:58:59.33469-06:00","dependencies":[{"issue_id":"zine-qch.19","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:15.393494-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.19","depends_on_id":"zine-qch.1","type":"blocks","created_at":"2025-12-25T22:24:20.350531-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.19","depends_on_id":"zine-qch.13","type":"blocks","created_at":"2025-12-25T22:24:20.518677-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.19","depends_on_id":"zine-qch.14","type":"blocks","created_at":"2025-12-25T22:24:20.687381-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.19","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:20.859227-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.19","depends_on_id":"zine-vq9","type":"blocks","created_at":"2025-12-25T22:36:24.503372-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.2","title":"Phase 1.2: Create lib/format.ts with formatting utilities","description":"# Phase 1.2: Create lib/format.ts with formatting utilities\n\n## What This Task Does\nExtract time and duration formatting utilities currently duplicated across screens into a single `lib/format.ts` module.\n\n## Why This Matters\n- **Code Duplication**: formatDuration and formatRelativeTime defined multiple times\n- **Consistency**: Ensures \"2 days ago\" vs \"2d ago\" is consistent app-wide\n- **Testing**: Centralized utilities can be unit tested\n- **Item Detail Page Dependency**: Detail page needs both formatters\n\n## Current State Analysis\n\n### formatDuration in use-items-trpc.ts:\n```typescript\nexport function formatDuration(seconds: number | null): string {\n  if (seconds === null || seconds === undefined) return '';\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  if (hours \u003e 0) return `${hours}h ${minutes}m`;\n  return `${minutes}m`;\n}\n```\n\n### formatRelativeTime in library.tsx (lines 266-281):\n```typescript\nfunction formatRelativeTime(dateString: string | null | undefined): string {\n  if (!dateString) return '';\n  const date = new Date(dateString);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  // ... calculations ...\n}\n```\n\n## Implementation Details\n\n### Module Structure\n```typescript\n// apps/mobile/lib/format.ts\n\n/**\n * Format duration in seconds to human-readable string\n * @param seconds - Duration in seconds (from API)\n * @returns Formatted string like \"1h 23m\" or \"45m\"\n * \n * @example\n * formatDuration(3723) // \"1h 2m\"\n * formatDuration(2700) // \"45m\"\n * formatDuration(59)   // \"0m\" (less than a minute)\n * formatDuration(null) // \"\"\n */\nexport function formatDuration(seconds: number | null | undefined): string;\n\n/**\n * Format timestamp to relative time string\n * @param dateString - ISO 8601 date string\n * @returns Relative time like \"2 hours ago\", \"Yesterday\", \"3 days ago\"\n * \n * @example\n * formatRelativeTime('2024-01-15T10:00:00Z') // \"2 days ago\"\n * formatRelativeTime(null) // \"\"\n */\nexport function formatRelativeTime(dateString: string | null | undefined): string;\n\n/**\n * Format absolute date for display\n * @param dateString - ISO 8601 date string\n * @returns Formatted date like \"Jan 15, 2024\"\n */\nexport function formatDate(dateString: string | null | undefined): string;\n```\n\n### Edge Cases to Handle\n1. **null/undefined inputs**: Return empty string\n2. **Invalid dates**: Return empty string (don't crash)\n3. **Future dates**: Handle gracefully (show \"Just now\" or actual date)\n4. **Zero duration**: Return \"0m\" not empty string\n5. **Very long durations**: \"24h 30m\" for day+ content\n\n### Relative Time Thresholds\n```\n\u003c 1 minute:  \"Just now\"\n\u003c 1 hour:    \"X minutes ago\" (plural aware)\n\u003c 24 hours:  \"X hours ago\"\n= 1 day:     \"Yesterday\"\n\u003c 7 days:    \"X days ago\"\n\u003c 30 days:   \"X weeks ago\"\n\u003e= 30 days:  Actual date (Jan 15)\n\u003e= 1 year:   Actual date with year (Jan 15, 2024)\n```\n\n## Acceptance Criteria\n- [ ] formatDuration handles all edge cases\n- [ ] formatRelativeTime handles all edge cases\n- [ ] TypeScript types properly defined\n- [ ] JSDoc comments with examples\n- [ ] Unit tests (if test infrastructure exists)\n\n## Files to Create\n- CREATE: apps/mobile/lib/format.ts\n\n## Dependencies\n- None (pure utility functions)\n\n## Testing Notes\n```typescript\n// Quick manual tests\nformatDuration(null)      // \"\"\nformatDuration(0)         // \"0m\"\nformatDuration(59)        // \"0m\"\nformatDuration(60)        // \"1m\"\nformatDuration(3600)      // \"1h 0m\"\nformatDuration(3661)      // \"1h 1m\"\n\nformatRelativeTime(null)  // \"\"\nformatRelativeTime(new Date().toISOString())  // \"Just now\"\nformatRelativeTime(new Date(Date.now() - 3600000).toISOString())  // \"1 hour ago\"\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:12.277076-06:00","updated_at":"2025-12-25T22:45:10.650709-06:00","closed_at":"2025-12-25T22:45:10.650709-06:00","dependencies":[{"issue_id":"zine-qch.2","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:12.277415-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.20","title":"Phase 3.6: Implement description display with scroll","description":"# Phase 3.6: Implement description display with scroll\n\n## What This Task Does\nDisplay the item's full description/summary in a scrollable area below the action row.\n\n## Why This Matters\n- **Context**: Users want to read about content before consuming\n- **Decision Support**: Description helps decide if content is worth the time\n- **Completeness**: All available metadata should be accessible\n\n## Implementation\n\n### Description Section\n```typescript\nfunction DescriptionSection({ summary }: { summary: string | null }) {\n  const colors = useColors();\n  \n  if (!summary) {\n    return null;  // Don't show section if no description\n  }\n  \n  return (\n    \u003cView style={styles.descriptionSection}\u003e\n      \u003cText style={[styles.sectionLabel, { color: colors.textSecondary }]}\u003e\n        Description\n      \u003c/Text\u003e\n      \u003cText \n        style={[styles.description, { color: colors.text }]}\n        selectable={true}  // Allow text selection for copy\n      \u003e\n        {summary}\n      \u003c/Text\u003e\n    \u003c/View\u003e\n  );\n}\n\nconst styles = StyleSheet.create({\n  descriptionSection: {\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n  },\n  sectionLabel: {\n    ...Typography.labelMedium,\n    marginBottom: Spacing.sm,\n    textTransform: 'uppercase',\n    letterSpacing: 0.5,\n  },\n  description: {\n    ...Typography.bodyMedium,\n    lineHeight: 24,  // Comfortable reading\n  },\n});\n```\n\n### Scroll Behavior\nThe entire screen is wrapped in ScrollView, so:\n- Short descriptions: No scroll needed\n- Long descriptions: Natural scroll extends below\n\n```typescript\n\u003cScrollView \n  style={styles.scrollView}\n  contentContainerStyle={styles.content}\n  showsVerticalScrollIndicator={true}\n\u003e\n  \u003cCoverImage /\u003e\n  \u003cTitleSection /\u003e\n  \u003cOpenButton /\u003e\n  \u003cActionRow /\u003e\n  \u003cDescriptionSection summary={item.summary} /\u003e\n\u003c/ScrollView\u003e\n```\n\n### Text Features\n- **selectable={true}**: Users can select and copy text\n- **lineHeight: 24**: Comfortable reading spacing\n- **No truncation**: Full text always visible via scroll\n\n### Empty State\nIf `summary` is null or empty string:\n- Don't render the section at all\n- Avoids awkward empty \"Description\" label\n\n## Metadata Expansion (Future)\nCould add more metadata below description:\n- Duration\n- Published date\n- Provider\n- Content type\n\nThis is out of scope but easy to add later.\n\n## Acceptance Criteria\n- [ ] Full description displays without truncation\n- [ ] Scrollable when content exceeds viewport\n- [ ] Section hidden when no summary\n- [ ] Text is selectable\n- [ ] Comfortable line height for reading\n\n## Files to Modify\n- MODIFY: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- Depends on: zine-qch.15 (route structure exists)\n\n## Testing Notes\n1. Test with short description (no scroll)\n2. Test with very long description (scrolls)\n3. Test with no description (section hidden)\n4. Test text selection works","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T22:20:15.599881-06:00","updated_at":"2025-12-25T22:36:05.092882-06:00","closed_at":"2025-12-25T22:36:05.092882-06:00","dependencies":[{"issue_id":"zine-qch.20","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:15.600234-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.20","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:21.03158-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.21","title":"Phase 3.7: Handle loading, error, and empty states","description":"# Phase 3.7: Handle loading, error, and empty states\n\n## What This Task Does\nImplement proper states for loading, errors, and items not found on the detail page.\n\n## Why This Matters\n- **User Feedback**: Users need to know what's happening\n- **Error Recovery**: Clear messaging for failures\n- **Edge Cases**: Handle deleted/invalid items gracefully\n\n## Implementation\n\n### Loading State\n```typescript\nfunction LoadingState({ colors }: { colors: Colors }) {\n  return (\n    \u003cView style={styles.centerContainer}\u003e\n      \u003cActivityIndicator size=\"large\" color={colors.primary} /\u003e\n      \u003cText style={[styles.loadingText, { color: colors.textSecondary }]}\u003e\n        Loading...\n      \u003c/Text\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### Error State\n```typescript\nfunction ErrorState({ \n  colors, \n  message, \n  onRetry \n}: { \n  colors: Colors; \n  message: string;\n  onRetry: () =\u003e void;\n}) {\n  return (\n    \u003cView style={styles.centerContainer}\u003e\n      \u003cText style={styles.errorEmoji}\u003e😕\u003c/Text\u003e\n      \u003cText style={[styles.errorTitle, { color: colors.text }]}\u003e\n        Something went wrong\n      \u003c/Text\u003e\n      \u003cText style={[styles.errorMessage, { color: colors.textSecondary }]}\u003e\n        {message}\n      \u003c/Text\u003e\n      \u003cPressable\n        onPress={onRetry}\n        style={[styles.retryButton, { backgroundColor: colors.primary }]}\n      \u003e\n        \u003cText style={styles.retryButtonText}\u003eTry Again\u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### Not Found State\n```typescript\nfunction NotFoundState({ colors }: { colors: Colors }) {\n  const router = useRouter();\n  \n  return (\n    \u003cView style={styles.centerContainer}\u003e\n      \u003cText style={styles.notFoundEmoji}\u003e🔍\u003c/Text\u003e\n      \u003cText style={[styles.notFoundTitle, { color: colors.text }]}\u003e\n        Item not found\n      \u003c/Text\u003e\n      \u003cText style={[styles.notFoundMessage, { color: colors.textSecondary }]}\u003e\n        This item may have been deleted or moved.\n      \u003c/Text\u003e\n      \u003cPressable\n        onPress={() =\u003e router.back()}\n        style={[styles.backButton, { borderColor: colors.border }]}\n      \u003e\n        \u003cText style={[styles.backButtonText, { color: colors.text }]}\u003e\n          Go Back\n        \u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### Main Screen Integration\n```typescript\nexport default function ItemDetailScreen() {\n  const { id } = useLocalSearchParams\u003c{ id: string }\u003e();\n  const { data: item, isLoading, error, refetch } = useItem(id);\n  const colors = useColors();\n  \n  // Loading state\n  if (isLoading) {\n    return \u003cLoadingState colors={colors} /\u003e;\n  }\n  \n  // Error state\n  if (error) {\n    return (\n      \u003cErrorState \n        colors={colors} \n        message={error.message}\n        onRetry={refetch}\n      /\u003e\n    );\n  }\n  \n  // Not found state\n  if (!item) {\n    return \u003cNotFoundState colors={colors} /\u003e;\n  }\n  \n  // Main content\n  return (\n    \u003c\u003e\n      \u003cStack.Screen options={{ title: item.title ?? '' }} /\u003e\n      \u003cScrollView\u003e\n        {/* ... content ... */}\n      \u003c/ScrollView\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n## Error Scenarios\n\n### Network Error\n- Message: \"Please check your connection\"\n- Action: Retry button\n\n### 404 Not Found\n- Message: \"This item may have been deleted\"\n- Action: Go back button\n\n### 500 Server Error\n- Message: \"Something went wrong on our end\"\n- Action: Retry button\n\n### Unknown Error\n- Message: \"An unexpected error occurred\"\n- Action: Retry button\n\n## Acceptance Criteria\n- [ ] Loading spinner while fetching\n- [ ] Error state with retry button\n- [ ] Not found state with back button\n- [ ] Smooth transitions between states\n- [ ] Appropriate messaging for each scenario\n\n## Files to Modify\n- MODIFY: apps/mobile/app/item/[id].tsx\n\n## Dependencies\n- Depends on: zine-qch.15 (route structure exists)\n\n## Testing Notes\n1. Disconnect network and open item → Error state\n2. Navigate to invalid ID → Not found state\n3. Slow network → Loading state visible\n4. Retry button works on error state","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:15.80823-06:00","updated_at":"2025-12-25T22:36:06.024835-06:00","closed_at":"2025-12-25T22:36:06.024835-06:00","dependencies":[{"issue_id":"zine-qch.21","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:15.808559-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.21","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:21.200504-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.22","title":"Phase 4.1: Add navigation from Library screen cards","description":"# Phase 4.1: Add navigation from Library screen cards\n\n## What This Task Does\nEnable tapping Library cards to navigate to the Item Detail page.\n\n## Why This Matters\n- **User Journey**: Library → Item Detail is primary flow\n- **Feature Completion**: Cards should be interactive\n- **Consistency**: Same navigation pattern across all screens\n\n## Implementation\n\n### If Using Shared ItemCard\nItemCard already handles navigation via `useRouter`:\n\n```typescript\n// ItemCard component handles this internally\nfunction ItemCard({ item, ...props }) {\n  const router = useRouter();\n  \n  const handlePress = () =\u003e {\n    router.push(`/item/${item.id}`);\n  };\n  \n  return (\n    \u003cPressable onPress={handlePress}\u003e\n      {/* ... */}\n    \u003c/Pressable\u003e\n  );\n}\n```\n\nIf Library is already using shared ItemCard (from zine-qch.5), this task may just require verification.\n\n### If Still Using Inline LibraryCard\nAdd navigation to the card press handler:\n\n```typescript\nimport { useRouter } from 'expo-router';\n\nfunction LibraryCard({ item, colors, index }) {\n  const router = useRouter();\n  \n  const handlePress = () =\u003e {\n    router.push(`/item/${item.id}`);\n  };\n  \n  return (\n    \u003cPressable onPress={handlePress}\u003e\n      {/* ... existing card content ... */}\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n## UserItem ID vs Item ID\nMake sure we're passing the correct ID:\n- **Correct**: `item.id` (UserItem ID from the list)\n- **Incorrect**: `item.itemId` (canonical Item ID)\n\nThe route expects UserItem ID because that's what the backend `items.get({ id })` query uses.\n\n## Visual Feedback\nEnsure cards provide feedback on press:\n```typescript\n\u003cPressable\n  onPress={handlePress}\n  style={({ pressed }) =\u003e [\n    styles.card,\n    pressed \u0026\u0026 { opacity: 0.9 },\n  ]}\n\u003e\n```\n\n## Acceptance Criteria\n- [ ] Tapping any Library card navigates to detail page\n- [ ] Correct item ID passed in route\n- [ ] Visual feedback on press\n- [ ] Back button returns to Library\n- [ ] Works for all content types\n\n## Files to Modify\n- MODIFY: apps/mobile/app/(tabs)/library.tsx\n- POSSIBLY: apps/mobile/components/item-card.tsx (if ItemCard needs changes)\n\n## Dependencies\n- Depends on: zine-qch.4 (ItemCard component)\n- Depends on: zine-qch.15 (route must exist)\n\n## Testing Notes\n1. Tap a Library card\n2. Verify correct item displays\n3. Tap back button\n4. Verify return to Library at same scroll position","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:16.043622-06:00","updated_at":"2025-12-25T22:36:11.287096-06:00","closed_at":"2025-12-25T22:36:11.287096-06:00","dependencies":[{"issue_id":"zine-qch.22","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:16.043977-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.22","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:24:21.369327-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.22","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:21.53873-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.23","title":"Phase 4.2: Add navigation from Inbox screen items","description":"# Phase 4.2: Add navigation from Inbox screen items\n\n## What This Task Does\nEnable tapping Inbox items to navigate to the Item Detail page.\n\n## Why This Matters\n- **Decision Making**: View full details before bookmark/archive\n- **User Journey**: Inbox → Detail → (decide) → back\n- **Full Information**: Users may want description before deciding\n\n## Implementation\n\n### Card Press Handler\nThe Inbox card needs special handling because it also has action buttons:\n\n```typescript\nfunction InboxItemCard({ item, onBookmark, onArchive, ... }) {\n  const router = useRouter();\n  \n  const handleCardPress = () =\u003e {\n    // Navigate to detail page\n    router.push(`/item/${item.id}`);\n  };\n  \n  return (\n    \u003cPressable onPress={handleCardPress}\u003e\n      \u003cView style={styles.thumbnailContainer}\u003e\n        {/* ... */}\n      \u003c/View\u003e\n      \u003cView style={styles.cardContent}\u003e\n        {/* ... */}\n      \u003c/View\u003e\n      \n      {/* Action buttons - these have their own onPress handlers */}\n      \u003cView style={styles.cardActions}\u003e\n        \u003cPressable \n          onPress={(e) =\u003e {\n            e.stopPropagation?.(); // Prevent card press\n            onArchive();\n          }}\n        \u003e\n          \u003cArchiveIcon /\u003e\n        \u003c/Pressable\u003e\n        \u003cPressable \n          onPress={(e) =\u003e {\n            e.stopPropagation?.();\n            onBookmark();\n          }}\n        \u003e\n          \u003cBookmarkIcon /\u003e\n        \u003c/Pressable\u003e\n      \u003c/View\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### If Using Shared ItemCard\nItemCard handles this, but need to ensure action buttons don't trigger card navigation.\n\n### Event Propagation\nAction buttons should stop event propagation so tapping Archive doesn't also navigate:\n\n```typescript\n\u003cPressable\n  onPress={(e) =\u003e {\n    // In React Native, stopPropagation works differently\n    // The Pressable component hierarchy handles this\n    onArchive();\n  }}\n  hitSlop={8}  // Make action buttons easier to tap\n\u003e\n```\n\nActually, in React Native with nested Pressables, the inner Pressable's onPress naturally takes precedence. No explicit stopPropagation needed.\n\n## Acceptance Criteria\n- [ ] Tapping card content navigates to detail\n- [ ] Tapping Archive button archives (no navigation)\n- [ ] Tapping Bookmark button bookmarks (no navigation)\n- [ ] Back button returns to Inbox\n- [ ] Visual feedback on card press\n\n## Files to Modify\n- MODIFY: apps/mobile/app/(tabs)/inbox.tsx\n- POSSIBLY: apps/mobile/components/item-card.tsx\n\n## Dependencies\n- Depends on: zine-qch.4 (ItemCard component)\n- Depends on: zine-qch.15 (route must exist)\n\n## Testing Notes\n1. Tap Inbox card (not on buttons) → navigates\n2. Tap Archive button → archives, no navigation\n3. Tap Bookmark button → bookmarks, no navigation\n4. Back button returns to Inbox","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:16.274232-06:00","updated_at":"2025-12-25T22:36:11.455952-06:00","closed_at":"2025-12-25T22:36:11.455952-06:00","dependencies":[{"issue_id":"zine-qch.23","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:16.27484-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.23","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:24:21.709753-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.23","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:21.893717-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.24","title":"Phase 4.3: Add navigation from Home screen cards","description":"# Phase 4.3: Add navigation from Home screen cards\n\n## What This Task Does\nEnable tapping Home screen content cards to navigate to the Item Detail page.\n\n## Why This Matters\n- **Discovery Flow**: Home → Item Detail for featured content\n- **\"Jump Back In\"**: Resume where you left off\n- **Consistency**: All cards navigate to same detail page\n\n## Implementation\n\n### For Featured Content (\"Jump Back In\")\n```typescript\nfunction JumpBackInSection({ items }) {\n  const router = useRouter();\n  \n  return (\n    \u003cScrollView horizontal\u003e\n      {items.map((item) =\u003e (\n        \u003cItemCard\n          key={item.id}\n          item={item}\n          variant=\"large\"\n          onPress={() =\u003e router.push(`/item/${item.id}`)}\n        /\u003e\n      ))}\n    \u003c/ScrollView\u003e\n  );\n}\n```\n\n### For Recent Items List\n```typescript\nfunction RecentItemsList({ items }) {\n  return (\n    \u003cFlatList\n      data={items}\n      renderItem={({ item, index }) =\u003e (\n        \u003cItemCard\n          item={item}\n          variant=\"compact\"\n          index={index}\n          // ItemCard handles navigation internally\n        /\u003e\n      )}\n    /\u003e\n  );\n}\n```\n\n### If Using Shared ItemCard\nNavigation is already built into ItemCard via internal `useRouter().push()`.\n\n## Scope Consideration\nThe Home screen implementation varies. This task should:\n1. Identify all item cards on Home screen\n2. Ensure each navigates correctly\n3. Verify with different content types\n\n## Acceptance Criteria\n- [ ] Featured cards navigate on tap\n- [ ] List cards navigate on tap\n- [ ] Correct item ID in route\n- [ ] Back returns to Home\n- [ ] Works for all card variants\n\n## Files to Modify\n- MODIFY: apps/mobile/app/(tabs)/index.tsx\n- POSSIBLY: apps/mobile/components/item-card.tsx\n\n## Dependencies\n- Depends on: zine-qch.4 (ItemCard component)\n- Depends on: zine-qch.15 (route must exist)\n\n## Notes\nHome screen implementation may be minimal. Verify what content exists on Home before implementing.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:16.47992-06:00","updated_at":"2025-12-25T22:36:11.62085-06:00","closed_at":"2025-12-25T22:36:11.62085-06:00","dependencies":[{"issue_id":"zine-qch.24","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:16.480267-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.24","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:24:22.061526-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.24","depends_on_id":"zine-qch.15","type":"blocks","created_at":"2025-12-25T22:24:22.22982-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.3","title":"Phase 1.3: Create lib/content-utils.ts with content type helpers","description":"# Phase 1.3: Create lib/content-utils.ts with content type helpers\n\n## What This Task Does\nExtract content type utility functions (icon selection, colors, labels) into a centralized module.\n\n## Why This Matters\n- **Code Duplication**: getContentIcon and getProviderColor defined in library.tsx\n- **Consistency**: Ensures VIDEO always gets red color, PODCAST always green\n- **Type Safety**: Proper typing for ContentType and Provider enums\n- **Item Detail Page Dependency**: Detail page uses these for adaptive aspect ratio and styling\n\n## Current State Analysis\n\n### From library.tsx (lines 110-129):\n```typescript\nfunction getContentIcon(type: ContentType, size = 14, color = '#fff') {\n  switch (type) {\n    case 'podcast': return \u003cHeadphonesIcon size={size} color={color} /\u003e;\n    case 'video': return \u003cVideoIcon size={size} color={color} /\u003e;\n    default: return \u003cArticleIcon size={size} color={color} /\u003e;\n  }\n}\n\nfunction getProviderColor(provider: Provider): string {\n  const providerColorMap: Record\u003cProvider, string\u003e = {\n    youtube: ProviderColors.youtube,\n    spotify: ProviderColors.spotify,\n    // ...\n  };\n  return providerColorMap[provider] || '#6366F1';\n}\n```\n\n## Implementation Details\n\n### Module Structure\n```typescript\n// apps/mobile/lib/content-utils.ts\nimport { ContentColors, ProviderColors } from '@/constants/theme';\nimport { HeadphonesIcon, VideoIcon, ArticleIcon } from '@/components/icons';\n\n// Types (re-export from shared or define locally)\nexport type ContentType = 'VIDEO' | 'PODCAST' | 'ARTICLE' | 'POST';\nexport type UIContentType = 'video' | 'podcast' | 'article' | 'post';\nexport type Provider = 'YOUTUBE' | 'SPOTIFY' | 'RSS' | 'SUBSTACK';\nexport type UIProvider = 'youtube' | 'spotify' | 'rss' | 'substack';\n\n/**\n * Get the appropriate icon component for a content type\n */\nexport function getContentIcon(\n  type: UIContentType | ContentType,\n  size?: number,\n  color?: string\n): React.ReactElement;\n\n/**\n * Get the theme color for a content type\n */\nexport function getContentColor(type: UIContentType | ContentType): string;\n\n/**\n * Get the theme color for a provider\n */\nexport function getProviderColor(provider: UIProvider | Provider): string;\n\n/**\n * Get human-readable label for content type\n */\nexport function getContentTypeLabel(type: ContentType | UIContentType): string;\n\n/**\n * Get the appropriate aspect ratio for cover images\n * - Podcasts: 1:1 (square album art)\n * - Videos: 16:9 (widescreen)\n * - Articles: 16:10 (slightly taller)\n */\nexport function getContentAspectRatio(type: ContentType | UIContentType): number;\n\n/**\n * Map API content type to UI content type (lowercase)\n */\nexport function mapContentType(apiType: ContentType): UIContentType;\n\n/**\n * Map API provider to UI provider (lowercase)\n */\nexport function mapProvider(apiProvider: Provider): UIProvider;\n```\n\n### Aspect Ratio Logic (NEW)\nThis is critical for the Item Detail Page:\n```typescript\nexport function getContentAspectRatio(type: ContentType | UIContentType): number {\n  const normalized = typeof type === 'string' ? type.toLowerCase() : type;\n  switch (normalized) {\n    case 'podcast':\n    case 'PODCAST':\n      return 1;        // 1:1 square (album art style)\n    case 'video':\n    case 'VIDEO':\n      return 16 / 9;   // Widescreen video\n    case 'article':\n    case 'ARTICLE':\n    case 'post':\n    case 'POST':\n    default:\n      return 16 / 10;  // Slightly taller for reading content\n  }\n}\n```\n\n## Why Case Insensitive?\nThe API returns uppercase (`VIDEO`, `PODCAST`) but UI often uses lowercase for styling keys. Functions should accept both to reduce friction.\n\n## Acceptance Criteria\n- [ ] All utility functions extracted\n- [ ] getContentAspectRatio added (new function)\n- [ ] Type-safe with proper TypeScript\n- [ ] Works with both API (uppercase) and UI (lowercase) types\n- [ ] JSDoc comments with usage examples\n\n## Files to Create\n- CREATE: apps/mobile/lib/content-utils.ts\n\n## Dependencies\n- Depends on: zine-qch.1 (icon components must exist)\n- Uses: @/constants/theme (existing)\n\n## Testing Notes\n```typescript\ngetContentAspectRatio('PODCAST')  // 1\ngetContentAspectRatio('podcast')  // 1\ngetContentAspectRatio('VIDEO')    // 1.777... (16/9)\ngetContentColor('video')          // from ContentColors.video\ngetProviderColor('YOUTUBE')       // from ProviderColors.youtube\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:12.456188-06:00","updated_at":"2025-12-25T22:46:37.881371-06:00","closed_at":"2025-12-25T22:46:37.881371-06:00","dependencies":[{"issue_id":"zine-qch.3","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:12.456592-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.3","depends_on_id":"zine-qch.1","type":"blocks","created_at":"2025-12-25T22:24:17.195375-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.4","title":"Phase 1.4: Create unified ItemCard component with variants","description":"# Phase 1.4: Create unified ItemCard component with variants\n\n## What This Task Does\nCreate a single, flexible ItemCard component that replaces the duplicated card implementations across Library, Inbox, and Home screens.\n\n## Why This Matters\n- **Major Duplication**: Three different card implementations with similar but inconsistent code\n- **Navigation Target**: All cards will navigate to item detail page - logic should be in one place\n- **Consistency**: Ensures thumbnail handling, metadata display, and animations are uniform\n- **Maintainability**: Bug fixes and enhancements apply to all screens\n\n## Current State Analysis\n\n### Library Screen - LibraryCard (lines 167-229)\n- Horizontal layout (thumbnail left, content right)\n- Compact size (100px thumbnail width)\n- Shows: type indicator, duration badge, title, source, relative time\n- No actions (tap to navigate only)\n\n### Inbox Screen - InboxItemCard (lines 81-183)\n- Vertical layout (thumbnail top, content below)\n- Full width with 16:9 thumbnail\n- Shows: duration badge, type badge, title, creator\n- Has inline actions: Archive button, Bookmark button\n\n### Home Screen (presumed)\n- Large featured cards (\"Jump Back In\")\n- Similar to inbox but larger\n- Different visual treatment\n\n## Implementation Details\n\n### Component API Design\n```typescript\n// apps/mobile/components/item-card.tsx\n\ntype ItemCardVariant = 'compact' | 'full' | 'large';\n\ninterface ItemCardProps {\n  /** The item data to display */\n  item: {\n    id: string;\n    title: string;\n    creator: string;\n    thumbnailUrl: string | null;\n    contentType: ContentType;\n    provider: Provider;\n    duration?: number | null;\n    bookmarkedAt?: string | null;\n    publishedAt?: string | null;\n  };\n  \n  /** Visual variant */\n  variant?: ItemCardVariant;\n  \n  /** Whether to show inline action buttons */\n  showActions?: boolean;\n  \n  /** Callback when bookmark action is pressed */\n  onBookmark?: () =\u003e void;\n  \n  /** Callback when archive action is pressed */\n  onArchive?: () =\u003e void;\n  \n  /** Whether bookmark mutation is pending */\n  isBookmarking?: boolean;\n  \n  /** Whether archive mutation is pending */\n  isArchiving?: boolean;\n  \n  /** Animation delay index for staggered entry */\n  index?: number;\n  \n  /** Called when card is pressed (default: navigate to detail) */\n  onPress?: () =\u003e void;\n}\n```\n\n### Variant Specifications\n\n#### compact (Library)\n```\n┌──────────────────────────────────────┐\n│ ┌────┐                               │\n│ │IMG │ Title goes here...            │\n│ │    │ ● Source · 2 days ago         │\n│ └────┘                               │\n└──────────────────────────────────────┘\n```\n- 100px thumbnail width\n- Horizontal layout\n- No actions\n- Row height: ~80-100px\n\n#### full (Inbox)\n```\n┌──────────────────────────────────────┐\n│ ┌──────────────────────────────────┐ │\n│ │                                  │ │\n│ │        THUMBNAIL (16:9)          │ │\n│ │                                  │ │\n│ └──────────────────────────────────┘ │\n│                                      │\n│ Title Goes Here                      │\n│ Creator · Publisher                  │\n│                                      │\n│              [Archive] [Bookmark]    │\n└──────────────────────────────────────┘\n```\n- Full width thumbnail (16:9)\n- Vertical layout\n- Shows actions when showActions=true\n- Card height: variable\n\n#### large (Home \"Jump Back In\")\n```\n┌──────────────────────────────────────┐\n│ ┌──────────────────────────────────┐ │\n│ │                                  │ │\n│ │        THUMBNAIL (larger)        │ │\n│ │                                  │ │\n│ └──────────────────────────────────┘ │\n│                                      │\n│ Title Goes Here (larger text)        │\n│ Creator                              │\n└──────────────────────────────────────┘\n```\n- Larger thumbnail\n- Larger typography\n- Featured styling\n\n### Common Elements (All Variants)\n1. **Type indicator badge** - Top-left corner of thumbnail\n2. **Duration badge** - Bottom-right corner of thumbnail\n3. **Provider color dot** - In metadata line\n4. **Placeholder image** - When thumbnailUrl is null\n5. **Entry animation** - FadeInDown with stagger based on index\n\n### Navigation Integration\n```typescript\nimport { useRouter } from 'expo-router';\n\nfunction ItemCard({ item, onPress, ...props }: ItemCardProps) {\n  const router = useRouter();\n  \n  const handlePress = () =\u003e {\n    if (onPress) {\n      onPress();\n    } else {\n      router.push(`/item/${item.id}`);\n    }\n  };\n  \n  return (\n    \u003cPressable onPress={handlePress}\u003e\n      {/* ... card content ... */}\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n## Acceptance Criteria\n- [ ] Supports all three variants (compact, full, large)\n- [ ] Renders identically to current implementations\n- [ ] Handles navigation to item detail page\n- [ ] Supports optional action buttons\n- [ ] Proper loading states for actions\n- [ ] Entry animations with stagger\n- [ ] Accessibility: proper hitSlop and labels\n\n## Files to Create\n- CREATE: apps/mobile/components/item-card.tsx\n\n## Dependencies\n- Depends on: zine-qch.1 (icon components)\n- Depends on: zine-qch.2 (formatDuration, formatRelativeTime)\n- Depends on: zine-qch.3 (getContentIcon, getProviderColor, getContentAspectRatio)\n\n## Testing Notes\nRender each variant side-by-side with existing implementation to verify pixel-perfect match before refactoring screens.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:12.624519-06:00","updated_at":"2025-12-25T22:56:37.965868-06:00","closed_at":"2025-12-25T22:56:37.965868-06:00","dependencies":[{"issue_id":"zine-qch.4","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:12.624826-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.4","depends_on_id":"zine-qch.1","type":"blocks","created_at":"2025-12-25T22:24:17.360643-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.4","depends_on_id":"zine-qch.2","type":"blocks","created_at":"2025-12-25T22:24:17.527195-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.4","depends_on_id":"zine-qch.3","type":"blocks","created_at":"2025-12-25T22:24:17.694948-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.5","title":"Phase 1.5: Refactor Library screen to use shared components","description":"# Phase 1.5: Refactor Library screen to use shared components\n\n## What This Task Does\nReplace inline card implementations in library.tsx with the new shared ItemCard component.\n\n## Why This Matters\n- **Consistency**: Library cards now use same component as other screens\n- **Navigation**: ItemCard handles navigation to detail page\n- **Maintenance**: Future changes apply to all screens\n\n## Current State\nLibrary screen (lines 167-229) has LibraryCard component with:\n- Horizontal layout (thumbnail left)\n- 100px thumbnail\n- Type indicator, duration badge\n- Title, source, relative time\n\n## Changes Required\n\n### Before\n```typescript\nfunction LibraryCard({ item, colors, index }: LibraryCardProps) {\n  // ~60 lines of JSX and styling\n}\n```\n\n### After\n```typescript\nimport { ItemCard } from '@/components/item-card';\n\n// In the screen:\n{libraryItems.map((item, index) =\u003e (\n  \u003cItemCard\n    key={item.id}\n    item={item}\n    variant=\"compact\"\n    index={index}\n  /\u003e\n))}\n```\n\n## Cleanup Required\n1. Remove LibraryCard component\n2. Remove inline icon definitions (SearchIcon, etc.)\n3. Remove getContentIcon function\n4. Remove getProviderColor function\n5. Update imports to use shared modules\n\n## Acceptance Criteria\n- [ ] ItemCard variant=\"compact\" renders identically to old LibraryCard\n- [ ] Navigation to item detail works on card tap\n- [ ] Animations preserved (stagger entry)\n- [ ] All inline icons removed (use shared)\n- [ ] No visual regressions\n\n## Files to Modify\n- MODIFY: apps/mobile/app/(tabs)/library.tsx\n\n## Dependencies\n- Depends on: zine-qch.4 (ItemCard component must exist)\n\n## Testing Notes\nCompare screenshots before/after to verify pixel-perfect match.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T22:20:12.795784-06:00","updated_at":"2025-12-25T23:04:03.950533-06:00","closed_at":"2025-12-25T23:04:03.950533-06:00","dependencies":[{"issue_id":"zine-qch.5","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:12.796127-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.5","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:24:17.857614-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.6","title":"Phase 1.6: Refactor Inbox screen to use shared components","description":"# Phase 1.6: Refactor Inbox screen to use shared components\n\n## What This Task Does\nReplace inline InboxItemCard in inbox.tsx with the shared ItemCard component.\n\n## Why This Matters\n- **Consistency**: Inbox cards match styling of other screens\n- **Navigation**: ItemCard handles navigation to detail page\n- **Actions**: Use shared action handling pattern\n\n## Current State\nInbox screen (lines 81-183) has InboxItemCard with:\n- Vertical layout (thumbnail top)\n- 16:9 thumbnail\n- Duration badge, type badge\n- Title, creator\n- Inline Archive and Bookmark buttons\n\n## Changes Required\n\n### Before\n```typescript\nfunction InboxItemCard({...}: InboxItemCardProps) {\n  // ~100 lines of JSX\n}\n```\n\n### After\n```typescript\nimport { ItemCard } from '@/components/item-card';\n\n{data.items.map((item, index) =\u003e (\n  \u003cItemCard\n    key={item.id}\n    item={item}\n    variant=\"full\"\n    showActions={true}\n    onBookmark={() =\u003e handleBookmark(item.id)}\n    onArchive={() =\u003e handleArchive(item.id)}\n    isBookmarking={bookmarkMutation.isPending \u0026\u0026 bookmarkMutation.variables?.id === item.id}\n    isArchiving={archiveMutation.isPending \u0026\u0026 archiveMutation.variables?.id === item.id}\n    index={index}\n  /\u003e\n))}\n```\n\n## Cleanup Required\n1. Remove InboxItemCard component\n2. Remove inline icon definitions (BookmarkIcon, ArchiveIcon)\n3. Update imports\n\n## Acceptance Criteria\n- [ ] ItemCard variant=\"full\" renders identically to old InboxItemCard\n- [ ] Archive and Bookmark actions work\n- [ ] Loading states for actions work\n- [ ] Navigation to item detail works\n- [ ] Animations preserved\n\n## Files to Modify\n- MODIFY: apps/mobile/app/(tabs)/inbox.tsx\n\n## Dependencies\n- Depends on: zine-qch.4 (ItemCard component must exist)\n\n## Testing Notes\n1. Verify bookmark action updates UI optimistically\n2. Verify archive action removes item from list\n3. Compare screenshots before/after","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T22:20:12.970034-06:00","updated_at":"2025-12-25T23:05:12.698616-06:00","closed_at":"2025-12-25T23:05:12.698616-06:00","dependencies":[{"issue_id":"zine-qch.6","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:12.970389-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.6","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:24:18.021245-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.7","title":"Phase 1.7: Refactor Home screen to use shared components","description":"# Phase 1.7: Refactor Home screen to use shared components\n\n## What This Task Does\nUpdate index.tsx (Home screen) to use shared ItemCard component for any content cards.\n\n## Why This Matters\n- **Consistency**: Home cards match styling of other screens\n- **Navigation**: ItemCard handles navigation to detail page\n- **\"Jump Back In\"**: Large variant for featured cards\n\n## Current State\nHome screen likely has:\n- Featured content sections\n- \"Jump Back In\" with larger cards\n- \"Recent\" or other lists\n\n## Changes Required\n\n### For Featured Cards\n```typescript\n{featuredItems.map((item, index) =\u003e (\n  \u003cItemCard\n    key={item.id}\n    item={item}\n    variant=\"large\"\n    index={index}\n  /\u003e\n))}\n```\n\n### For List Items\n```typescript\n{recentItems.map((item, index) =\u003e (\n  \u003cItemCard\n    key={item.id}\n    item={item}\n    variant=\"compact\"\n    index={index}\n  /\u003e\n))}\n```\n\n## Cleanup Required\n1. Remove any inline card components\n2. Remove inline icon definitions\n3. Update imports\n\n## Acceptance Criteria\n- [ ] All item cards use shared ItemCard component\n- [ ] Large variant for featured content\n- [ ] Compact variant for list content\n- [ ] Navigation works\n- [ ] No visual regressions\n\n## Files to Modify\n- MODIFY: apps/mobile/app/(tabs)/index.tsx\n\n## Dependencies\n- Depends on: zine-qch.4 (ItemCard component must exist)\n\n## Notes\nThis task scope depends on current Home screen implementation. May be minimal if Home doesn't show item cards yet.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T22:20:13.143063-06:00","updated_at":"2025-12-25T23:09:52.551935-06:00","closed_at":"2025-12-25T23:09:52.551935-06:00","dependencies":[{"issue_id":"zine-qch.7","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:13.143414-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.7","depends_on_id":"zine-qch.4","type":"blocks","created_at":"2025-12-25T22:24:18.185556-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.8","title":"Phase 2.1: Add isFinished and finishedAt columns to user_items schema","description":"# Phase 2.1: Add isFinished and finishedAt columns to user_items schema\n\n## What This Task Does\nAdd two new columns to the `user_items` table in Drizzle schema to track whether a user has consumed/finished an item.\n\n## Why This Matters\n- **Core Feature**: The Item Detail Page needs a \"Mark as Finished\" toggle\n- **User Value**: Users want to track what they've watched/listened to vs what's still pending\n- **Data Model**: Separate from bookmark state (can be finished but still bookmarked)\n\n## Schema Design\n\n### New Columns\n```typescript\n// Add to apps/worker/src/db/schema.ts in userItems table definition\n\nisFinished: integer('is_finished', { mode: 'boolean' }).default(false),\nfinishedAt: text('finished_at'), // ISO 8601 string, null when not finished\n```\n\n### Why These Types?\n- **isFinished as integer (mode: boolean)**: SQLite has no native boolean; Drizzle maps 0/1\n- **finishedAt as text (ISO 8601)**: Matches existing timestamp convention in this table (ingestedAt, bookmarkedAt)\n- **finishedAt nullable**: Only set when isFinished=true, cleared when unmarked\n\n### Relationship to Existing Fields\n```\nUserItem\n├── state: INBOX | BOOKMARKED | ARCHIVED  (lifecycle state)\n├── ingestedAt: timestamp                  (when item arrived)\n├── bookmarkedAt: timestamp | null         (when saved)\n├── isFinished: boolean (NEW)              (consumption tracking)\n└── finishedAt: timestamp | null (NEW)     (when marked finished)\n```\n\n### State Matrix\n| state | isFinished | Meaning |\n|-------|------------|---------|\n| INBOX | false | New, unprocessed |\n| INBOX | true | Unlikely but valid (triaged after consuming) |\n| BOOKMARKED | false | Saved for later, not yet consumed |\n| BOOKMARKED | true | Saved and consumed (reference material) |\n| ARCHIVED | false | Dismissed without consuming |\n| ARCHIVED | true | Consumed then archived |\n\n## Implementation Details\n\n### Schema Change\n```typescript\nexport const userItems = sqliteTable('user_items', {\n  // ... existing columns ...\n  \n  // NEW: Consumption tracking\n  isFinished: integer('is_finished', { mode: 'boolean' }).default(false).notNull(),\n  finishedAt: text('finished_at'), // ISO 8601, null when not finished\n});\n```\n\n### Index Consideration\nNo index needed initially. If we add a \"Show unfinished only\" filter later:\n```sql\nCREATE INDEX idx_user_items_unfinished \nON user_items(user_id, is_finished) WHERE state = 'BOOKMARKED';\n```\n\n## Acceptance Criteria\n- [ ] isFinished column added with boolean mode\n- [ ] finishedAt column added as nullable text\n- [ ] Default value of false for isFinished\n- [ ] TypeScript types updated for select/insert\n- [ ] No breaking changes to existing queries\n\n## Files to Modify\n- MODIFY: apps/worker/src/db/schema.ts\n\n## Dependencies\n- None (schema change only)\n\n## Migration Notes\nThis is a non-destructive, additive change. Existing rows will have:\n- isFinished = false (default)\n- finishedAt = null\n\nNo data migration needed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:13.31336-06:00","updated_at":"2025-12-25T22:48:22.370201-06:00","closed_at":"2025-12-25T22:48:22.370201-06:00","dependencies":[{"issue_id":"zine-qch.8","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:13.313732-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-qch.9","title":"Phase 2.2: Create database migration for isFinished fields","description":"# Phase 2.2: Create database migration for isFinished fields\n\n## What This Task Does\nGenerate and apply a Drizzle migration to add the isFinished and finishedAt columns to the user_items table in Cloudflare D1.\n\n## Why This Matters\n- **Production Safety**: Migrations ensure schema changes are versioned and reversible\n- **D1 Requirement**: Schema changes must be applied via migrations, not direct DDL\n- **CI/CD Integration**: Migrations run automatically in deployment pipeline\n\n## Migration Details\n\n### Expected SQL\n```sql\n-- Migration: add_is_finished_to_user_items.sql\nALTER TABLE user_items ADD COLUMN is_finished INTEGER NOT NULL DEFAULT 0;\nALTER TABLE user_items ADD COLUMN finished_at TEXT;\n```\n\n### Why INTEGER for Boolean?\nSQLite has no native boolean type. Drizzle's `integer({ mode: 'boolean' })` maps:\n- `false` → `0`\n- `true` → `1`\n\n### Why DEFAULT 0?\nExisting rows should default to \"not finished\" state.\n\n## Implementation Steps\n\n### 1. Generate Migration\n```bash\ncd apps/worker\nbun drizzle-kit generate\n```\n\nThis reads the updated schema.ts and generates a migration in `src/db/migrations/`.\n\n### 2. Verify Migration File\nCheck the generated SQL matches expected changes.\n\n### 3. Apply to Local/Dev D1\n```bash\nwrangler d1 migrations apply zine-db --local\n```\n\n### 4. Test in Development\nRun the worker locally and verify:\n- New columns exist\n- Existing data has is_finished = 0\n- Queries still work\n\n## Migration Naming Convention\nFollowing existing pattern (see migrations folder):\n```\n0007_add_is_finished_to_user_items.sql\n```\n(Number increments from last migration)\n\n## Rollback Strategy\nIf migration fails:\n```sql\nALTER TABLE user_items DROP COLUMN is_finished;\nALTER TABLE user_items DROP COLUMN finished_at;\n```\n\nNote: SQLite's ALTER TABLE has limitations. If rollback needed in production, may require backup/restore.\n\n## Acceptance Criteria\n- [ ] Migration file generated by drizzle-kit\n- [ ] Migration applies successfully to local D1\n- [ ] Existing data unaffected (is_finished = 0)\n- [ ] TypeScript types match migrated schema\n- [ ] No errors in drizzle-kit output\n\n## Files to Create\n- CREATE: apps/worker/src/db/migrations/0007_*.sql (or next number)\n\n## Dependencies\n- Depends on: zine-qch.8 (schema.ts must be updated first)\n\n## Testing Notes\n```bash\n# After migration, verify in D1 shell:\nwrangler d1 execute zine-db --local --command \"PRAGMA table_info(user_items);\"\n# Should show is_finished and finished_at columns\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:20:13.483137-06:00","updated_at":"2025-12-25T22:52:39.877085-06:00","closed_at":"2025-12-25T22:52:39.877085-06:00","dependencies":[{"issue_id":"zine-qch.9","depends_on_id":"zine-qch","type":"parent-child","created_at":"2025-12-25T22:20:13.483455-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-qch.9","depends_on_id":"zine-qch.8","type":"blocks","created_at":"2025-12-25T22:24:18.353488-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq","title":"Subscriptions Backend Implementation","description":"Complete backend implementation for the Zine subscriptions feature, enabling users to subscribe to YouTube channels and Spotify podcasts with automated content polling and inbox delivery.\n\n## Overview\nThis epic implements the server-side infrastructure for subscriptions as specified in features/subscriptions/backend-spec.md. The feature allows users to:\n- Connect their YouTube and Spotify accounts via OAuth\n- Subscribe to channels/shows from those providers\n- Receive new content automatically delivered to their inbox via background polling\n\n## Architecture Summary\n- **Data Model**: provider_connections, subscriptions, subscription_items, provider_items_seen tables\n- **OAuth**: PKCE flow with server-side state validation and encrypted token storage\n- **Polling**: Cron-triggered batch processing with distributed locks and adaptive intervals\n- **Ingestion**: Idempotent pipeline with atomic transactions and deduplication\n- **API**: tRPC routers for connections, discovery, and subscription management\n\n## Key Design Decisions\n1. **Millisecond timestamps**: All _at columns use Unix ms (matches JS Date.now())\n2. **Soft delete for subscriptions**: Preserves metadata for re-subscribe scenarios\n3. **Two deduplication tables**: subscription_items (per-subscription tracking) vs provider_items_seen (user-wide idempotency)\n4. **Proactive token refresh**: Refresh 5 min before expiry to avoid mid-operation failures\n5. **Distributed locks via KV**: Prevents cron collisions and token refresh races\n\n## Success Criteria\n- Users can connect/disconnect YouTube and Spotify accounts\n- Users can browse and subscribe to channels/shows\n- New content appears in inbox within 15-60 minutes of publication\n- System handles rate limits gracefully without data loss\n- Tokens remain valid through automatic refresh\n\n## Related Documentation\n- Backend spec: features/subscriptions/backend-spec.md\n- Frontend spec: features/subscriptions/frontend-spec.md\n- Main spec: features/subscriptions/spec.md","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-16T22:07:11.239958-06:00","updated_at":"2025-12-17T19:53:13.481048-06:00","closed_at":"2025-12-17T19:53:13.481048-06:00"}
{"id":"zine-teq.1","title":"Database Schema: provider_connections table","description":"Create the provider_connections table to store OAuth credentials for connected providers (YouTube, Spotify).\n\n## Table Definition\n```sql\nCREATE TABLE provider_connections (\n  id TEXT PRIMARY KEY,           -- ULID\n  user_id TEXT NOT NULL,         -- FK to users\n  provider TEXT NOT NULL,        -- 'YOUTUBE' | 'SPOTIFY'\n  provider_user_id TEXT,         -- Provider's user ID (for reference)\n  access_token TEXT NOT NULL,    -- AES-256-GCM encrypted\n  refresh_token TEXT NOT NULL,   -- AES-256-GCM encrypted\n  token_expires_at INTEGER NOT NULL, -- Unix timestamp in MILLISECONDS\n  scopes TEXT,                   -- Comma-separated granted scopes\n  connected_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  last_refreshed_at INTEGER,\n  status TEXT NOT NULL DEFAULT 'ACTIVE', -- ACTIVE | EXPIRED | REVOKED\n  \n  UNIQUE(user_id, provider)\n);\n```\n\n## Implementation Notes\n- **Timestamp convention**: All _at columns store milliseconds (not seconds) to match JS Date.now()\n- **Token encryption**: access_token and refresh_token are stored encrypted; encryption utilities are a separate task\n- **Unique constraint**: One connection per provider per user; reconnecting updates existing row\n- **Status values**: ACTIVE (working), EXPIRED (refresh failed), REVOKED (user revoked on provider side)\n\n## Why This Design\n- Storing provider_user_id allows detecting if a different account is connected on reconnect\n- Scopes field enables checking if we have required permissions without hitting the provider\n- last_refreshed_at helps debug token issues and track refresh patterns\n- Soft status instead of deleting allows preserving connection history\n\n## Files to Modify\n- apps/worker/src/db/schema.ts - Add table definition\n- apps/worker/src/db/migrations/ - New migration file\n\n## Acceptance Criteria\n- [ ] Table created with all columns and constraints\n- [ ] Migration runs successfully\n- [ ] Drizzle schema exports the table for use in queries\n- [ ] Indexes on (user_id, provider) for lookups","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:07:24.884764-06:00","updated_at":"2025-12-17T18:36:28.056847-06:00","closed_at":"2025-12-17T18:36:28.056847-06:00","dependencies":[{"issue_id":"zine-teq.1","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:07:24.885119-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.10","title":"YouTube: SDK integration and client factory","description":"Completed: YouTube SDK integration with googleapis package and client factory","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:10:08.511186-06:00","updated_at":"2025-12-17T18:51:05.906431-06:00","closed_at":"2025-12-17T18:51:05.906431-06:00","dependencies":[{"issue_id":"zine-teq.10","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:10:08.51155-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.10","depends_on_id":"zine-teq.9","type":"blocks","created_at":"2025-12-16T22:19:12.320006-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.10","depends_on_id":"zine-teq.6","type":"blocks","created_at":"2025-12-16T22:19:12.370706-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.11","title":"Spotify: SDK integration and client factory","description":"Completed: Spotify SDK integration with client factory and helper functions","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:10:33.598756-06:00","updated_at":"2025-12-17T18:51:06.307754-06:00","closed_at":"2025-12-17T18:51:06.307754-06:00","dependencies":[{"issue_id":"zine-teq.11","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:10:33.599166-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.11","depends_on_id":"zine-teq.9","type":"blocks","created_at":"2025-12-16T22:19:16.119858-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.11","depends_on_id":"zine-teq.6","type":"blocks","created_at":"2025-12-16T22:19:16.168973-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.12","title":"tRPC: Connections router (list, disconnect)","description":"Implement the connections tRPC router for listing and disconnecting provider connections.\n\n## Router Structure\n```typescript\n// apps/worker/src/trpc/routers/connections.ts\nexport const connectionsRouter = router({\n  // List user's connected providers\n  list: protectedProcedure.query(/* ... */),\n  \n  // Register OAuth state (implemented in zine-teq.7)\n  registerState: protectedProcedure.mutation(/* ... */),\n  \n  // Exchange code for tokens (implemented in zine-teq.8)\n  callback: protectedProcedure.mutation(/* ... */),\n  \n  // Disconnect a provider\n  disconnect: protectedProcedure.mutation(/* ... */),\n});\n```\n\n## List Endpoint\nReturns all connected providers for the authenticated user with status.\n\n```typescript\nlist: protectedProcedure.query(async ({ ctx }) =\u003e {\n  const connections = await ctx.db.query.providerConnections.findMany({\n    where: eq(providerConnections.userId, ctx.userId),\n    columns: {\n      provider: true,\n      status: true,\n      connectedAt: true,\n      lastRefreshedAt: true,\n      // Explicitly exclude tokens!\n    },\n  });\n  \n  // Return a map for easy lookup\n  return {\n    YOUTUBE: connections.find(c =\u003e c.provider === 'YOUTUBE') ?? null,\n    SPOTIFY: connections.find(c =\u003e c.provider === 'SPOTIFY') ?? null,\n  };\n}),\n```\n\n## Disconnect Endpoint\nRevokes access and cleans up related data.\n\n```typescript\ndisconnect: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    const connection = await ctx.db.query.providerConnections.findFirst({\n      where: and(\n        eq(providerConnections.userId, ctx.userId),\n        eq(providerConnections.provider, input.provider)\n      ),\n    });\n    \n    if (!connection) {\n      throw new TRPCError({ code: 'NOT_FOUND', message: 'Provider not connected' });\n    }\n    \n    // 1. Attempt to revoke tokens with provider (best effort)\n    try {\n      await revokeProviderTokens(connection, ctx.env);\n    } catch (e) {\n      // Log but don't fail - we'll delete our copy anyway\n      console.error('Failed to revoke tokens with provider:', e);\n    }\n    \n    // 2. Update subscriptions to DISCONNECTED\n    await ctx.db.update(subscriptions)\n      .set({ status: 'DISCONNECTED', updatedAt: Date.now() })\n      .where(and(\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.provider, input.provider)\n      ));\n    \n    // 3. Delete our stored connection\n    await ctx.db.delete(providerConnections)\n      .where(eq(providerConnections.id, connection.id));\n    \n    return { success: true };\n  }),\n```\n\n## Token Revocation\n```typescript\n// apps/worker/src/lib/oauth.ts\nasync function revokeProviderTokens(\n  connection: ProviderConnection,\n  env: Env\n): Promise\u003cvoid\u003e {\n  const accessToken = await decrypt(connection.accessToken, env.ENCRYPTION_KEY);\n  \n  if (connection.provider === 'YOUTUBE') {\n    // Google's revoke endpoint\n    await fetch(`https://oauth2.googleapis.com/revoke?token=${accessToken}`, {\n      method: 'POST',\n    });\n  } else if (connection.provider === 'SPOTIFY') {\n    // Spotify doesn't have a revoke endpoint\n    // Users must revoke via Spotify account settings\n  }\n}\n```\n\n## Rate Limiting\n| Endpoint   | Window | Max | Key    |\n|------------|--------|-----|--------|\n| disconnect | 1 min  | 3   | userId |\n\n## Response Types\n```typescript\ninterface ConnectionInfo {\n  provider: 'YOUTUBE' | 'SPOTIFY';\n  status: 'ACTIVE' | 'EXPIRED' | 'REVOKED';\n  connectedAt: number;\n  lastRefreshedAt: number | null;\n}\n\ninterface ListConnectionsResponse {\n  YOUTUBE: ConnectionInfo | null;\n  SPOTIFY: ConnectionInfo | null;\n}\n```\n\n## Files to Create/Modify\n- apps/worker/src/trpc/routers/connections.ts - Main router file\n- apps/worker/src/trpc/router.ts - Register connectionsRouter\n- apps/worker/src/lib/oauth.ts - Add revokeProviderTokens\n\n## Dependencies\n- zine-teq.1 (provider_connections table)\n- zine-teq.7 (registerState - same file)\n- zine-teq.8 (callback - same file)\n\n## Acceptance Criteria\n- [ ] list returns connected providers without exposing tokens\n- [ ] disconnect revokes with provider and deletes connection\n- [ ] disconnect marks related subscriptions as DISCONNECTED\n- [ ] Rate limiting prevents disconnect abuse\n- [ ] Integration tests cover happy path and error cases","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:10:54.217868-06:00","updated_at":"2025-12-17T18:56:19.752948-06:00","closed_at":"2025-12-17T18:56:19.752948-06:00","dependencies":[{"issue_id":"zine-teq.12","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:10:54.218258-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.12","depends_on_id":"zine-teq.1","type":"blocks","created_at":"2025-12-16T22:19:19.888624-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.12","depends_on_id":"zine-teq.7","type":"blocks","created_at":"2025-12-16T22:19:19.936998-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.12","depends_on_id":"zine-teq.8","type":"blocks","created_at":"2025-12-16T22:19:19.982516-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.13","title":"tRPC: Subscriptions router (add, remove, list)","description":"Implement the core subscriptions tRPC router for subscription management.\n\n## Router Structure\n```typescript\n// apps/worker/src/trpc/routers/subscriptions.ts\nexport const subscriptionsRouter = router({\n  // List user's subscriptions\n  list: protectedProcedure.query(/* paginated list */),\n  \n  // Add a subscription\n  add: protectedProcedure.mutation(/* subscribe to channel/show */),\n  \n  // Remove a subscription\n  remove: protectedProcedure.mutation(/* unsubscribe */),\n  \n  // Pause/resume (separate task)\n  // Sync now (separate task)\n  // Discovery (separate task)\n});\n```\n\n## List Endpoint (Paginated)\n```typescript\nlist: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema.optional(),\n    status: SubscriptionStatusSchema.optional(),\n    limit: z.number().min(1).max(100).default(50),\n    cursor: z.string().optional(), // ULID for cursor-based pagination\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    const conditions = [eq(subscriptions.userId, ctx.userId)];\n    \n    if (input.provider) {\n      conditions.push(eq(subscriptions.provider, input.provider));\n    }\n    if (input.status) {\n      conditions.push(eq(subscriptions.status, input.status));\n    }\n    if (input.cursor) {\n      conditions.push(gt(subscriptions.id, input.cursor));\n    }\n    \n    const results = await ctx.db.query.subscriptions.findMany({\n      where: and(...conditions),\n      orderBy: [asc(subscriptions.id)],\n      limit: input.limit + 1,\n    });\n    \n    const hasMore = results.length \u003e input.limit;\n    const items = hasMore ? results.slice(0, -1) : results;\n    \n    return {\n      items,\n      nextCursor: hasMore ? items[items.length - 1].id : null,\n      hasMore,\n    };\n  }),\n```\n\n## Add Endpoint (Subscribe)\n```typescript\nadd: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n    providerChannelId: z.string(), // Validated by provider-specific schema\n    name: z.string().optional(),\n    imageUrl: z.string().url().optional(),\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Validate provider channel ID format\n    if (input.provider === 'YOUTUBE') {\n      YouTubeChannelIdSchema.parse(input.providerChannelId);\n    } else {\n      SpotifyShowIdSchema.parse(input.providerChannelId);\n    }\n    \n    // 2. Check provider connection exists and is active\n    const connection = await ctx.db.query.providerConnections.findFirst({\n      where: and(\n        eq(providerConnections.userId, ctx.userId),\n        eq(providerConnections.provider, input.provider),\n        eq(providerConnections.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!connection) {\n      throw new TRPCError({\n        code: 'PRECONDITION_FAILED',\n        message: `${input.provider} account not connected`,\n      });\n    }\n    \n    // 3. Fetch channel/show details if not provided\n    let name = input.name;\n    let imageUrl = input.imageUrl;\n    let description: string | undefined;\n    let externalUrl: string | undefined;\n    \n    if (!name || !imageUrl) {\n      const details = await fetchChannelDetails(connection, input.providerChannelId, ctx.env);\n      name = name || details.name;\n      imageUrl = imageUrl || details.imageUrl;\n      description = details.description;\n      externalUrl = details.externalUrl;\n    }\n    \n    // 4. Create subscription (upsert for re-subscribe)\n    const subscriptionId = ulid();\n    await ctx.db.insert(subscriptions).values({\n      id: subscriptionId,\n      userId: ctx.userId,\n      provider: input.provider,\n      providerChannelId: input.providerChannelId,\n      name,\n      description,\n      imageUrl,\n      externalUrl,\n      status: 'ACTIVE',\n      pollIntervalSeconds: 3600, // Default 1 hour\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    }).onConflictDoUpdate({\n      target: [subscriptions.userId, subscriptions.provider, subscriptions.providerChannelId],\n      set: {\n        status: 'ACTIVE',\n        name,\n        imageUrl,\n        description,\n        externalUrl,\n        updatedAt: Date.now(),\n      },\n    });\n    \n    // 5. Trigger initial fetch (fetch latest item only)\n    await triggerInitialFetch(ctx.userId, subscriptionId, connection, input.provider, input.providerChannelId, ctx.env);\n    \n    return { subscriptionId, name, imageUrl };\n  }),\n```\n\n## Remove Endpoint (Unsubscribe)\n```typescript\nremove: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    const subscription = await ctx.db.query.subscriptions.findFirst({\n      where: and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId)\n      ),\n    });\n    \n    if (!subscription) {\n      throw new TRPCError({ code: 'NOT_FOUND' });\n    }\n    \n    await ctx.db.transaction(async (tx) =\u003e {\n      // 1. Soft delete subscription (preserves metadata for re-subscribe)\n      await tx.update(subscriptions)\n        .set({ status: 'UNSUBSCRIBED', updatedAt: Date.now() })\n        .where(eq(subscriptions.id, input.subscriptionId));\n      \n      // 2. Hard delete subscription_items (tracking records)\n      await tx.delete(subscriptionItems)\n        .where(eq(subscriptionItems.subscriptionId, input.subscriptionId));\n      \n      // 3. Delete INBOX user_items from this subscription\n      // Note: Keeps SAVED, ARCHIVED items (user committed to those)\n      const itemIds = await tx.query.subscriptionItems.findMany({\n        where: eq(subscriptionItems.subscriptionId, input.subscriptionId),\n        columns: { itemId: true },\n      });\n      \n      if (itemIds.length \u003e 0) {\n        await tx.delete(userItems)\n          .where(and(\n            eq(userItems.userId, ctx.userId),\n            eq(userItems.state, 'INBOX'),\n            inArray(userItems.itemId, itemIds.map(i =\u003e i.itemId))\n          ));\n      }\n      \n      // 4. DO NOT delete provider_items_seen (prevents duplicates on re-subscribe)\n    });\n    \n    return { success: true };\n  }),\n```\n\n## Unsubscribe Behavior Summary\n| Table | Action | Rationale |\n|-------|--------|-----------|\n| subscriptions | Soft delete (UNSUBSCRIBED) | Preserves metadata for re-subscribe |\n| subscription_items | Hard delete | Tracking records have no value |\n| user_items (INBOX) | Hard delete | User hasn't committed to these |\n| user_items (SAVED/ARCHIVED) | Preserved | User's intentional saves |\n| provider_items_seen | Preserved | Prevents duplicates on re-subscribe |\n\n## Files to Create/Modify\n- apps/worker/src/trpc/routers/subscriptions.ts - Main router\n- apps/worker/src/trpc/router.ts - Register subscriptionsRouter\n\n## Dependencies\n- zine-teq.2 (subscriptions table)\n- zine-teq.3 (subscription_items table)\n- zine-teq.5 (validation schemas)\n- zine-teq.10 (YouTube SDK for details fetch)\n- zine-teq.11 (Spotify SDK for details fetch)\n\n## Acceptance Criteria\n- [ ] list returns paginated subscriptions with cursor\n- [ ] add validates provider channel ID format\n- [ ] add requires active provider connection\n- [ ] add fetches channel details if not provided\n- [ ] add handles re-subscription (upsert to ACTIVE)\n- [ ] remove soft-deletes subscription\n- [ ] remove hard-deletes subscription_items and INBOX user_items\n- [ ] remove preserves SAVED/ARCHIVED items and provider_items_seen\n- [ ] Integration tests cover subscription lifecycle","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:11:22.563292-06:00","updated_at":"2025-12-17T18:56:20.883594-06:00","closed_at":"2025-12-17T18:56:20.883594-06:00","dependencies":[{"issue_id":"zine-teq.13","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:11:22.563689-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.13","depends_on_id":"zine-teq.2","type":"blocks","created_at":"2025-12-16T22:19:23.823902-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.13","depends_on_id":"zine-teq.3","type":"blocks","created_at":"2025-12-16T22:19:23.873062-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.13","depends_on_id":"zine-teq.5","type":"blocks","created_at":"2025-12-16T22:19:23.91813-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.13","depends_on_id":"zine-teq.10","type":"blocks","created_at":"2025-12-16T22:19:23.964909-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.13","depends_on_id":"zine-teq.11","type":"blocks","created_at":"2025-12-16T22:19:24.00941-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.14","title":"tRPC: Subscriptions discovery endpoints","description":"Implement discovery endpoints for browsing available channels/shows to subscribe to.\n\n## Discovery Use Cases\n1. **Available**: Show channels/podcasts the user follows on YouTube/Spotify but hasn't subscribed to in Zine\n2. **Search**: Search for channels/podcasts by name (for subscribing to things not in their provider library)\n\n## Router Additions\n```typescript\n// apps/worker/src/trpc/routers/subscriptions.ts (add to existing)\n\ndiscover: router({\n  // Get user's provider subscriptions not yet in Zine\n  available: protectedProcedure\n    .input(z.object({\n      provider: ProviderSchema,\n    }))\n    .query(/* ... */),\n  \n  // Search for channels/shows on provider\n  search: protectedProcedure\n    .input(z.object({\n      provider: ProviderSchema,\n      query: z.string().min(2).max(100),\n      limit: z.number().min(1).max(20).default(10),\n    }))\n    .query(/* ... */),\n}),\n```\n\n## Available Endpoint\nReturns channels/shows the user follows on the provider but hasn't subscribed to in Zine.\n\n```typescript\navailable: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    // 1. Get active provider connection\n    const connection = await getActiveConnection(ctx.userId, input.provider, ctx);\n    if (!connection) {\n      return { items: [], connectionRequired: true };\n    }\n    \n    // 2. Fetch user's subscriptions from provider\n    let providerSubs: ProviderChannel[];\n    if (input.provider === 'YOUTUBE') {\n      const client = await getYouTubeClientForConnection(connection, ctx.env);\n      providerSubs = await getUserSubscriptions(client);\n    } else {\n      const client = await getSpotifyClientForConnection(connection, ctx.env);\n      providerSubs = await getUserSavedShows(client);\n    }\n    \n    // 3. Get existing Zine subscriptions for this provider\n    const existingIds = await ctx.db.query.subscriptions.findMany({\n      where: and(\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.provider, input.provider),\n        ne(subscriptions.status, 'UNSUBSCRIBED')\n      ),\n      columns: { providerChannelId: true },\n    }).then(rows =\u003e new Set(rows.map(r =\u003e r.providerChannelId)));\n    \n    // 4. Filter to only show not-yet-subscribed\n    const available = providerSubs.filter(sub =\u003e !existingIds.has(sub.id));\n    \n    return {\n      items: available,\n      connectionRequired: false,\n    };\n  }),\n```\n\n## Search Endpoint\n**Note**: YouTube search costs 100 quota units per call. Use sparingly and consider caching.\n\n```typescript\nsearch: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n    query: z.string().min(2).max(100),\n    limit: z.number().min(1).max(20).default(10),\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    // 1. Rate limit search (expensive, especially YouTube)\n    await rateLimitSearch(ctx.userId, input.provider, ctx.env);\n    \n    // 2. Get active provider connection\n    const connection = await getActiveConnection(ctx.userId, input.provider, ctx);\n    if (!connection) {\n      throw new TRPCError({\n        code: 'PRECONDITION_FAILED',\n        message: `${input.provider} account not connected`,\n      });\n    }\n    \n    // 3. Search provider\n    let results: ProviderChannel[];\n    if (input.provider === 'YOUTUBE') {\n      const client = await getYouTubeClientForConnection(connection, ctx.env);\n      results = await searchYouTubeChannels(client, input.query, input.limit);\n    } else {\n      const client = await getSpotifyClientForConnection(connection, ctx.env);\n      results = await searchSpotifyShows(client, input.query, input.limit);\n    }\n    \n    return { items: results };\n  }),\n```\n\n## Provider Search Implementations\n\n### YouTube Search (100 quota units!)\n```typescript\n// apps/worker/src/providers/youtube.ts\nexport async function searchYouTubeChannels(\n  client: YouTubeClient,\n  query: string,\n  limit: number\n): Promise\u003cProviderChannel[]\u003e {\n  const response = await client.api.search.list({\n    part: ['snippet'],\n    q: query,\n    type: ['channel'],\n    maxResults: limit,\n  });\n  \n  return response.data.items?.map(item =\u003e ({\n    id: item.id?.channelId,\n    name: item.snippet?.title,\n    description: item.snippet?.description,\n    imageUrl: item.snippet?.thumbnails?.default?.url,\n  })) || [];\n}\n```\n\n### Spotify Search\n```typescript\n// apps/worker/src/providers/spotify.ts\nexport async function searchSpotifyShows(\n  client: SpotifyApi,\n  query: string,\n  limit: number\n): Promise\u003cProviderChannel[]\u003e {\n  const response = await client.search(query, ['show'], undefined, limit);\n  \n  return response.shows.items.map(show =\u003e ({\n    id: show.id,\n    name: show.name,\n    description: show.description,\n    imageUrl: show.images[0]?.url,\n    publisher: show.publisher,\n  }));\n}\n```\n\n## Rate Limiting for Search\n| Provider | Window | Max Requests | Reason |\n|----------|--------|--------------|--------|\n| YouTube | 1 min | 3 | 100 quota units per search |\n| Spotify | 1 min | 10 | Moderate rate limits |\n\n```typescript\nasync function rateLimitSearch(userId: string, provider: Provider, env: Env) {\n  const key = `search:rate:${userId}:${provider}`;\n  const limit = provider === 'YOUTUBE' ? 3 : 10;\n  \n  const current = parseInt(await env.KV.get(key) || '0', 10);\n  if (current \u003e= limit) {\n    throw new TRPCError({ code: 'TOO_MANY_REQUESTS', message: 'Search rate limit exceeded' });\n  }\n  \n  await env.KV.put(key, String(current + 1), { expirationTtl: 60 });\n}\n```\n\n## Response Type\n```typescript\ninterface ProviderChannel {\n  id: string;\n  name: string;\n  description?: string;\n  imageUrl?: string;\n  publisher?: string; // Spotify shows only\n}\n```\n\n## Files to Modify\n- apps/worker/src/trpc/routers/subscriptions.ts - Add discover sub-router\n- apps/worker/src/providers/youtube.ts - Add searchYouTubeChannels\n- apps/worker/src/providers/spotify.ts - Add searchSpotifyShows\n\n## Dependencies\n- zine-teq.10 (YouTube SDK)\n- zine-teq.11 (Spotify SDK)\n- zine-teq.13 (subscriptions router structure)\n\n## Acceptance Criteria\n- [ ] available returns provider subscriptions not in Zine\n- [ ] available handles disconnected providers gracefully\n- [ ] search finds channels/shows by name\n- [ ] search is rate limited (especially YouTube)\n- [ ] Both endpoints require active provider connection\n- [ ] Integration tests cover discovery flow","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:11:49.573004-06:00","updated_at":"2025-12-17T19:05:01.819266-06:00","closed_at":"2025-12-17T19:05:01.819266-06:00","dependencies":[{"issue_id":"zine-teq.14","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:11:49.573414-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.14","depends_on_id":"zine-teq.10","type":"blocks","created_at":"2025-12-16T22:19:27.619549-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.14","depends_on_id":"zine-teq.11","type":"blocks","created_at":"2025-12-16T22:19:27.668676-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.14","depends_on_id":"zine-teq.13","type":"blocks","created_at":"2025-12-16T22:19:27.714839-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.15","title":"tRPC: Subscriptions pause/resume and syncNow","description":"Implement pause, resume, and manual sync (syncNow) endpoints for subscription management.\n\n## Use Cases\n- **Pause**: User wants to temporarily stop receiving content from a subscription without unsubscribing\n- **Resume**: User wants to restart content delivery after pausing\n- **Sync Now**: User wants to immediately check for new content instead of waiting for next poll\n\n## Router Additions\n```typescript\n// apps/worker/src/trpc/routers/subscriptions.ts (add to existing)\n\n// Pause a subscription (stops polling)\npause: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(/* ... */),\n\n// Resume a paused subscription\nresume: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(/* ... */),\n\n// Manually trigger a sync (rate limited)\nsyncNow: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(/* ... */),\n```\n\n## Pause Endpoint\n```typescript\npause: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    const result = await ctx.db.update(subscriptions)\n      .set({ \n        status: 'PAUSED', \n        updatedAt: Date.now() \n      })\n      .where(and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.status, 'ACTIVE') // Can only pause active subscriptions\n      ))\n      .returning({ id: subscriptions.id });\n    \n    if (result.length === 0) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Subscription not found or not active',\n      });\n    }\n    \n    return { success: true };\n  }),\n```\n\n## Resume Endpoint\n```typescript\nresume: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Check subscription exists and is paused\n    const subscription = await ctx.db.query.subscriptions.findFirst({\n      where: and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.status, 'PAUSED')\n      ),\n    });\n    \n    if (!subscription) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Subscription not found or not paused',\n      });\n    }\n    \n    // 2. Verify provider connection is still active\n    const connection = await ctx.db.query.providerConnections.findFirst({\n      where: and(\n        eq(providerConnections.userId, ctx.userId),\n        eq(providerConnections.provider, subscription.provider),\n        eq(providerConnections.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!connection) {\n      throw new TRPCError({\n        code: 'PRECONDITION_FAILED',\n        message: 'Provider connection expired. Please reconnect.',\n      });\n    }\n    \n    // 3. Resume subscription\n    await ctx.db.update(subscriptions)\n      .set({ \n        status: 'ACTIVE',\n        updatedAt: Date.now(),\n        // Clear lastPolledAt to prioritize in next cron\n        lastPolledAt: null,\n      })\n      .where(eq(subscriptions.id, input.subscriptionId));\n    \n    return { success: true };\n  }),\n```\n\n## Sync Now Endpoint (Manual Poll)\n```typescript\nsyncNow: protectedProcedure\n  .input(z.object({\n    subscriptionId: z.string(),\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Rate limit: 1 per 5 minutes per subscription\n    const rateLimitKey = `manual-sync:${input.subscriptionId}`;\n    const lastSync = await ctx.env.KV.get(rateLimitKey);\n    \n    if (lastSync) {\n      const elapsed = Date.now() - parseInt(lastSync, 10);\n      const cooldown = 5 * 60 * 1000; // 5 minutes\n      \n      if (elapsed \u003c cooldown) {\n        const remainingSeconds = Math.ceil((cooldown - elapsed) / 1000);\n        throw new TRPCError({\n          code: 'TOO_MANY_REQUESTS',\n          message: `Please wait ${remainingSeconds} seconds before syncing again`,\n        });\n      }\n    }\n    \n    // 2. Get subscription and verify ownership\n    const subscription = await ctx.db.query.subscriptions.findFirst({\n      where: and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!subscription) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Subscription not found or not active',\n      });\n    }\n    \n    // 3. Get provider connection\n    const connection = await ctx.db.query.providerConnections.findFirst({\n      where: and(\n        eq(providerConnections.userId, ctx.userId),\n        eq(providerConnections.provider, subscription.provider),\n        eq(providerConnections.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!connection) {\n      throw new TRPCError({\n        code: 'PRECONDITION_FAILED',\n        message: 'Provider connection expired',\n      });\n    }\n    \n    // 4. Perform sync\n    const result = await pollSingleSubscription(subscription, connection, ctx.env);\n    \n    // 5. Set rate limit\n    await ctx.env.KV.put(rateLimitKey, Date.now().toString(), { expirationTtl: 300 });\n    \n    return {\n      success: result.success,\n      itemsFound: result.itemsFound,\n      newItems: result.newItems,\n      error: result.error,\n    };\n  }),\n```\n\n## Response Type for syncNow\n```typescript\ninterface SyncResult {\n  success: boolean;\n  itemsFound: number;    // Total items checked\n  newItems: number;      // Items added to inbox\n  error?: string;        // Error message if failed\n}\n```\n\n## Status Transitions\n```\nACTIVE ──pause──→ PAUSED\nPAUSED ──resume──→ ACTIVE\nACTIVE ──disconnect──→ DISCONNECTED\nDISCONNECTED ──reconnect──→ ACTIVE (handled by resume after reconnect)\n```\n\n## Rate Limiting Summary\n| Action | Limit | Window | Key |\n|--------|-------|--------|-----|\n| syncNow | 1 | 5 min | subscriptionId |\n\n## Files to Modify\n- apps/worker/src/trpc/routers/subscriptions.ts - Add pause, resume, syncNow\n\n## Dependencies\n- zine-teq.13 (subscriptions router structure)\n- zine-teq.17 (polling logic for syncNow - can stub initially)\n\n## Acceptance Criteria\n- [ ] pause changes status from ACTIVE to PAUSED\n- [ ] pause rejects if not ACTIVE\n- [ ] resume changes status from PAUSED to ACTIVE\n- [ ] resume verifies provider connection is active\n- [ ] syncNow triggers immediate poll\n- [ ] syncNow is rate limited to 1 per 5 minutes\n- [ ] syncNow returns item counts\n- [ ] Integration tests cover state transitions","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:12:13.848217-06:00","updated_at":"2025-12-17T19:05:02.438084-06:00","closed_at":"2025-12-17T19:05:02.438084-06:00","dependencies":[{"issue_id":"zine-teq.15","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:12:13.848597-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.15","depends_on_id":"zine-teq.13","type":"blocks","created_at":"2025-12-16T22:19:31.677667-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.16","title":"Item Transformation: YouTube video and Spotify episode mappers","description":"Implemented transformYouTubeVideo and transformSpotifyEpisode functions in apps/worker/src/ingestion/transformers.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:12:38.384045-06:00","updated_at":"2025-12-17T18:56:20.265467-06:00","closed_at":"2025-12-17T18:56:20.265467-06:00","dependencies":[{"issue_id":"zine-teq.16","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:12:38.38444-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.16","depends_on_id":"zine-teq.5","type":"blocks","created_at":"2025-12-16T22:19:35.01398-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.17","title":"Ingestion Pipeline: Idempotent item processing with transactions","description":"Implemented idempotent ingestion processor with atomic transactions. Created processor.ts with ingestItem and ingestBatch functions that handle idempotency checks, timestamp format bridging (Unix ms to ISO8601), and atomic writes across items, user_items, subscription_items, and provider_items_seen tables.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:13:03.422298-06:00","updated_at":"2025-12-17T18:56:21.340272-06:00","closed_at":"2025-12-17T18:56:21.340272-06:00","dependencies":[{"issue_id":"zine-teq.17","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:13:03.422694-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.17","depends_on_id":"zine-teq.3","type":"blocks","created_at":"2025-12-16T22:19:38.689573-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.17","depends_on_id":"zine-teq.4","type":"blocks","created_at":"2025-12-16T22:19:38.739366-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.17","depends_on_id":"zine-teq.16","type":"blocks","created_at":"2025-12-16T22:19:38.784868-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.18","title":"Initial Fetch: Latest item semantics on subscription creation","description":"Implemented initial fetch logic that triggers when a subscription is created. The implementation fetches only the latest item from the channel/show and ingests it into the user's inbox using the existing ingestion pipeline for idempotency.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:13:30.337091-06:00","updated_at":"2025-12-17T19:05:03.019788-06:00","closed_at":"2025-12-17T19:05:03.019788-06:00","dependencies":[{"issue_id":"zine-teq.18","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:13:30.337474-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.18","depends_on_id":"zine-teq.10","type":"blocks","created_at":"2025-12-16T22:19:42.535828-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.18","depends_on_id":"zine-teq.11","type":"blocks","created_at":"2025-12-16T22:19:42.584945-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.18","depends_on_id":"zine-teq.17","type":"blocks","created_at":"2025-12-16T22:19:42.630455-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.19","title":"Polling: Cron job with distributed locking and batch processing","description":"Implement the main subscription polling cron job with distributed locks to prevent overlapping executions.\n\n## Cron Configuration\n```toml\n# wrangler.toml\n[triggers]\ncrons = [\"*/15 * * * *\"]  # Every 15 minutes\n```\n\n## Why Distributed Locks?\nCloudflare Workers cron can run on multiple instances. Without locking:\n- Same subscriptions polled multiple times\n- Wasted API quota\n- Potential race conditions in ingestion\n\n## Main Cron Handler\n\n```typescript\n// apps/worker/src/scheduled.ts\n\nexport async function scheduled(\n  event: ScheduledEvent,\n  env: Env,\n  ctx: ExecutionContext\n): Promise\u003cvoid\u003e {\n  switch (event.cron) {\n    case '*/15 * * * *':\n      await pollSubscriptions(env, ctx);\n      break;\n    // Add other crons here as needed\n  }\n}\n```\n\n## Polling Logic with Lock\n\n```typescript\n// apps/worker/src/polling/scheduler.ts\n\nconst POLL_LOCK_KEY = 'cron:poll-subscriptions:lock';\nconst POLL_LOCK_TTL = 900; // 15 minutes (matches cron interval)\nconst BATCH_SIZE = 50;\n\nexport async function pollSubscriptions(\n  env: Env,\n  ctx: ExecutionContext\n): Promise\u003cPollResult\u003e {\n  // 1. Try to acquire distributed lock\n  const existingLock = await env.KV.get(POLL_LOCK_KEY);\n  if (existingLock) {\n    const elapsedMs = Date.now() - parseInt(existingLock, 10);\n    if (elapsedMs \u003c POLL_LOCK_TTL * 1000) {\n      console.log('Poll skipped: lock held by another worker');\n      return { skipped: true, reason: 'lock_held' };\n    }\n    // Lock is stale, proceed to acquire\n  }\n  \n  // 2. Acquire lock (optimistic, KV is eventually consistent)\n  await env.KV.put(POLL_LOCK_KEY, Date.now().toString(), { \n    expirationTtl: POLL_LOCK_TTL \n  });\n  \n  try {\n    // 3. Find due subscriptions\n    const now = Date.now();\n    const dueSubscriptions = await db.query.subscriptions.findMany({\n      where: and(\n        eq(subscriptions.status, 'ACTIVE'),\n        or(\n          isNull(subscriptions.lastPolledAt),\n          lt(\n            subscriptions.lastPolledAt, \n            sql`${now} - (${subscriptions.pollIntervalSeconds} * 1000)`\n          )\n        )\n      ),\n      orderBy: [asc(subscriptions.lastPolledAt)], // Oldest first\n      limit: BATCH_SIZE,\n    });\n    \n    if (dueSubscriptions.length === 0) {\n      return { skipped: false, processed: 0, reason: 'no_due_subscriptions' };\n    }\n    \n    // 4. Group by provider for efficient token usage\n    const byProvider = groupBy(dueSubscriptions, 'provider');\n    \n    // 5. Process each provider's subscriptions\n    const results = await Promise.all([\n      processYouTubeBatch(byProvider.YOUTUBE || [], env),\n      processSpotifyBatch(byProvider.SPOTIFY || [], env),\n    ]);\n    \n    const totalProcessed = results.reduce((sum, r) =\u003e sum + r.processed, 0);\n    const totalNewItems = results.reduce((sum, r) =\u003e sum + r.newItems, 0);\n    \n    return {\n      skipped: false,\n      processed: totalProcessed,\n      newItems: totalNewItems,\n    };\n  } finally {\n    // 6. Release lock\n    await env.KV.delete(POLL_LOCK_KEY);\n  }\n}\n```\n\n## Provider Batch Processing\n\n```typescript\nasync function processYouTubeBatch(\n  subscriptions: Subscription[],\n  env: Env\n): Promise\u003cBatchResult\u003e {\n  if (subscriptions.length === 0) {\n    return { processed: 0, newItems: 0 };\n  }\n  \n  // Group subscriptions by user (to share client/token)\n  const byUser = groupBy(subscriptions, 'userId');\n  \n  let processed = 0;\n  let newItems = 0;\n  \n  for (const [userId, userSubs] of Object.entries(byUser)) {\n    // Check rate limit before processing user's subscriptions\n    const rateCheck = await isRateLimited('YOUTUBE', userId, env.KV);\n    if (rateCheck.limited) {\n      console.log(`Skipping user ${userId}: rate limited`);\n      continue;\n    }\n    \n    // Get user's connection\n    const connection = await getActiveConnection(userId, 'YOUTUBE', env);\n    if (!connection) {\n      // Mark subscriptions as DISCONNECTED\n      await markSubscriptionsDisconnected(userSubs.map(s =\u003e s.id), env);\n      continue;\n    }\n    \n    try {\n      const client = await getYouTubeClientForConnection(connection, env);\n      \n      for (const sub of userSubs) {\n        const result = await pollSingleYouTubeSubscription(sub, client, userId, env);\n        processed++;\n        newItems += result.newItems;\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        await markConnectionExpired(connection.id, env);\n        await markSubscriptionsDisconnected(userSubs.map(s =\u003e s.id), env);\n      }\n      console.error(`YouTube batch error for user ${userId}:`, error);\n    }\n  }\n  \n  return { processed, newItems };\n}\n```\n\n## Single Subscription Poll\n\n```typescript\nasync function pollSingleYouTubeSubscription(\n  subscription: Subscription,\n  client: YouTubeClient,\n  userId: string,\n  env: Env\n): Promise\u003c{ newItems: number }\u003e {\n  try {\n    // 1. Fetch recent videos since last poll\n    const uploadsPlaylistId = await getChannelUploadsPlaylistId(\n      client, \n      subscription.providerChannelId\n    );\n    \n    const videos = await fetchRecentVideos(client, uploadsPlaylistId, 10);\n    \n    // 2. Filter to new videos (published after last_polled_at)\n    const newVideos = subscription.lastPolledAt\n      ? videos.filter(v =\u003e \n          new Date(v.publishedAt).getTime() \u003e subscription.lastPolledAt!\n        )\n      : videos.slice(0, 1); // First poll: only latest\n    \n    // 3. Ingest new items\n    let newItems = 0;\n    for (const video of newVideos) {\n      const result = await ingestItem(\n        userId,\n        subscription.id,\n        video,\n        'YOUTUBE',\n        db,\n        transformYouTubeVideo\n      );\n      if (result.created) newItems++;\n    }\n    \n    // 4. Update subscription\n    const newestPublishedAt = videos.length \u003e 0\n      ? Math.max(...videos.map(v =\u003e new Date(v.publishedAt).getTime()))\n      : subscription.lastPublishedAt;\n    \n    await db.update(subscriptions)\n      .set({\n        lastPolledAt: Date.now(),\n        lastPublishedAt: newestPublishedAt,\n        updatedAt: Date.now(),\n      })\n      .where(eq(subscriptions.id, subscription.id));\n    \n    // Clear poll failure count on success\n    await clearPollFailures(subscription.id, env);\n    \n    return { newItems };\n  } catch (error) {\n    // Track poll failure\n    await trackPollFailure(subscription.id, error as Error, env);\n    \n    // Update lastPolledAt even on error to prevent tight retry loops\n    await db.update(subscriptions)\n      .set({ lastPolledAt: Date.now(), updatedAt: Date.now() })\n      .where(eq(subscriptions.id, subscription.id));\n    \n    throw error;\n  }\n}\n```\n\n## Result Types\n```typescript\ninterface PollResult {\n  skipped: boolean;\n  reason?: string;\n  processed?: number;\n  newItems?: number;\n}\n\ninterface BatchResult {\n  processed: number;\n  newItems: number;\n}\n```\n\n## Files to Create/Modify\n- apps/worker/src/scheduled.ts - Cron handler\n- apps/worker/src/polling/scheduler.ts - Main polling logic\n- apps/worker/wrangler.toml - Add cron trigger\n\n## Dependencies\n- zine-teq.9 (token refresh)\n- zine-teq.10 (YouTube SDK)\n- zine-teq.11 (Spotify SDK)\n- zine-teq.17 (ingestion pipeline)\n- zine-teq.22 (rate limiter)\n- zine-teq.25 (connection health - for trackPollFailure)\n\n## Acceptance Criteria\n- [ ] Cron triggers every 15 minutes\n- [ ] Distributed lock prevents overlapping executions\n- [ ] Only processes subscriptions due for polling\n- [ ] Groups by provider and user for efficiency\n- [ ] Updates lastPolledAt after each subscription\n- [ ] Handles auth errors by marking disconnected\n- [ ] Continues processing on individual subscription errors\n- [ ] Rate limits respected per user/provider\n- [ ] Poll failures tracked for health monitoring\n- [ ] Integration tests verify polling behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:14:01.383353-06:00","updated_at":"2025-12-17T19:36:15.51776-06:00","closed_at":"2025-12-17T19:36:15.51776-06:00","dependencies":[{"issue_id":"zine-teq.19","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:14:01.383764-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.19","depends_on_id":"zine-teq.9","type":"blocks","created_at":"2025-12-16T22:19:47.545616-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.19","depends_on_id":"zine-teq.10","type":"blocks","created_at":"2025-12-16T22:19:47.595066-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.19","depends_on_id":"zine-teq.11","type":"blocks","created_at":"2025-12-16T22:19:47.641007-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.19","depends_on_id":"zine-teq.17","type":"blocks","created_at":"2025-12-16T22:19:47.686476-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.2","title":"Database Schema: subscriptions table","description":"Create the subscriptions table to track user subscriptions to YouTube channels and Spotify shows.\n\n## Table Definition\n```sql\nCREATE TABLE subscriptions (\n  id TEXT PRIMARY KEY,                    -- ULID\n  user_id TEXT NOT NULL,                  -- FK to users\n  provider TEXT NOT NULL,                 -- 'YOUTUBE' | 'SPOTIFY'\n  provider_channel_id TEXT NOT NULL,      -- YouTube channel ID (UC...) or Spotify show ID\n  name TEXT NOT NULL,                     -- Channel/show display name\n  description TEXT,                       -- Channel/show description (cached)\n  image_url TEXT,                         -- Thumbnail/artwork URL (cached)\n  external_url TEXT,                      -- Link to channel/show on provider\n  total_items INTEGER,                    -- Total videos/episodes (cached, informational)\n  last_published_at INTEGER,              -- Timestamp of newest known item (ms)\n  last_polled_at INTEGER,                 -- Last successful poll timestamp (ms)\n  poll_interval_seconds INTEGER NOT NULL DEFAULT 3600, -- Polling frequency\n  status TEXT NOT NULL DEFAULT 'ACTIVE',  -- ACTIVE | PAUSED | DISCONNECTED | UNSUBSCRIBED\n  created_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  updated_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  \n  UNIQUE(user_id, provider, provider_channel_id)\n);\n\nCREATE INDEX idx_subscriptions_poll ON subscriptions(status, last_polled_at);\nCREATE INDEX idx_subscriptions_user ON subscriptions(user_id, status);\n```\n\n## Implementation Notes\n- **Polling index**: idx_subscriptions_poll enables efficient queries for 'find subscriptions due for polling'\n- **User index**: idx_subscriptions_user supports fast listing of a user's active subscriptions\n- **poll_interval_seconds**: Stored in seconds (not ms) since it's a duration, not a timestamp\n- **Soft delete via status**: UNSUBSCRIBED preserves metadata; hard delete only for subscription_items\n\n## Status Semantics\n- ACTIVE: Polling enabled, content delivered to inbox\n- PAUSED: User-initiated pause, no polling, can resume\n- DISCONNECTED: Provider connection lost/expired, needs reconnection\n- UNSUBSCRIBED: Soft-deleted, preserved for re-subscribe detection\n\n## Why This Design\n- Caching name/image_url avoids provider API calls for display\n- last_published_at enables showing 'last updated X ago' in UI\n- poll_interval_seconds per-subscription enables adaptive polling\n- External URL useful for 'open in YouTube/Spotify' actions\n\n## Files to Modify\n- apps/worker/src/db/schema.ts\n- apps/worker/src/db/migrations/\n\n## Acceptance Criteria\n- [ ] Table created with all columns and constraints\n- [ ] Both indexes created for query performance\n- [ ] Migration runs successfully\n- [ ] Drizzle schema exports the table","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:07:39.601359-06:00","updated_at":"2025-12-17T18:36:28.611506-06:00","closed_at":"2025-12-17T18:36:28.611506-06:00","dependencies":[{"issue_id":"zine-teq.2","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:07:39.60172-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.20","title":"Polling: Adaptive interval adjustment based on channel activity","description":"Implement adaptive polling intervals that adjust based on channel publishing frequency.\n\n## Motivation\nPolling every hour for a channel that posts monthly wastes quota and resources. Conversely, a daily vlogger needs more frequent checks.\n\n## Interval Tiers\n| Channel Activity | Polling Interval | Detection Criteria |\n|-----------------|------------------|-------------------|\n| Very active | 1 hour | 7+ items in last 7 days |\n| Active | 4 hours | 1-6 items in last 7 days |\n| Moderate | 12 hours | 1-4 items in last 30 days |\n| Inactive | 24 hours | No items in 30+ days |\n\n## Implementation\n\n### Activity Detection\n```typescript\n// apps/worker/src/polling/adaptive.ts\n\ninterface ActivityMetrics {\n  itemsLast7Days: number;\n  itemsLast30Days: number;\n  daysSinceLastItem: number | null;\n}\n\nexport function calculateOptimalInterval(metrics: ActivityMetrics): number {\n  // Very active: 7+ items in last week\n  if (metrics.itemsLast7Days \u003e= 7) {\n    return 3600; // 1 hour\n  }\n  \n  // Active: at least 1 item in last week\n  if (metrics.itemsLast7Days \u003e= 1) {\n    return 4 * 3600; // 4 hours\n  }\n  \n  // Moderate: at least 1 item in last 30 days\n  if (metrics.itemsLast30Days \u003e= 1) {\n    return 12 * 3600; // 12 hours\n  }\n  \n  // Inactive: no items in 30+ days\n  return 24 * 3600; // 24 hours\n}\n\nexport async function getActivityMetrics(\n  subscriptionId: string,\n  db: DrizzleDB\n): Promise\u003cActivityMetrics\u003e {\n  const now = Date.now();\n  const sevenDaysAgo = now - 7 * 24 * 3600 * 1000;\n  const thirtyDaysAgo = now - 30 * 24 * 3600 * 1000;\n  \n  // Count items from this subscription by published_at\n  const items = await db.query.subscriptionItems.findMany({\n    where: eq(subscriptionItems.subscriptionId, subscriptionId),\n    columns: { publishedAt: true },\n    orderBy: [desc(subscriptionItems.publishedAt)],\n    limit: 100, // Enough to calculate metrics\n  });\n  \n  return {\n    itemsLast7Days: items.filter(i =\u003e i.publishedAt \u0026\u0026 i.publishedAt \u003e sevenDaysAgo).length,\n    itemsLast30Days: items.filter(i =\u003e i.publishedAt \u0026\u0026 i.publishedAt \u003e thirtyDaysAgo).length,\n    daysSinceLastItem: items.length \u003e 0 \u0026\u0026 items[0].publishedAt\n      ? Math.floor((now - items[0].publishedAt) / (24 * 3600 * 1000))\n      : null,\n  };\n}\n```\n\n### Interval Update Hook\nCalled after successful poll:\n\n```typescript\nexport async function maybeUpdatePollInterval(\n  subscriptionId: string,\n  db: DrizzleDB\n): Promise\u003cvoid\u003e {\n  const metrics = await getActivityMetrics(subscriptionId, db);\n  const optimalInterval = calculateOptimalInterval(metrics);\n  \n  const subscription = await db.query.subscriptions.findFirst({\n    where: eq(subscriptions.id, subscriptionId),\n    columns: { pollIntervalSeconds: true },\n  });\n  \n  if (!subscription) return;\n  \n  // Only update if interval changed significantly (avoid DB writes for minor changes)\n  const currentInterval = subscription.pollIntervalSeconds;\n  const change = Math.abs(optimalInterval - currentInterval) / currentInterval;\n  \n  if (change \u003e= 0.5) { // 50% change threshold\n    await db.update(subscriptions)\n      .set({ pollIntervalSeconds: optimalInterval, updatedAt: Date.now() })\n      .where(eq(subscriptions.id, subscriptionId));\n    \n    console.log(`Adjusted poll interval for ${subscriptionId}: ${currentInterval}s → ${optimalInterval}s`);\n  }\n}\n```\n\n### Integration with Polling\nAdd to pollSingleSubscription after successful ingestion:\n\n```typescript\n// In polling/scheduler.ts\nasync function pollSingleYouTubeSubscription(...) {\n  // ... existing poll logic ...\n  \n  // After successful poll, consider adjusting interval\n  if (shouldAdjustInterval(subscription)) {\n    await maybeUpdatePollInterval(subscription.id, db);\n  }\n}\n\nfunction shouldAdjustInterval(subscription: Subscription): boolean {\n  // Only adjust periodically to avoid constant DB writes\n  // Check roughly once per day\n  const dayInMs = 24 * 3600 * 1000;\n  const timeSinceCreation = Date.now() - subscription.createdAt;\n  const pollCount = Math.floor(timeSinceCreation / (subscription.pollIntervalSeconds * 1000));\n  \n  // Adjust every ~24 polls (roughly daily for most intervals)\n  return pollCount % 24 === 0;\n}\n```\n\n## Quota Impact Analysis\nWith adaptive polling, a user with 10 subscriptions:\n\n**Without adaptive polling** (all 1 hour):\n- 10 subs × 24 polls/day = 240 polls/day\n- × 2 API calls/poll = 480 quota/day\n\n**With adaptive polling** (realistic mix):\n- 2 very active (1h) = 48 polls\n- 3 active (4h) = 18 polls  \n- 3 moderate (12h) = 6 polls\n- 2 inactive (24h) = 2 polls\n- Total: 74 polls × 2 = 148 quota/day\n\n**Savings: ~70%** quota reduction!\n\n## Override Capability\nAllow users to set preferred interval (future feature):\n```sql\nALTER TABLE subscriptions ADD COLUMN user_poll_interval_seconds INTEGER;\n```\n\nIf set, use max(user_poll_interval_seconds, adaptive_interval) to prevent excessive polling.\n\n## Files to Create/Modify\n- apps/worker/src/polling/adaptive.ts - New file\n- apps/worker/src/polling/scheduler.ts - Integration\n\n## Dependencies\n- zine-teq.19 (polling cron)\n- zine-teq.3 (subscription_items table)\n\n## Acceptance Criteria\n- [ ] Activity metrics calculated from subscription_items\n- [ ] Interval tiers applied correctly\n- [ ] Updates only on significant changes (50%+ difference)\n- [ ] Adjustment happens periodically (not every poll)\n- [ ] Unit tests for each activity tier\n- [ ] Integration test verifies interval changes","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:14:28.786412-06:00","updated_at":"2025-12-17T19:36:16.988635-06:00","closed_at":"2025-12-17T19:36:16.988635-06:00","dependencies":[{"issue_id":"zine-teq.20","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:14:28.786813-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.20","depends_on_id":"zine-teq.19","type":"blocks","created_at":"2025-12-16T22:19:51.224296-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.20","depends_on_id":"zine-teq.3","type":"blocks","created_at":"2025-12-16T22:19:51.272861-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.21","title":"YouTube: Quota tracking and graceful degradation","description":"Implemented YouTube quota tracking with all acceptance criteria met","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:14:59.36417-06:00","updated_at":"2025-12-17T19:08:32.861656-06:00","closed_at":"2025-12-17T19:08:32.86166-06:00","dependencies":[{"issue_id":"zine-teq.21","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:14:59.364577-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.21","depends_on_id":"zine-teq.10","type":"blocks","created_at":"2025-12-16T22:19:54.825851-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.21","depends_on_id":"zine-teq.19","type":"blocks","created_at":"2025-12-16T22:19:54.87434-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.22","title":"Rate Limiting: Provider-aware fetch with backoff","description":"Implement a rate-limited fetcher with exponential backoff that respects provider-specific limits.\n\n## Provider Rate Limits\n\n### YouTube\n- No official rate limit (quota-based instead)\n- Retry on 403 with 'quotaExceeded' error\n- Back off on 429 (rare)\n\n### Spotify  \n- Rolling 30-second window\n- ~100-180 requests per 30s depending on endpoint\n- Returns 429 with Retry-After header\n\n## Implementation\n\n### Rate Limited Fetcher\n```typescript\n// apps/worker/src/lib/rate-limiter.ts\n\ninterface RateLimitState {\n  retryAfter: number | null; // Unix timestamp when we can retry\n  consecutiveFailures: number;\n  lastRequest: number;\n}\n\nexport class RateLimitedFetcher {\n  private state: Map\u003cstring, RateLimitState\u003e = new Map();\n  \n  constructor(private kv: KVNamespace) {}\n  \n  async fetch(\n    provider: Provider,\n    userId: string,\n    fn: () =\u003e Promise\u003cResponse\u003e\n  ): Promise\u003cResponse\u003e {\n    const key = `rate:${provider}:${userId}`;\n    \n    // 1. Check if we're rate limited\n    const state = await this.getState(key);\n    if (state.retryAfter \u0026\u0026 Date.now() \u003c state.retryAfter) {\n      const waitMs = state.retryAfter - Date.now();\n      throw new RateLimitError(provider, waitMs);\n    }\n    \n    // 2. Execute request\n    try {\n      const response = await fn();\n      \n      // 3. Handle rate limit response\n      if (response.status === 429) {\n        const retryAfter = this.parseRetryAfter(response);\n        await this.setRateLimited(key, retryAfter);\n        throw new RateLimitError(provider, retryAfter - Date.now());\n      }\n      \n      // 4. Clear failure count on success\n      await this.clearState(key);\n      return response;\n      \n    } catch (error) {\n      if (error instanceof RateLimitError) throw error;\n      \n      // 5. Exponential backoff on other errors\n      const newState = await this.incrementFailures(key);\n      const backoffMs = this.calculateBackoff(newState.consecutiveFailures);\n      \n      console.warn(`Request failed, backing off ${backoffMs}ms`, error);\n      throw error;\n    }\n  }\n  \n  private parseRetryAfter(response: Response): number {\n    const header = response.headers.get('Retry-After');\n    if (header) {\n      // Could be seconds or HTTP date\n      const seconds = parseInt(header, 10);\n      if (!isNaN(seconds)) {\n        return Date.now() + seconds * 1000;\n      }\n      // Try parsing as date\n      const date = new Date(header).getTime();\n      if (!isNaN(date)) {\n        return date;\n      }\n    }\n    // Default: 30 seconds\n    return Date.now() + 30 * 1000;\n  }\n  \n  private calculateBackoff(failures: number): number {\n    // Exponential backoff with jitter: 2^n * 1000ms + random 0-1000ms\n    const base = Math.min(Math.pow(2, failures) * 1000, 300000); // Max 5 min\n    const jitter = Math.random() * 1000;\n    return base + jitter;\n  }\n  \n  private async getState(key: string): Promise\u003cRateLimitState\u003e {\n    const cached = this.state.get(key);\n    if (cached) return cached;\n    \n    const stored = await this.kv.get(key);\n    const state = stored \n      ? JSON.parse(stored) \n      : { retryAfter: null, consecutiveFailures: 0, lastRequest: 0 };\n    \n    this.state.set(key, state);\n    return state;\n  }\n  \n  private async setRateLimited(key: string, retryAfter: number): Promise\u003cvoid\u003e {\n    const state = await this.getState(key);\n    state.retryAfter = retryAfter;\n    state.consecutiveFailures++;\n    this.state.set(key, state);\n    \n    const ttl = Math.ceil((retryAfter - Date.now()) / 1000) + 60;\n    await this.kv.put(key, JSON.stringify(state), { expirationTtl: ttl });\n  }\n  \n  private async incrementFailures(key: string): Promise\u003cRateLimitState\u003e {\n    const state = await this.getState(key);\n    state.consecutiveFailures++;\n    state.lastRequest = Date.now();\n    this.state.set(key, state);\n    \n    await this.kv.put(key, JSON.stringify(state), { expirationTtl: 3600 });\n    return state;\n  }\n  \n  private async clearState(key: string): Promise\u003cvoid\u003e {\n    this.state.delete(key);\n    await this.kv.delete(key);\n  }\n}\n\nexport class RateLimitError extends Error {\n  constructor(\n    public provider: Provider,\n    public retryInMs: number\n  ) {\n    super(`Rate limited by ${provider}, retry in ${Math.ceil(retryInMs / 1000)}s`);\n    this.name = 'RateLimitError';\n  }\n}\n```\n\n### Pre-emptive Rate Limit Check\n```typescript\nexport async function isRateLimited(\n  provider: Provider,\n  userId: string,\n  kv: KVNamespace\n): Promise\u003c{ limited: boolean; retryInMs?: number }\u003e {\n  const key = `rate:${provider}:${userId}`;\n  const stored = await kv.get(key);\n  \n  if (!stored) return { limited: false };\n  \n  const state: RateLimitState = JSON.parse(stored);\n  if (!state.retryAfter || Date.now() \u003e= state.retryAfter) {\n    return { limited: false };\n  }\n  \n  return { \n    limited: true, \n    retryInMs: state.retryAfter - Date.now() \n  };\n}\n```\n\n### Integration with Polling\n```typescript\n// In polling/scheduler.ts\nasync function pollSingleSubscription(\n  subscription: Subscription,\n  connection: ProviderConnection,\n  env: Env\n): Promise\u003cPollResult\u003e {\n  // Check rate limit before attempting\n  const rateCheck = await isRateLimited(\n    subscription.provider, \n    subscription.userId, \n    env.KV\n  );\n  \n  if (rateCheck.limited) {\n    console.log(`Skipping ${subscription.id}: rate limited for ${rateCheck.retryInMs}ms`);\n    return { skipped: true, reason: 'rate_limited' };\n  }\n  \n  // Proceed with poll...\n}\n```\n\n## Backoff Schedule\n| Consecutive Failures | Backoff |\n|---------------------|---------|\n| 1 | 2s + jitter |\n| 2 | 4s + jitter |\n| 3 | 8s + jitter |\n| 4 | 16s + jitter |\n| 5+ | 32s + jitter (capped) |\n\n## Files to Create\n- apps/worker/src/lib/rate-limiter.ts\n\n## Dependencies\n- zine-teq.26 (Wrangler config with KV namespace)\n\n## Acceptance Criteria\n- [ ] Respects Retry-After header from providers\n- [ ] Exponential backoff on repeated failures\n- [ ] Jitter prevents thundering herd\n- [ ] Pre-emptive check skips rate-limited requests\n- [ ] State persisted in KV for cross-worker consistency\n- [ ] Unit tests cover all backoff scenarios","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:15:25.84527-06:00","updated_at":"2025-12-17T19:05:03.413455-06:00","closed_at":"2025-12-17T19:05:03.413455-06:00","dependencies":[{"issue_id":"zine-teq.22","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:15:25.845662-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.22","depends_on_id":"zine-teq.7","type":"blocks","created_at":"2025-12-16T22:19:58.235193-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.23","title":"YouTube: PubSubHubbub push notifications (optional)","description":"Implement YouTube PubSubHubbub integration for real-time notifications as an alternative to polling.\n\n## Overview\nYouTube supports WebSub (PubSubHubbub) for push notifications when channels publish new videos. Benefits:\n- **Zero quota cost** (notifications pushed, not pulled)\n- **Near real-time** (seconds vs hours with polling)\n- **Scales infinitely** (no per-subscription API calls)\n\n## Architecture\n\n### Subscription Flow\n1. When user subscribes to a channel, register with PubSubHubbub hub\n2. Hub verifies our callback URL (GET request with challenge)\n3. Hub pushes notifications to callback when channel posts (POST with Atom feed)\n4. We process notification and ingest items\n\n### Lease Management\n- Leases last up to 432,000 seconds (5 days)\n- Must renew before expiry\n- Store lease expiry in subscriptions table\n\n## Implementation\n\n### Hub Registration\n```typescript\n// apps/worker/src/providers/youtube-push.ts\n\nconst HUB_URL = 'https://pubsubhubbub.appspot.com/subscribe';\n\nexport async function subscribeToYouTubeChannel(\n  channelId: string,\n  env: Env\n): Promise\u003cvoid\u003e {\n  const callbackUrl = `${env.BASE_URL}/webhooks/youtube?channel=${channelId}`;\n  const topicUrl = `https://www.youtube.com/xml/feeds/videos.xml?channel_id=${channelId}`;\n  \n  const response = await fetch(HUB_URL, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      'hub.callback': callbackUrl,\n      'hub.topic': topicUrl,\n      'hub.mode': 'subscribe',\n      'hub.lease_seconds': '432000', // 5 days\n      'hub.verify': 'async',\n    }),\n  });\n  \n  if (!response.ok) {\n    throw new PushSubscriptionError(`Hub returned ${response.status}`);\n  }\n}\n\nexport async function unsubscribeFromYouTubeChannel(\n  channelId: string,\n  env: Env\n): Promise\u003cvoid\u003e {\n  const callbackUrl = `${env.BASE_URL}/webhooks/youtube?channel=${channelId}`;\n  const topicUrl = `https://www.youtube.com/xml/feeds/videos.xml?channel_id=${channelId}`;\n  \n  await fetch(HUB_URL, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      'hub.callback': callbackUrl,\n      'hub.topic': topicUrl,\n      'hub.mode': 'unsubscribe',\n    }),\n  });\n}\n```\n\n### Webhook Handler\n```typescript\n// apps/worker/src/routes/webhooks.ts\n\nexport async function handleYouTubeWebhook(\n  request: Request,\n  env: Env\n): Promise\u003cResponse\u003e {\n  const url = new URL(request.url);\n  const channelId = url.searchParams.get('channel');\n  \n  if (!channelId) {\n    return new Response('Missing channel', { status: 400 });\n  }\n  \n  // Hub verification (GET request with challenge)\n  if (request.method === 'GET') {\n    const challenge = url.searchParams.get('hub.challenge');\n    const mode = url.searchParams.get('hub.mode');\n    \n    if (mode === 'subscribe' \u0026\u0026 challenge) {\n      console.log(`Verified push subscription for channel ${channelId}`);\n      return new Response(challenge, { status: 200 });\n    }\n    \n    return new Response('Invalid verification', { status: 400 });\n  }\n  \n  // Notification (POST with Atom feed)\n  if (request.method === 'POST') {\n    const body = await request.text();\n    await processYouTubeNotification(channelId, body, env);\n    return new Response('OK', { status: 200 });\n  }\n  \n  return new Response('Method not allowed', { status: 405 });\n}\n```\n\n### Notification Processing\n```typescript\nexport async function processYouTubeNotification(\n  channelId: string,\n  atomXml: string,\n  env: Env\n): Promise\u003cvoid\u003e {\n  // Parse Atom feed to extract video details\n  const videos = parseAtomFeed(atomXml);\n  \n  if (videos.length === 0) {\n    console.log(`Push notification for ${channelId} contained no videos`);\n    return;\n  }\n  \n  // Find all subscriptions for this channel\n  const subs = await db.query.subscriptions.findMany({\n    where: and(\n      eq(subscriptions.provider, 'YOUTUBE'),\n      eq(subscriptions.providerChannelId, channelId),\n      eq(subscriptions.status, 'ACTIVE')\n    ),\n  });\n  \n  // Ingest for each user (respecting idempotency)\n  for (const sub of subs) {\n    for (const video of videos) {\n      await ingestItem(\n        sub.userId,\n        sub.id,\n        video,\n        'YOUTUBE',\n        db,\n        transformYouTubeVideoFromAtom\n      );\n    }\n    \n    // Update lastPolledAt to prevent redundant polling\n    await db.update(subscriptions)\n      .set({ lastPolledAt: Date.now() })\n      .where(eq(subscriptions.id, sub.id));\n  }\n}\n```\n\n### Lease Renewal Cron\n```toml\n# wrangler.toml\n[triggers]\ncrons = [\n  \"*/15 * * * *\",   # Poll subscriptions\n  \"0 4 * * *\",      # Renew push leases daily at 4 AM\n]\n```\n\n```typescript\nexport async function renewPushLeases(env: Env): Promise\u003cvoid\u003e {\n  const expiringWithin = 2 * 24 * 3600 * 1000; // 2 days\n  const now = Date.now();\n  \n  // Find subscriptions with expiring leases\n  const expiring = await db.query.subscriptions.findMany({\n    where: and(\n      eq(subscriptions.provider, 'YOUTUBE'),\n      eq(subscriptions.status, 'ACTIVE'),\n      lt(subscriptions.pushLeaseExpiresAt, now + expiringWithin)\n    ),\n    columns: { providerChannelId: true },\n  });\n  \n  // Get unique channels\n  const channels = [...new Set(expiring.map(s =\u003e s.providerChannelId))];\n  \n  for (const channelId of channels) {\n    try {\n      await subscribeToYouTubeChannel(channelId, env);\n      await db.update(subscriptions)\n        .set({ pushLeaseExpiresAt: now + 5 * 24 * 3600 * 1000 })\n        .where(and(\n          eq(subscriptions.provider, 'YOUTUBE'),\n          eq(subscriptions.providerChannelId, channelId)\n        ));\n    } catch (e) {\n      console.error(`Failed to renew lease for ${channelId}:`, e);\n    }\n  }\n}\n```\n\n## Schema Addition\n```sql\nALTER TABLE subscriptions \nADD COLUMN push_lease_expires_at INTEGER;\n```\n\n## Hybrid Approach\nUse push as primary, polling as fallback:\n- Register push subscription on channel add\n- If push lease expires or fails, fall back to polling\n- Polling cron skips channels with active push subscriptions\n\n## Considerations\n- Requires publicly accessible callback URL\n- Notifications can be delayed (usually \u003c1 min)\n- Some notifications may be duplicate (idempotency handles this)\n- Not all YouTube events trigger notifications\n\n## Files to Create/Modify\n- apps/worker/src/providers/youtube-push.ts - Push subscription logic\n- apps/worker/src/routes/webhooks.ts - Webhook handler\n- apps/worker/src/polling/scheduler.ts - Skip push-enabled subscriptions\n- apps/worker/wrangler.toml - Add lease renewal cron\n\n## Dependencies\n- zine-teq.17 (ingestion pipeline)\n- zine-teq.19 (polling cron integration)\n- zine-teq.2 (subscriptions table - may need migration)\n\n## Acceptance Criteria\n- [ ] Push subscription registered on channel add\n- [ ] Webhook verifies hub challenges\n- [ ] Notifications trigger ingestion\n- [ ] Lease renewal cron runs daily\n- [ ] Polling skips channels with active push\n- [ ] Fallback to polling on push failure\n- [ ] Integration tests with mock hub","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:15:57.711947-06:00","updated_at":"2025-12-17T19:53:07.363827-06:00","closed_at":"2025-12-17T19:53:07.363827-06:00","dependencies":[{"issue_id":"zine-teq.23","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:15:57.712342-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.23","depends_on_id":"zine-teq.17","type":"blocks","created_at":"2025-12-16T22:20:02.352111-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.23","depends_on_id":"zine-teq.19","type":"blocks","created_at":"2025-12-16T22:20:02.40378-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.23","depends_on_id":"zine-teq.2","type":"blocks","created_at":"2025-12-16T22:20:02.4517-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.24","title":"Security: Encryption key rotation support","description":"Implement encryption key rotation to support periodic key changes without downtime.\n\n## Why Key Rotation\n- Security best practice: limit exposure if key is compromised\n- Compliance requirements may mandate periodic rotation\n- Ability to respond to key leaks without emergency\n\n## Versioned Ciphertext Format\nCurrent format: `{iv}:{ciphertext}`\nNew format: `v{version}:{iv}:{ciphertext}`\n\nVersion allows decryption with correct key even during transition.\n\n## Implementation\n\n### Multi-Key Decryption\n```typescript\n// apps/worker/src/lib/crypto.ts\n\ninterface EncryptionKeys {\n  current: { version: number; keyHex: string };\n  previous?: { version: number; keyHex: string };\n}\n\nexport async function encryptWithVersion(\n  plaintext: string,\n  keys: EncryptionKeys\n): Promise\u003cstring\u003e {\n  const key = await importKey(keys.current.keyHex);\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const encoded = new TextEncoder().encode(plaintext);\n  \n  const ciphertext = await crypto.subtle.encrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    encoded\n  );\n  \n  return `v${keys.current.version}:${bytesToHex(iv)}:${bytesToHex(new Uint8Array(ciphertext))}`;\n}\n\nexport async function decryptWithVersion(\n  encrypted: string,\n  keys: EncryptionKeys\n): Promise\u003cstring\u003e {\n  // Handle legacy format (no version prefix)\n  if (!encrypted.startsWith('v')) {\n    // Assume version 1 or try current key\n    return decryptLegacy(encrypted, keys.current.keyHex);\n  }\n  \n  const [versionPart, ivHex, ciphertextHex] = encrypted.split(':');\n  const version = parseInt(versionPart.slice(1), 10);\n  \n  // Select appropriate key\n  let keyHex: string;\n  if (version === keys.current.version) {\n    keyHex = keys.current.keyHex;\n  } else if (keys.previous \u0026\u0026 version === keys.previous.version) {\n    keyHex = keys.previous.keyHex;\n  } else {\n    throw new CryptoError('KEY_VERSION_NOT_FOUND', `Unknown key version: ${version}`);\n  }\n  \n  const key = await importKey(keyHex);\n  const iv = hexToBytes(ivHex);\n  const ciphertext = hexToBytes(ciphertextHex);\n  \n  try {\n    const decrypted = await crypto.subtle.decrypt(\n      { name: 'AES-GCM', iv },\n      key,\n      ciphertext\n    );\n    return new TextDecoder().decode(decrypted);\n  } catch (e) {\n    throw new CryptoError('DECRYPTION_FAILED', 'Failed to decrypt');\n  }\n}\n```\n\n### Environment Configuration\n```typescript\n// Keys from environment\nfunction getEncryptionKeys(env: Env): EncryptionKeys {\n  return {\n    current: {\n      version: parseInt(env.ENCRYPTION_KEY_VERSION || '1', 10),\n      keyHex: env.ENCRYPTION_KEY,\n    },\n    previous: env.ENCRYPTION_KEY_PREVIOUS ? {\n      version: parseInt(env.ENCRYPTION_KEY_VERSION_PREVIOUS || '0', 10),\n      keyHex: env.ENCRYPTION_KEY_PREVIOUS,\n    } : undefined,\n  };\n}\n```\n\n### Migration Job\nRe-encrypt all tokens with the new key:\n\n```typescript\n// apps/worker/src/jobs/rotate-keys.ts\n\nexport async function migrateEncryptionKeys(\n  env: Env,\n  batchSize = 100\n): Promise\u003cMigrationResult\u003e {\n  const keys = getEncryptionKeys(env);\n  let migrated = 0;\n  let failed = 0;\n  \n  // Process in batches to avoid timeout\n  let cursor: string | null = null;\n  \n  while (true) {\n    const connections = await db.query.providerConnections.findMany({\n      where: cursor ? gt(providerConnections.id, cursor) : undefined,\n      orderBy: [asc(providerConnections.id)],\n      limit: batchSize,\n    });\n    \n    if (connections.length === 0) break;\n    \n    for (const conn of connections) {\n      try {\n        // Check if already on current version\n        if (conn.accessToken.startsWith(`v${keys.current.version}:`)) {\n          continue;\n        }\n        \n        // Decrypt with any available key\n        const accessToken = await decryptWithVersion(conn.accessToken, keys);\n        const refreshToken = await decryptWithVersion(conn.refreshToken, keys);\n        \n        // Re-encrypt with current key\n        const newAccessToken = await encryptWithVersion(accessToken, keys);\n        const newRefreshToken = await encryptWithVersion(refreshToken, keys);\n        \n        await db.update(providerConnections)\n          .set({\n            accessToken: newAccessToken,\n            refreshToken: newRefreshToken,\n          })\n          .where(eq(providerConnections.id, conn.id));\n        \n        migrated++;\n      } catch (e) {\n        console.error(`Failed to migrate ${conn.id}:`, e);\n        failed++;\n      }\n    }\n    \n    cursor = connections[connections.length - 1].id;\n  }\n  \n  return { migrated, failed };\n}\n```\n\n## Rotation Procedure\n1. Generate new key: `openssl rand -hex 32`\n2. Deploy with both keys:\n   - `ENCRYPTION_KEY` = new key\n   - `ENCRYPTION_KEY_VERSION` = 2\n   - `ENCRYPTION_KEY_PREVIOUS` = old key  \n   - `ENCRYPTION_KEY_VERSION_PREVIOUS` = 1\n3. New encryptions use v2\n4. Run migration job to re-encrypt existing tokens\n5. Verify migration: no v1 tokens remain\n6. Remove `ENCRYPTION_KEY_PREVIOUS` after grace period (1 week)\n\n## Error Recovery\n| Scenario | Action |\n|----------|--------|\n| Migration fails mid-way | Re-run (idempotent) |\n| Key leak during rotation | Complete rotation, revoke old key |\n| Decryption fails | Mark connection EXPIRED, user re-auths |\n\n## Files to Modify\n- apps/worker/src/lib/crypto.ts - Versioned encryption\n- apps/worker/src/jobs/rotate-keys.ts - Migration job\n- apps/worker/worker-configuration.d.ts - New env vars\n\n## Dependencies\n- zine-teq.6 (base encryption utilities)\n- zine-teq.1 (provider_connections table)\n\n## Acceptance Criteria\n- [ ] Versioned ciphertext format implemented\n- [ ] Decryption works with current and previous keys\n- [ ] Legacy format handled gracefully\n- [ ] Migration job re-encrypts all tokens\n- [ ] Migration is idempotent\n- [ ] Unknown version throws descriptive error\n- [ ] Integration tests cover rotation scenario","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:16:24.520201-06:00","updated_at":"2025-12-17T19:42:26.238366-06:00","closed_at":"2025-12-17T19:42:26.238366-06:00","dependencies":[{"issue_id":"zine-teq.24","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:16:24.520598-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.24","depends_on_id":"zine-teq.6","type":"blocks","created_at":"2025-12-16T22:20:07.036504-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.24","depends_on_id":"zine-teq.1","type":"blocks","created_at":"2025-12-16T22:20:07.086448-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.25","title":"Connection Health: Status monitoring and recovery","description":"Implemented connection health monitoring with automatic status transitions and user notifications. Created apps/worker/src/polling/health.ts with all required functionality.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:16:55.641081-06:00","updated_at":"2025-12-17T19:12:03.085916-06:00","closed_at":"2025-12-17T19:12:03.085921-06:00","dependencies":[{"issue_id":"zine-teq.25","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:16:55.641482-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.25","depends_on_id":"zine-teq.9","type":"blocks","created_at":"2025-12-16T22:20:14.170323-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.25","depends_on_id":"zine-teq.19","type":"blocks","created_at":"2025-12-16T22:20:14.21961-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.26","title":"Wrangler Configuration: Cron triggers and secrets","description":"Configure wrangler.toml with all required cron triggers, KV namespaces, secrets, and environment variables.\n\n## Cron Triggers\n```toml\n# wrangler.toml\n\n[triggers]\ncrons = [\n  \"*/15 * * * *\",   # Poll subscriptions every 15 minutes\n  \"0 4 * * *\",      # Renew YouTube push leases daily at 4 AM\n  \"0 */6 * * *\",    # YouTube fallback polling every 6 hours (for push failures)\n  \"0 3 * * 0\"       # Cleanup job Sundays at 3 AM UTC\n]\n```\n\n## KV Namespaces\n```toml\n[[kv_namespaces]]\nbinding = \"KV\"\nid = \"\u003ccreate-with-wrangler\u003e\"\npreview_id = \"\u003ccreate-for-preview\u003e\"\n```\n\nUsed for:\n- OAuth state storage (`oauth:state:{state}`)\n- Distributed locks (`cron:poll-subscriptions:lock`)\n- Token refresh locks (`token:refresh:{connectionId}`)\n- Rate limit state (`rate:{provider}:{userId}`)\n- YouTube quota tracking (`youtube:quota:{date}`)\n- Poll failure counts (`poll:failures:{subscriptionId}`)\n- Manual sync rate limiting (`manual-sync:{subscriptionId}`)\n\n## Queue Configuration (Optional for webhooks)\n```toml\n[[queues.producers]]\nqueue = \"youtube-notifications\"\nbinding = \"YOUTUBE_QUEUE\"\n\n[[queues.consumers]]\nqueue = \"youtube-notifications\"\nmax_batch_size = 10\nmax_retries = 3\n```\n\n## Environment Variables\n```toml\n[vars]\n# Base URL for callbacks\nBASE_URL = \"https://api.zine.app\"\n\n# OAuth redirect URIs\nYOUTUBE_REDIRECT_URI = \"zine://auth/youtube/callback\"\nSPOTIFY_REDIRECT_URI = \"zine://auth/spotify/callback\"\n\n# Polling configuration\nPOLL_BATCH_SIZE = \"50\"\nPOLL_LOCK_TTL_SECONDS = \"900\"\n\n# Feature flags\nENABLE_YOUTUBE_PUSH = \"false\"  # Enable when ready\n```\n\n## Secrets (via wrangler secret put)\nRequired secrets:\n```bash\n# OAuth credentials\nwrangler secret put YOUTUBE_CLIENT_ID\nwrangler secret put YOUTUBE_CLIENT_SECRET\nwrangler secret put SPOTIFY_CLIENT_ID\nwrangler secret put SPOTIFY_CLIENT_SECRET\n\n# Encryption\nwrangler secret put ENCRYPTION_KEY           # 64 hex chars (256 bits)\nwrangler secret put ENCRYPTION_KEY_VERSION   # e.g., \"1\"\n\n# For key rotation (optional, add when rotating)\nwrangler secret put ENCRYPTION_KEY_PREVIOUS\nwrangler secret put ENCRYPTION_KEY_VERSION_PREVIOUS\n```\n\n## TypeScript Environment Types\n```typescript\n// apps/worker/worker-configuration.d.ts\n\ninterface Env {\n  // Database\n  DB: D1Database;\n  \n  // KV Namespace\n  KV: KVNamespace;\n  \n  // Queues (optional)\n  YOUTUBE_QUEUE?: Queue;\n  \n  // Environment variables\n  BASE_URL: string;\n  YOUTUBE_REDIRECT_URI: string;\n  SPOTIFY_REDIRECT_URI: string;\n  POLL_BATCH_SIZE: string;\n  POLL_LOCK_TTL_SECONDS: string;\n  ENABLE_YOUTUBE_PUSH: string;\n  \n  // Secrets\n  YOUTUBE_CLIENT_ID: string;\n  YOUTUBE_CLIENT_SECRET: string;\n  SPOTIFY_CLIENT_ID: string;\n  SPOTIFY_CLIENT_SECRET: string;\n  ENCRYPTION_KEY: string;\n  ENCRYPTION_KEY_VERSION: string;\n  ENCRYPTION_KEY_PREVIOUS?: string;\n  ENCRYPTION_KEY_VERSION_PREVIOUS?: string;\n}\n```\n\n## Scheduled Handler\n```typescript\n// apps/worker/src/index.ts\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise\u003cResponse\u003e {\n    // ... existing fetch handler ...\n  },\n  \n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise\u003cvoid\u003e {\n    switch (event.cron) {\n      case '*/15 * * * *':\n        await pollSubscriptions(env, ctx);\n        break;\n      case '0 4 * * *':\n        await renewPushLeases(env, ctx);\n        break;\n      case '0 */6 * * *':\n        await fallbackYouTubePolling(env, ctx);\n        break;\n      case '0 3 * * 0':\n        await cleanupJob(env, ctx);\n        break;\n    }\n  },\n  \n  async queue(batch: MessageBatch, env: Env): Promise\u003cvoid\u003e {\n    // Handle YouTube push notification queue\n    for (const message of batch.messages) {\n      await processYouTubeNotification(message.body, env);\n      message.ack();\n    }\n  },\n};\n```\n\n## Cleanup Job\n```typescript\n// apps/worker/src/jobs/cleanup.ts\n\nexport async function cleanupJob(env: Env, ctx: ExecutionContext): Promise\u003cvoid\u003e {\n  // 1. Clean up old provider_items_seen (optional, for storage management)\n  // Keep for re-subscribe prevention, but could archive very old records\n  \n  // 2. Clean up orphaned subscription_items\n  await db.delete(subscriptionItems)\n    .where(notExists(\n      db.select()\n        .from(subscriptions)\n        .where(eq(subscriptions.id, subscriptionItems.subscriptionId))\n    ));\n  \n  // 3. Expire old notifications\n  const thirtyDaysAgo = Date.now() - 30 * 24 * 3600 * 1000;\n  await db.delete(userNotifications)\n    .where(lt(userNotifications.createdAt, thirtyDaysAgo));\n}\n```\n\n## Files to Modify\n- apps/worker/wrangler.toml - Full configuration\n- apps/worker/worker-configuration.d.ts - TypeScript types\n- apps/worker/src/index.ts - Add scheduled handler\n\n## KV Namespace Creation Commands\n```bash\n# Create production namespace\nwrangler kv:namespace create \"KV\"\n\n# Create preview namespace\nwrangler kv:namespace create \"KV\" --preview\n```\n\n## Dependencies\nNone - this is foundational configuration\n\n## Acceptance Criteria\n- [ ] All cron triggers configured\n- [ ] KV namespace created and bound\n- [ ] All secrets documented and added\n- [ ] TypeScript Env type complete\n- [ ] Scheduled handler routes to correct functions\n- [ ] Preview environment works locally\n- [ ] Production deployment succeeds","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:17:23.603563-06:00","updated_at":"2025-12-17T19:42:24.639395-06:00","closed_at":"2025-12-17T19:42:24.639395-06:00","dependencies":[{"issue_id":"zine-teq.26","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:17:23.603939-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.27","title":"Testing: Unit tests for crypto, transformers, and ingestion","description":"Write comprehensive unit tests for the core utility modules.\n\n## Test Structure\n```\napps/worker/src/\n├── lib/\n│   ├── crypto.test.ts\n│   ├── rate-limiter.test.ts\n│   └── locks.test.ts\n├── ingestion/\n│   ├── transformers.test.ts\n│   └── processor.test.ts\n├── providers/\n│   ├── youtube.test.ts\n│   └── spotify.test.ts\n└── polling/\n    └── adaptive.test.ts\n```\n\n## Crypto Tests\n```typescript\n// apps/worker/src/lib/crypto.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { encrypt, decrypt, encryptWithVersion, decryptWithVersion, CryptoError } from './crypto';\n\ndescribe('crypto', () =\u003e {\n  const validKey = 'a'.repeat(64); // 256-bit key in hex\n  const invalidKey = 'short';\n  \n  describe('encrypt/decrypt', () =\u003e {\n    it('should round-trip encrypt and decrypt', async () =\u003e {\n      const plaintext = 'my secret token';\n      const encrypted = await encrypt(plaintext, validKey);\n      const decrypted = await decrypt(encrypted, validKey);\n      expect(decrypted).toBe(plaintext);\n    });\n    \n    it('should produce different ciphertext each time (random IV)', async () =\u003e {\n      const plaintext = 'test';\n      const e1 = await encrypt(plaintext, validKey);\n      const e2 = await encrypt(plaintext, validKey);\n      expect(e1).not.toBe(e2);\n    });\n    \n    it('should throw on invalid key length', async () =\u003e {\n      await expect(encrypt('test', invalidKey))\n        .rejects.toThrow(CryptoError);\n    });\n    \n    it('should throw on wrong decryption key', async () =\u003e {\n      const encrypted = await encrypt('test', validKey);\n      const wrongKey = 'b'.repeat(64);\n      await expect(decrypt(encrypted, wrongKey))\n        .rejects.toThrow('DECRYPTION_FAILED');\n    });\n    \n    it('should throw on tampered ciphertext', async () =\u003e {\n      const encrypted = await encrypt('test', validKey);\n      const tampered = encrypted.slice(0, -2) + 'xx';\n      await expect(decrypt(tampered, validKey))\n        .rejects.toThrow('DECRYPTION_FAILED');\n    });\n  });\n  \n  describe('versioned encryption', () =\u003e {\n    const keys = {\n      current: { version: 2, keyHex: validKey },\n      previous: { version: 1, keyHex: 'b'.repeat(64) },\n    };\n    \n    it('should encrypt with version prefix', async () =\u003e {\n      const encrypted = await encryptWithVersion('test', keys);\n      expect(encrypted).toMatch(/^v2:/);\n    });\n    \n    it('should decrypt current version', async () =\u003e {\n      const encrypted = await encryptWithVersion('test', keys);\n      const decrypted = await decryptWithVersion(encrypted, keys);\n      expect(decrypted).toBe('test');\n    });\n    \n    it('should decrypt previous version', async () =\u003e {\n      const oldKeys = { current: keys.previous! };\n      const encrypted = await encryptWithVersion('test', oldKeys);\n      const decrypted = await decryptWithVersion(encrypted, keys);\n      expect(decrypted).toBe('test');\n    });\n    \n    it('should throw on unknown version', async () =\u003e {\n      const encrypted = 'v99:abc:def';\n      await expect(decryptWithVersion(encrypted, keys))\n        .rejects.toThrow('KEY_VERSION_NOT_FOUND');\n    });\n  });\n});\n```\n\n## Transformer Tests\n```typescript\n// apps/worker/src/ingestion/transformers.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { \n  transformYouTubeVideo, \n  transformSpotifyEpisode,\n  TransformError \n} from './transformers';\n\ndescribe('transformers', () =\u003e {\n  describe('transformYouTubeVideo', () =\u003e {\n    const validVideo = {\n      contentDetails: { videoId: 'abc123' },\n      snippet: {\n        title: 'Test Video',\n        channelTitle: 'Test Channel',\n        channelId: 'UCabc123',\n        publishedAt: '2024-01-15T10:00:00Z',\n        thumbnails: { high: { url: 'https://example.com/thumb.jpg' } },\n      },\n    };\n    \n    it('should transform valid video', () =\u003e {\n      const item = transformYouTubeVideo(validVideo);\n      expect(item.providerId).toBe('abc123');\n      expect(item.title).toBe('Test Video');\n      expect(item.creator).toBe('Test Channel');\n      expect(item.contentType).toBe('VIDEO');\n      expect(item.provider).toBe('YOUTUBE');\n      expect(item.canonicalUrl).toBe('https://www.youtube.com/watch?v=abc123');\n    });\n    \n    it('should throw on missing videoId', () =\u003e {\n      expect(() =\u003e transformYouTubeVideo({ contentDetails: {} }))\n        .toThrow(TransformError);\n    });\n    \n    it('should handle missing optional fields', () =\u003e {\n      const minimal = { contentDetails: { videoId: 'xyz' } };\n      const item = transformYouTubeVideo(minimal);\n      expect(item.title).toBe('Untitled');\n      expect(item.creator).toBe('Unknown');\n    });\n  });\n  \n  describe('transformSpotifyEpisode', () =\u003e {\n    const validEpisode = {\n      id: 'spotify123',\n      name: 'Episode 1',\n      description: 'Description',\n      release_date: '2024-01-15',\n      duration_ms: 3600000,\n      external_urls: { spotify: 'https://spotify.com/episode/123' },\n      images: [{ url: 'https://example.com/art.jpg' }],\n    };\n    \n    it('should transform valid episode', () =\u003e {\n      const item = transformSpotifyEpisode(validEpisode, 'Test Show');\n      expect(item.providerId).toBe('spotify123');\n      expect(item.title).toBe('Episode 1');\n      expect(item.creator).toBe('Test Show');\n      expect(item.durationSeconds).toBe(3600);\n      expect(item.contentType).toBe('PODCAST');\n    });\n    \n    it('should parse YYYY-MM-DD date', () =\u003e {\n      const item = transformSpotifyEpisode(validEpisode, 'Show');\n      expect(item.publishedAt).toBe(new Date('2024-01-15T00:00:00Z').getTime());\n    });\n    \n    it('should parse YYYY-MM date', () =\u003e {\n      const episode = { ...validEpisode, release_date: '2024-01' };\n      const item = transformSpotifyEpisode(episode, 'Show');\n      expect(item.publishedAt).toBe(new Date('2024-01-01T00:00:00Z').getTime());\n    });\n    \n    it('should parse YYYY date', () =\u003e {\n      const episode = { ...validEpisode, release_date: '2024' };\n      const item = transformSpotifyEpisode(episode, 'Show');\n      expect(item.publishedAt).toBe(new Date('2024-01-01T00:00:00Z').getTime());\n    });\n  });\n});\n```\n\n## Adaptive Polling Tests\n```typescript\n// apps/worker/src/polling/adaptive.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { calculateOptimalInterval } from './adaptive';\n\ndescribe('adaptive polling', () =\u003e {\n  it('should return 1 hour for very active channels', () =\u003e {\n    const interval = calculateOptimalInterval({\n      itemsLast7Days: 10,\n      itemsLast30Days: 30,\n      daysSinceLastItem: 0,\n    });\n    expect(interval).toBe(3600);\n  });\n  \n  it('should return 4 hours for active channels', () =\u003e {\n    const interval = calculateOptimalInterval({\n      itemsLast7Days: 3,\n      itemsLast30Days: 10,\n      daysSinceLastItem: 2,\n    });\n    expect(interval).toBe(4 * 3600);\n  });\n  \n  it('should return 12 hours for moderate channels', () =\u003e {\n    const interval = calculateOptimalInterval({\n      itemsLast7Days: 0,\n      itemsLast30Days: 2,\n      daysSinceLastItem: 10,\n    });\n    expect(interval).toBe(12 * 3600);\n  });\n  \n  it('should return 24 hours for inactive channels', () =\u003e {\n    const interval = calculateOptimalInterval({\n      itemsLast7Days: 0,\n      itemsLast30Days: 0,\n      daysSinceLastItem: 45,\n    });\n    expect(interval).toBe(24 * 3600);\n  });\n});\n```\n\n## Rate Limiter Tests\n```typescript\n// apps/worker/src/lib/rate-limiter.test.ts\nimport { describe, it, expect, vi } from 'vitest';\nimport { RateLimitedFetcher, RateLimitError } from './rate-limiter';\n\ndescribe('rate limiter', () =\u003e {\n  const mockKV = {\n    get: vi.fn(),\n    put: vi.fn(),\n    delete: vi.fn(),\n  };\n  \n  it('should allow requests when not rate limited', async () =\u003e {\n    mockKV.get.mockResolvedValue(null);\n    const fetcher = new RateLimitedFetcher(mockKV as any);\n    \n    const response = new Response('OK', { status: 200 });\n    const result = await fetcher.fetch('YOUTUBE', 'user1', async () =\u003e response);\n    \n    expect(result.status).toBe(200);\n  });\n  \n  it('should block requests when rate limited', async () =\u003e {\n    mockKV.get.mockResolvedValue(JSON.stringify({\n      retryAfter: Date.now() + 10000,\n      consecutiveFailures: 1,\n    }));\n    \n    const fetcher = new RateLimitedFetcher(mockKV as any);\n    \n    await expect(fetcher.fetch('SPOTIFY', 'user1', async () =\u003e new Response()))\n      .rejects.toThrow(RateLimitError);\n  });\n  \n  it('should parse Retry-After header', async () =\u003e {\n    mockKV.get.mockResolvedValue(null);\n    const fetcher = new RateLimitedFetcher(mockKV as any);\n    \n    const response = new Response('', { \n      status: 429,\n      headers: { 'Retry-After': '60' },\n    });\n    \n    await expect(fetcher.fetch('SPOTIFY', 'user1', async () =\u003e response))\n      .rejects.toThrow(RateLimitError);\n    \n    expect(mockKV.put).toHaveBeenCalledWith(\n      expect.any(String),\n      expect.stringContaining('retryAfter'),\n      expect.any(Object)\n    );\n  });\n});\n```\n\n## Running Tests\n```bash\n# Run all tests\ncd apps/worker \u0026\u0026 npm test\n\n# Run specific test file\nnpm test -- crypto.test.ts\n\n# Run with coverage\nnpm test -- --coverage\n```\n\n## Files to Create\n- apps/worker/src/lib/crypto.test.ts\n- apps/worker/src/lib/rate-limiter.test.ts\n- apps/worker/src/lib/locks.test.ts\n- apps/worker/src/ingestion/transformers.test.ts\n- apps/worker/src/ingestion/processor.test.ts\n- apps/worker/src/polling/adaptive.test.ts\n\n## Dependencies\n- zine-teq.6 (crypto utilities)\n- zine-teq.16 (transformers)\n- zine-teq.17 (ingestion processor)\n- zine-teq.20 (adaptive polling)\n- zine-teq.22 (rate limiter)\n\n## Acceptance Criteria\n- [ ] All crypto functions have test coverage\n- [ ] Transformer edge cases covered\n- [ ] Adaptive polling tiers verified\n- [ ] Rate limiter backoff tested\n- [ ] Tests run in CI\n- [ ] Coverage \u003e 80% for tested modules","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:18:01.713885-06:00","updated_at":"2025-12-17T19:42:27.342146-06:00","closed_at":"2025-12-17T19:42:27.342146-06:00","dependencies":[{"issue_id":"zine-teq.27","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:18:01.714297-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.27","depends_on_id":"zine-teq.6","type":"blocks","created_at":"2025-12-16T22:20:18.786678-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.27","depends_on_id":"zine-teq.16","type":"blocks","created_at":"2025-12-16T22:20:18.834486-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.27","depends_on_id":"zine-teq.17","type":"blocks","created_at":"2025-12-16T22:20:18.881567-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.27","depends_on_id":"zine-teq.20","type":"blocks","created_at":"2025-12-16T22:20:18.92801-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.27","depends_on_id":"zine-teq.22","type":"blocks","created_at":"2025-12-16T22:20:18.973872-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.28","title":"Integration Tests: OAuth flow and subscription lifecycle","description":"Write integration tests for the complete OAuth flow and subscription management.\n\n## Test Scope\nIntegration tests verify the full flow across multiple components, including:\n- OAuth state registration → callback → token storage\n- Subscription creation → initial fetch → ingestion\n- Polling flow → new item detection → inbox delivery\n- Connection expiry → subscription disconnection → notification\n\n## OAuth Flow Tests\n```typescript\n// apps/worker/src/trpc/routers/connections.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createTestContext, mockYouTubeTokenExchange } from '../test-utils';\n\ndescribe('connections router', () =\u003e {\n  describe('OAuth flow', () =\u003e {\n    it('should complete full OAuth flow', async () =\u003e {\n      const ctx = await createTestContext();\n      \n      // 1. Register state\n      const state = 'random-state-123';\n      await ctx.caller.connections.registerState({\n        provider: 'YOUTUBE',\n        state,\n      });\n      \n      // Verify state stored in KV\n      expect(await ctx.env.KV.get(`oauth:state:${state}`)).toBe(ctx.userId);\n      \n      // 2. Mock provider token exchange\n      mockYouTubeTokenExchange({\n        access_token: 'access-123',\n        refresh_token: 'refresh-123',\n        expires_in: 3600,\n      });\n      \n      // 3. Complete callback\n      const result = await ctx.caller.connections.callback({\n        provider: 'YOUTUBE',\n        code: 'auth-code',\n        state,\n        codeVerifier: 'a'.repeat(43),\n      });\n      \n      expect(result.success).toBe(true);\n      \n      // 4. Verify connection stored\n      const connections = await ctx.caller.connections.list();\n      expect(connections.YOUTUBE).toBeDefined();\n      expect(connections.YOUTUBE?.status).toBe('ACTIVE');\n      \n      // 5. Verify state deleted\n      expect(await ctx.env.KV.get(`oauth:state:${state}`)).toBeNull();\n    });\n    \n    it('should reject invalid state', async () =\u003e {\n      const ctx = await createTestContext();\n      \n      await expect(ctx.caller.connections.callback({\n        provider: 'YOUTUBE',\n        code: 'auth-code',\n        state: 'invalid-state',\n        codeVerifier: 'a'.repeat(43),\n      })).rejects.toThrow('Invalid state');\n    });\n    \n    it('should update existing connection on reconnect', async () =\u003e {\n      const ctx = await createTestContext();\n      await createExistingConnection(ctx, 'YOUTUBE');\n      \n      // Reconnect flow\n      const state = 'new-state';\n      await ctx.caller.connections.registerState({ provider: 'YOUTUBE', state });\n      mockYouTubeTokenExchange({ access_token: 'new-token' });\n      \n      await ctx.caller.connections.callback({\n        provider: 'YOUTUBE',\n        code: 'new-code',\n        state,\n        codeVerifier: 'a'.repeat(43),\n      });\n      \n      // Should still be one connection, not two\n      const connections = await ctx.db.query.providerConnections.findMany({\n        where: eq(providerConnections.userId, ctx.userId),\n      });\n      expect(connections.length).toBe(1);\n    });\n  });\n  \n  describe('disconnect', () =\u003e {\n    it('should disconnect and mark subscriptions disconnected', async () =\u003e {\n      const ctx = await createTestContext();\n      await createExistingConnection(ctx, 'YOUTUBE');\n      await createSubscription(ctx, 'YOUTUBE', 'UCabc123');\n      \n      await ctx.caller.connections.disconnect({ provider: 'YOUTUBE' });\n      \n      // Connection should be deleted\n      const connections = await ctx.caller.connections.list();\n      expect(connections.YOUTUBE).toBeNull();\n      \n      // Subscription should be DISCONNECTED\n      const subs = await ctx.caller.subscriptions.list({});\n      expect(subs.items[0].status).toBe('DISCONNECTED');\n    });\n  });\n});\n```\n\n## Subscription Lifecycle Tests\n```typescript\n// apps/worker/src/trpc/routers/subscriptions.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { createTestContext, mockYouTubeAPI } from '../test-utils';\n\ndescribe('subscriptions router', () =\u003e {\n  describe('add', () =\u003e {\n    it('should create subscription and fetch initial item', async () =\u003e {\n      const ctx = await createTestContext();\n      await createExistingConnection(ctx, 'YOUTUBE');\n      \n      // Mock YouTube API responses\n      mockYouTubeAPI.channels({ uploadsPlaylistId: 'UUabc123' });\n      mockYouTubeAPI.playlistItems([\n        { videoId: 'video1', title: 'Latest Video', publishedAt: '2024-01-15T10:00:00Z' },\n      ]);\n      \n      const result = await ctx.caller.subscriptions.add({\n        provider: 'YOUTUBE',\n        providerChannelId: 'UCabc123456789012345678',\n      });\n      \n      expect(result.subscriptionId).toBeDefined();\n      \n      // Verify initial item ingested\n      const inbox = await ctx.caller.items.list({ state: 'INBOX' });\n      expect(inbox.items.length).toBe(1);\n      expect(inbox.items[0].title).toBe('Latest Video');\n    });\n    \n    it('should require active connection', async () =\u003e {\n      const ctx = await createTestContext();\n      // No connection created\n      \n      await expect(ctx.caller.subscriptions.add({\n        provider: 'YOUTUBE',\n        providerChannelId: 'UCabc123456789012345678',\n      })).rejects.toThrow('not connected');\n    });\n    \n    it('should validate channel ID format', async () =\u003e {\n      const ctx = await createTestContext();\n      await createExistingConnection(ctx, 'YOUTUBE');\n      \n      await expect(ctx.caller.subscriptions.add({\n        provider: 'YOUTUBE',\n        providerChannelId: 'invalid-id',\n      })).rejects.toThrow('Invalid YouTube channel ID');\n    });\n  });\n  \n  describe('remove', () =\u003e {\n    it('should soft delete and clean up inbox items', async () =\u003e {\n      const ctx = await createTestContext();\n      const { subscriptionId, itemId } = await setupSubscriptionWithItem(ctx);\n      \n      await ctx.caller.subscriptions.remove({ subscriptionId });\n      \n      // Subscription should be UNSUBSCRIBED\n      const subs = await ctx.caller.subscriptions.list({});\n      expect(subs.items.find(s =\u003e s.id === subscriptionId)?.status).toBe('UNSUBSCRIBED');\n      \n      // INBOX item should be deleted\n      const inbox = await ctx.caller.items.list({ state: 'INBOX' });\n      expect(inbox.items.find(i =\u003e i.id === itemId)).toBeUndefined();\n      \n      // provider_items_seen should remain (for re-subscribe protection)\n      const seen = await ctx.db.query.providerItemsSeen.findMany({\n        where: eq(providerItemsSeen.userId, ctx.userId),\n      });\n      expect(seen.length).toBeGreaterThan(0);\n    });\n    \n    it('should preserve saved items', async () =\u003e {\n      const ctx = await createTestContext();\n      const { subscriptionId, itemId } = await setupSubscriptionWithItem(ctx);\n      \n      // Save the item\n      await ctx.caller.items.save({ itemId });\n      \n      await ctx.caller.subscriptions.remove({ subscriptionId });\n      \n      // SAVED item should remain\n      const saved = await ctx.caller.items.list({ state: 'SAVED' });\n      expect(saved.items.find(i =\u003e i.id === itemId)).toBeDefined();\n    });\n  });\n  \n  describe('pause/resume', () =\u003e {\n    it('should pause and resume subscription', async () =\u003e {\n      const ctx = await createTestContext();\n      await createExistingConnection(ctx, 'YOUTUBE');\n      const sub = await createSubscription(ctx, 'YOUTUBE', 'UCabc123');\n      \n      // Pause\n      await ctx.caller.subscriptions.pause({ subscriptionId: sub.id });\n      let subs = await ctx.caller.subscriptions.list({});\n      expect(subs.items[0].status).toBe('PAUSED');\n      \n      // Resume\n      await ctx.caller.subscriptions.resume({ subscriptionId: sub.id });\n      subs = await ctx.caller.subscriptions.list({});\n      expect(subs.items[0].status).toBe('ACTIVE');\n    });\n  });\n});\n```\n\n## Polling Integration Tests\n```typescript\n// apps/worker/src/polling/scheduler.test.ts\nimport { describe, it, expect, vi } from 'vitest';\nimport { pollSubscriptions } from './scheduler';\n\ndescribe('polling scheduler', () =\u003e {\n  it('should poll due subscriptions and ingest new items', async () =\u003e {\n    const ctx = await createTestContext();\n    await createExistingConnection(ctx, 'YOUTUBE');\n    const sub = await createSubscription(ctx, 'YOUTUBE', 'UCabc123');\n    \n    // Set lastPolledAt to past\n    await ctx.db.update(subscriptions)\n      .set({ lastPolledAt: Date.now() - 2 * 3600 * 1000 })\n      .where(eq(subscriptions.id, sub.id));\n    \n    // Mock new videos since last poll\n    mockYouTubeAPI.playlistItems([\n      { videoId: 'new1', title: 'New Video', publishedAt: new Date().toISOString() },\n    ]);\n    \n    const result = await pollSubscriptions(ctx.env, {} as ExecutionContext);\n    \n    expect(result.processed).toBe(1);\n    expect(result.newItems).toBe(1);\n    \n    // Verify item in inbox\n    const inbox = await ctx.caller.items.list({ state: 'INBOX' });\n    expect(inbox.items.some(i =\u003e i.title === 'New Video')).toBe(true);\n  });\n  \n  it('should respect distributed lock', async () =\u003e {\n    const ctx = await createTestContext();\n    \n    // Simulate lock held by another worker\n    await ctx.env.KV.put('cron:poll-subscriptions:lock', Date.now().toString());\n    \n    const result = await pollSubscriptions(ctx.env, {} as ExecutionContext);\n    \n    expect(result.skipped).toBe(true);\n    expect(result.reason).toBe('lock_held');\n  });\n  \n  it('should handle auth errors and mark connections expired', async () =\u003e {\n    const ctx = await createTestContext();\n    await createExistingConnection(ctx, 'YOUTUBE');\n    const sub = await createSubscription(ctx, 'YOUTUBE', 'UCabc123');\n    \n    // Mock 401 response\n    mockYouTubeAPI.error(401, 'unauthorized');\n    \n    await pollSubscriptions(ctx.env, {} as ExecutionContext);\n    \n    // Connection should be EXPIRED\n    const connections = await ctx.caller.connections.list();\n    expect(connections.YOUTUBE?.status).toBe('EXPIRED');\n    \n    // Subscription should be DISCONNECTED\n    const subs = await ctx.caller.subscriptions.list({});\n    expect(subs.items[0].status).toBe('DISCONNECTED');\n  });\n});\n```\n\n## Test Utilities\n```typescript\n// apps/worker/src/test-utils.ts\n\nexport async function createTestContext() {\n  const db = await createTestDatabase();\n  const kv = createMockKV();\n  const userId = ulid();\n  \n  // ... setup test context\n}\n\nexport const mockYouTubeAPI = {\n  channels: (data: any) =\u003e { /* mock implementation */ },\n  playlistItems: (items: any[]) =\u003e { /* mock implementation */ },\n  error: (status: number, message: string) =\u003e { /* mock implementation */ },\n};\n```\n\n## Files to Create\n- apps/worker/src/trpc/routers/connections.test.ts\n- apps/worker/src/trpc/routers/subscriptions.test.ts\n- apps/worker/src/polling/scheduler.test.ts\n- apps/worker/src/test-utils.ts\n\n## Dependencies\n- zine-teq.27 (unit tests - shared utilities)\n- zine-teq.12 (connections router)\n- zine-teq.13 (subscriptions router)\n- zine-teq.19 (polling scheduler)\n\n## Acceptance Criteria\n- [ ] OAuth flow tested end-to-end\n- [ ] Subscription lifecycle tested\n- [ ] Polling integration verified\n- [ ] Error scenarios covered\n- [ ] Test utilities reusable\n- [ ] Tests pass in CI","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:18:42.049908-06:00","updated_at":"2025-12-17T19:52:55.225371-06:00","closed_at":"2025-12-17T19:52:55.225371-06:00","dependencies":[{"issue_id":"zine-teq.28","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:18:42.050314-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.28","depends_on_id":"zine-teq.27","type":"blocks","created_at":"2025-12-16T22:20:23.717865-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.28","depends_on_id":"zine-teq.12","type":"blocks","created_at":"2025-12-16T22:20:23.769029-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.28","depends_on_id":"zine-teq.13","type":"blocks","created_at":"2025-12-16T22:20:23.81562-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.28","depends_on_id":"zine-teq.19","type":"blocks","created_at":"2025-12-16T22:20:23.861721-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.29","title":"Database Schema: user_notifications table","description":"Create the user_notifications table for connection health alerts and system messages.\n\n## Table Definition\n```sql\nCREATE TABLE user_notifications (\n  id TEXT PRIMARY KEY,           -- ULID\n  user_id TEXT NOT NULL,\n  type TEXT NOT NULL,            -- connection_expired, poll_failures, etc.\n  provider TEXT,                 -- YOUTUBE, SPOTIFY (null for system-wide)\n  title TEXT NOT NULL,           -- Short title\n  message TEXT NOT NULL,         -- Full message body\n  data TEXT,                     -- JSON with additional details\n  read_at INTEGER,               -- Unix timestamp ms when read\n  resolved_at INTEGER,           -- Unix timestamp ms when auto-resolved\n  created_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  \n  -- Deduplication: one active notification per type/provider combo\n  UNIQUE(user_id, type, provider) WHERE resolved_at IS NULL\n);\n\n-- Index for efficient inbox queries\nCREATE INDEX idx_user_notifications_inbox \n  ON user_notifications(user_id, resolved_at, created_at DESC);\n```\n\n## Notification Types\n| Type | Provider | Trigger | Auto-resolves |\n|------|----------|---------|---------------|\n| `connection_expired` | YOUTUBE/SPOTIFY | OAuth token refresh fails | On reconnect |\n| `connection_revoked` | YOUTUBE/SPOTIFY | Provider returns 403 | On reconnect |\n| `poll_failures` | YOUTUBE/SPOTIFY | 3+ consecutive poll failures | On successful poll |\n| `quota_warning` | YOUTUBE | Quota \u003e 80% | Next day (quota reset) |\n\n## Drizzle Schema\n```typescript\nexport const userNotifications = sqliteTable('user_notifications', {\n  id: text('id').primaryKey(),\n  userId: text('user_id').notNull().references(() =\u003e users.id),\n  type: text('type').notNull(),\n  provider: text('provider'),\n  title: text('title').notNull(),\n  message: text('message').notNull(),\n  data: text('data'), // JSON\n  readAt: integer('read_at'),\n  resolvedAt: integer('resolved_at'),\n  createdAt: integer('created_at').notNull().default(sql`(unixepoch() * 1000)`),\n}, (table) =\u003e [\n  index('idx_user_notifications_inbox').on(table.userId, table.resolvedAt, table.createdAt),\n]);\n```\n\n## Notification Enum\nAdd to shared types:\n```typescript\nexport enum NotificationType {\n  CONNECTION_EXPIRED = 'connection_expired',\n  CONNECTION_REVOKED = 'connection_revoked',\n  POLL_FAILURES = 'poll_failures',\n  QUOTA_WARNING = 'quota_warning',\n}\n```\n\n## Files to Create/Modify\n- apps/worker/src/db/schema.ts - Add table definition\n- apps/worker/src/db/migrations/ - New migration\n- packages/shared/src/types/domain.ts - Add NotificationType enum\n\n## Dependencies\n- None (foundational table)\n\n## Acceptance Criteria\n- [ ] Table created with all columns\n- [ ] Unique constraint prevents duplicate active notifications\n- [ ] Index supports efficient inbox queries\n- [ ] Migration runs successfully\n- [ ] NotificationType enum exported from shared package","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:23:51.133494-06:00","updated_at":"2025-12-17T18:36:30.7622-06:00","closed_at":"2025-12-17T18:36:30.7622-06:00","dependencies":[{"issue_id":"zine-teq.29","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:23:51.133832-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.3","title":"Database Schema: subscription_items table","description":"Create the subscription_items table to track which items came from which subscription.\n\n## Table Definition\n```sql\nCREATE TABLE subscription_items (\n  id TEXT PRIMARY KEY,              -- ULID\n  subscription_id TEXT NOT NULL,    -- FK to subscriptions\n  item_id TEXT NOT NULL,            -- FK to items (canonical content)\n  provider_item_id TEXT NOT NULL,   -- YouTube video ID or Spotify episode ID\n  published_at INTEGER,             -- When item was published (ms)\n  fetched_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000), -- When we fetched it\n  \n  UNIQUE(subscription_id, provider_item_id)\n);\n\nCREATE INDEX idx_subscription_items_sub ON subscription_items(subscription_id);\n```\n\n## Purpose \u0026 Distinction from provider_items_seen\nThis table answers: 'What items came from this subscription?'\n- **Scope**: Per-subscription\n- **Use case**: Display subscription history, count items from a source\n- **Lifecycle**: Hard deleted when subscription is removed\n\nvs provider_items_seen which answers: 'Have I already ingested this item for this user?'\n- **Scope**: User-wide across all providers\n- **Use case**: Idempotency check during ingestion\n- **Lifecycle**: Preserved even after unsubscribe (prevents re-ingestion on re-subscribe)\n\n## Implementation Notes\n- Links subscription → items for provenance tracking\n- provider_item_id is denormalized for efficient lookups\n- published_at cached here to enable 'newest first' sorting without joining items\n- fetched_at useful for debugging ingestion timing issues\n\n## Why Both Tables Exist\nConsider: User subscribes to Channel A, video X appears. They unsubscribe, then re-subscribe.\n- subscription_items: Deleted on unsubscribe, recreated on re-subscribe (clean slate)\n- provider_items_seen: Preserved, so video X won't re-appear in inbox\n\n## Files to Modify\n- apps/worker/src/db/schema.ts\n- apps/worker/src/db/migrations/\n\n## Acceptance Criteria\n- [ ] Table created with all columns and constraints\n- [ ] Index on subscription_id for efficient lookups\n- [ ] Migration runs successfully\n- [ ] Drizzle schema exports the table","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:07:52.213141-06:00","updated_at":"2025-12-17T18:36:29.093837-06:00","closed_at":"2025-12-17T18:36:29.093837-06:00","dependencies":[{"issue_id":"zine-teq.3","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:07:52.213518-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.4","title":"Database Schema: provider_items_seen table","description":"Verified provider_items_seen table is compatible with subscriptions. Added comprehensive inline documentation.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:08:05.366652-06:00","updated_at":"2025-12-17T18:36:29.815336-06:00","closed_at":"2025-12-17T18:36:29.815336-06:00","dependencies":[{"issue_id":"zine-teq.4","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:08:05.367006-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.5","title":"Shared Types: Add subscription-related enums and schemas","description":"Added subscription-related enums and Zod schemas to shared package","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:08:22.273729-06:00","updated_at":"2025-12-17T18:36:30.321952-06:00","closed_at":"2025-12-17T18:36:30.321952-06:00","dependencies":[{"issue_id":"zine-teq.5","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:08:22.274098-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.6","title":"Token Encryption: AES-256-GCM utilities","description":"Implemented AES-256-GCM encryption utilities in apps/worker/src/lib/crypto.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:08:41.897439-06:00","updated_at":"2025-12-17T18:42:58.174664-06:00","closed_at":"2025-12-17T18:42:58.174664-06:00","dependencies":[{"issue_id":"zine-teq.6","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:08:41.897818-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.7","title":"OAuth: State management for CSRF protection","description":"Implement OAuth state parameter management using Cloudflare KV for CSRF protection.\n\n## Background\nThe OAuth 'state' parameter prevents CSRF attacks where an attacker tricks a user into connecting the attacker's account. The flow:\n1. Client generates state, sends to server with registerState\n2. Server stores state → userId mapping in KV\n3. Client includes state in OAuth redirect\n4. Provider callback includes state\n5. Server validates state matches userId before exchanging tokens\n\n## Implementation\n\n### State Registration Endpoint\n```typescript\n// apps/worker/src/trpc/routers/connections.ts\nregisterState: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n    state: z.string().min(32).max(128), // Client-generated, cryptographically random\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    const key = `oauth:state:${input.state}`;\n    \n    // Check for replay attacks\n    const existing = await ctx.env.KV.get(key);\n    if (existing) {\n      throw new TRPCError({ \n        code: 'BAD_REQUEST', \n        message: 'State already registered' \n      });\n    }\n    \n    // Store with 30 minute expiry (OAuth flow should complete faster)\n    await ctx.env.KV.put(key, ctx.userId, { expirationTtl: 1800 });\n    \n    return { success: true };\n  }),\n```\n\n### State Validation (in callback)\n```typescript\n// Inside callback mutation\nconst storedUserId = await ctx.env.KV.get(`oauth:state:${input.state}`);\nif (!storedUserId) {\n  throw new TRPCError({ code: 'BAD_REQUEST', message: 'State expired or invalid' });\n}\nif (storedUserId !== ctx.userId) {\n  throw new TRPCError({ code: 'BAD_REQUEST', message: 'State mismatch' });\n}\n// Delete after successful validation\nawait ctx.env.KV.delete(`oauth:state:${input.state}`);\n```\n\n## KV Namespace Setup\nAdd to wrangler.toml:\n```toml\n[[kv_namespaces]]\nbinding = \"KV\"\nid = \"...\" # Create with: wrangler kv:namespace create \"KV\"\n```\n\n## Rate Limiting\nApply rate limits to prevent abuse:\n| Endpoint        | Window   | Max Requests | Key    |\n| --------------- | -------- | ------------ | ------ |\n| registerState   | 1 minute | 5            | userId |\n\n## Why Not Server-Generated State?\nThe spec emphasizes client-generated state because:\n1. Client already generates PKCE verifier (similar security model)\n2. Reduces server round-trips\n3. Client can correlate state with its pending auth flow\n4. Follows OAuth 2.1 best practices\n\n## Files to Modify\n- apps/worker/src/trpc/routers/connections.ts - Add registerState procedure\n- apps/worker/wrangler.toml - Add KV namespace binding\n- apps/worker/worker-configuration.d.ts - Add KV to Env type\n\n## Acceptance Criteria\n- [ ] registerState stores state → userId in KV with TTL\n- [ ] Duplicate state registration is rejected\n- [ ] Callback validates state matches authenticated user\n- [ ] State is deleted after successful callback\n- [ ] Rate limiting prevents state flooding\n- [ ] Integration tests cover CSRF attack scenario","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:08:59.621916-06:00","updated_at":"2025-12-17T18:42:58.855854-06:00","closed_at":"2025-12-17T18:42:58.855854-06:00","dependencies":[{"issue_id":"zine-teq.7","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:08:59.622288-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.8","title":"OAuth: Token exchange endpoint (callback)","description":"Implement the OAuth callback endpoint that exchanges authorization code + PKCE verifier for tokens.\n\n## PKCE Security Model\n**Critical**: The code verifier is generated on the mobile client and NEVER stored on the server. This ensures that even if an attacker intercepts the authorization code, they cannot exchange it without the verifier.\n\nFlow:\n1. Mobile generates code_verifier (random 43-128 chars)\n2. Mobile computes code_challenge = BASE64URL(SHA256(code_verifier))\n3. Mobile redirects to provider with code_challenge\n4. Provider returns code to mobile via redirect\n5. Mobile calls our callback with code + code_verifier\n6. Server exchanges code + code_verifier for tokens\n\n## Implementation\n\n### Token Exchange Endpoint\n```typescript\n// apps/worker/src/trpc/routers/connections.ts\ncallback: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n    code: z.string(),\n    state: z.string(),\n    codeVerifier: z.string().min(43).max(128), // PKCE verifier\n  }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Validate state (CSRF protection)\n    const storedUserId = await ctx.env.KV.get(`oauth:state:${input.state}`);\n    if (storedUserId !== ctx.userId) {\n      throw new TRPCError({ code: 'BAD_REQUEST', message: 'Invalid state' });\n    }\n    \n    // 2. Exchange code + verifier for tokens\n    const tokens = await exchangeCodeForTokens(\n      input.provider,\n      input.code,\n      input.codeVerifier,\n      ctx.env\n    );\n    \n    // 3. Get provider user info (for provider_user_id)\n    const providerUser = await getProviderUserInfo(input.provider, tokens.access_token);\n    \n    // 4. Store encrypted tokens (upsert)\n    await ctx.db.insert(providerConnections).values({\n      id: ulid(),\n      userId: ctx.userId,\n      provider: input.provider,\n      providerUserId: providerUser.id,\n      accessToken: await encrypt(tokens.access_token, ctx.env.ENCRYPTION_KEY),\n      refreshToken: await encrypt(tokens.refresh_token, ctx.env.ENCRYPTION_KEY),\n      tokenExpiresAt: Date.now() + tokens.expires_in * 1000, // Convert to ms\n      scopes: tokens.scope,\n      status: 'ACTIVE',\n      connectedAt: Date.now(),\n    }).onConflictDoUpdate({\n      target: [providerConnections.userId, providerConnections.provider],\n      set: {\n        providerUserId: providerUser.id,\n        accessToken: await encrypt(tokens.access_token, ctx.env.ENCRYPTION_KEY),\n        refreshToken: await encrypt(tokens.refresh_token, ctx.env.ENCRYPTION_KEY),\n        tokenExpiresAt: Date.now() + tokens.expires_in * 1000,\n        scopes: tokens.scope,\n        status: 'ACTIVE',\n        lastRefreshedAt: Date.now(),\n      },\n    });\n    \n    // 5. Clean up state\n    await ctx.env.KV.delete(`oauth:state:${input.state}`);\n    \n    return { success: true, provider: input.provider };\n  }),\n```\n\n### Provider-Specific Token Exchange\n```typescript\n// apps/worker/src/lib/oauth.ts\nasync function exchangeCodeForTokens(\n  provider: Provider,\n  code: string,\n  codeVerifier: string,\n  env: Env\n): Promise\u003cTokenResponse\u003e {\n  const config = getProviderConfig(provider, env);\n  \n  const response = await fetch(config.tokenUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      code,\n      redirect_uri: config.redirectUri,\n      client_id: config.clientId,\n      client_secret: config.clientSecret,\n      code_verifier: codeVerifier, // PKCE\n    }),\n  });\n  \n  if (!response.ok) {\n    const error = await response.json();\n    throw new OAuthError(error.error, error.error_description);\n  }\n  \n  return response.json();\n}\n```\n\n## Provider Configuration\n| Provider | Token URL | Redirect URI |\n|----------|-----------|--------------|\n| YouTube  | https://oauth2.googleapis.com/token | {BASE_URL}/auth/youtube/callback |\n| Spotify  | https://accounts.spotify.com/api/token | {BASE_URL}/auth/spotify/callback |\n\n## Rate Limiting\n| Endpoint | Window | Max | Key |\n|----------|--------|-----|-----|\n| callback | 1 min  | 10  | userId |\n\n## Error Handling\n- Invalid code → 'Authorization code expired or invalid'\n- Invalid verifier → 'PKCE verification failed'\n- Provider error → Forward provider's error_description\n\n## Files to Create/Modify\n- apps/worker/src/trpc/routers/connections.ts - Add callback procedure\n- apps/worker/src/lib/oauth.ts - Token exchange utilities\n\n## Dependencies\n- zine-teq.6 (encryption utilities)\n- zine-teq.7 (state management)\n- zine-teq.1 (provider_connections table)\n\n## Acceptance Criteria\n- [ ] Successfully exchanges code for tokens with both providers\n- [ ] Tokens stored encrypted in database\n- [ ] State validated and deleted after use\n- [ ] PKCE verifier passed to provider correctly\n- [ ] Reconnection updates existing connection (upsert)\n- [ ] Integration tests cover successful and failed exchanges","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:09:23.606107-06:00","updated_at":"2025-12-17T18:46:49.255118-06:00","closed_at":"2025-12-17T18:46:49.255118-06:00","dependencies":[{"issue_id":"zine-teq.8","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:09:23.606478-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.8","depends_on_id":"zine-teq.6","type":"blocks","created_at":"2025-12-16T22:19:04.763407-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.8","depends_on_id":"zine-teq.7","type":"blocks","created_at":"2025-12-16T22:19:04.813353-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.8","depends_on_id":"zine-teq.1","type":"blocks","created_at":"2025-12-16T22:19:04.860592-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-teq.9","title":"OAuth: Token refresh with distributed locking","description":"Completed: Created token-refresh.ts and locks.ts with distributed locking for OAuth token refresh","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T22:09:46.702078-06:00","updated_at":"2025-12-17T18:46:49.663193-06:00","closed_at":"2025-12-17T18:46:49.663193-06:00","dependencies":[{"issue_id":"zine-teq.9","depends_on_id":"zine-teq","type":"parent-child","created_at":"2025-12-16T22:09:46.702442-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.9","depends_on_id":"zine-teq.6","type":"blocks","created_at":"2025-12-16T22:19:08.771538-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-teq.9","depends_on_id":"zine-teq.1","type":"blocks","created_at":"2025-12-16T22:19:08.820337-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zine-vq9","title":"Phase 3A: Create Item Detail Page (core UI)","description":"# Phase 3A: Create Item Detail Page Core UI\n\n## What This Task Does\nCreate the complete Item Detail Page screen with:\n- Route structure at app/item/[id].tsx\n- Cover image with adaptive aspect ratio (1:1 podcast, 16:9 video)\n- Title and creator display\n- Open Link button (Linking.openURL)\n- Description section with scrolling\n- Loading, error, and not found states\n\n## Why Consolidate?\nThe original plan split this into 7 separate beads (15, 16, 17, 18, 20, 21 and partially 19). In practice:\n- These are all built together in one session\n- There's no meaningful 'checkpoint' between title and description\n- The screen doesn't make sense without all parts\n- Managing 7 tiny dependencies creates overhead\n\n## What's NOT Included\nThe Action Row (finished, bookmark, share, add buttons) is separate because:\n- It depends on backend hooks (useToggleFinished, useUnbookmarkItem)\n- It can be added after the core UI is complete\n- It's a logical separation point\n\n## Implementation\nSee the original beads for detailed specs:\n- zine-qch.15: Route structure\n- zine-qch.16: Cover image\n- zine-qch.17: Title/source\n- zine-qch.18: Open button\n- zine-qch.20: Description\n- zine-qch.21: Loading/error states\n\n## Acceptance Criteria\n- [ ] Route /item/:id works\n- [ ] Cover image displays with correct aspect ratio per content type\n- [ ] Title and creator displayed\n- [ ] Open button opens canonicalUrl\n- [ ] Description scrolls if long\n- [ ] Loading spinner while fetching\n- [ ] Error state with retry\n- [ ] Not found state with back button\n\n## Dependencies\n- zine-qch.1: Icons (for placeholder and content type icons)\n- zine-qch.3: content-utils (for getContentAspectRatio)\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T22:35:36.013132-06:00","updated_at":"2025-12-25T22:58:57.642107-06:00","closed_at":"2025-12-25T22:58:57.642107-06:00","dependencies":[{"issue_id":"zine-vq9","depends_on_id":"zine-qch.1","type":"blocks","created_at":"2025-12-25T22:35:53.967613-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-vq9","depends_on_id":"zine-qch.3","type":"blocks","created_at":"2025-12-25T22:35:54.155091-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zine-vq9","depends_on_id":"zine-qch","type":"blocks","created_at":"2025-12-25T22:35:54.327208-06:00","created_by":"daemon","metadata":"{}"}]}
