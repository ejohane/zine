{"id":"zine-n9v","title":"Subscriptions Spec Review: Address Gaps and Issues","description":"This epic captures all findings from a thorough review of features/subscriptions/spec.md. The spec is comprehensive (~9500 lines) but has several gaps, inconsistencies, and areas needing clarification before implementation can proceed smoothly. Priority: P0 = blocking implementation, P1 = should fix before implementation, P2 = nice to have.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T19:34:13.078005-06:00","updated_at":"2025-12-16T20:07:20.08125-06:00","closed_at":"2025-12-16T20:07:20.08125-06:00"}
{"id":"zine-n9v.1","title":"Add missing provider_items_seen table schema to Appendix C","description":"## Problem\nThe `provider_items_seen` table is extensively referenced in §1.3 (Table Purpose Reference) with detailed queries and example usage, but its CREATE TABLE schema is missing from Appendix C (Database Migration).\n\n## Context\n- §1.3 describes the table's purpose: idempotency layer to prevent duplicate ingestion\n- Shows columns: `user_id`, `provider`, `provider_item_id`, `source_id`, `first_seen_at`\n- Unique constraint: `(user_id, provider, provider_item_id)`\n- The ingestion code in §4.3 references this table\n\n## Solution\nAdd the following to Appendix C after the `subscription_items` table:\n\n```sql\nCREATE TABLE provider_items_seen (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  provider TEXT NOT NULL,\n  provider_item_id TEXT NOT NULL,\n  source_id TEXT,  -- subscription_id that first ingested this\n  user_item_id TEXT REFERENCES user_items(id),\n  first_seen_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  UNIQUE(user_id, provider, provider_item_id)\n);\n\nCREATE INDEX idx_provider_items_seen_lookup \n  ON provider_items_seen(user_id, provider, provider_item_id);\n```\n\n## Files\n- features/subscriptions/spec.md (Appendix C, around line 9408)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T19:34:13.155594-06:00","updated_at":"2025-12-16T19:39:36.644099-06:00","closed_at":"2025-12-16T19:39:36.644099-06:00","dependencies":[{"issue_id":"zine-n9v.1","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.155936-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.10","title":"Add pagination to subscriptions.list API endpoint","description":"## Problem\nThe `subscriptions.list` endpoint (§5.1 line 3854) returns all subscriptions without pagination. Users with many subscriptions would get unbounded response sizes.\n\n## Context\n- Active users might have 50+ subscriptions\n- Each subscription object includes metadata (name, description, imageUrl)\n- No `limit` or `cursor` parameters shown in the input schema\n- Mobile app list views benefit from pagination for performance\n\n## Solution\nUpdate §5.1 to include pagination:\n\n```typescript\nlist: protectedProcedure\n  .input(\n    z.object({\n      provider: ProviderSchema.optional(),\n      status: SubscriptionStatusSchema.optional(),\n      // Pagination\n      limit: z.number().min(1).max(100).default(50),\n      cursor: z.string().optional(), // subscription ID for cursor-based pagination\n    }).optional()\n  )\n  .query(async ({ ctx, input }) =\u003e {\n    const { provider, status, limit = 50, cursor } = input || {};\n    \n    let whereClause = eq(subscriptions.userId, ctx.userId);\n    \n    if (provider) {\n      whereClause = and(whereClause, eq(subscriptions.provider, provider));\n    }\n    if (status) {\n      whereClause = and(whereClause, eq(subscriptions.status, status));\n    }\n    if (cursor) {\n      whereClause = and(whereClause, gt(subscriptions.id, cursor));\n    }\n    \n    const results = await ctx.db.query.subscriptions.findMany({\n      where: whereClause,\n      orderBy: [asc(subscriptions.id)],\n      limit: limit + 1, // Fetch one extra to detect hasMore\n    });\n    \n    const hasMore = results.length \u003e limit;\n    const items = hasMore ? results.slice(0, -1) : results;\n    const nextCursor = hasMore ? items[items.length - 1].id : null;\n    \n    return {\n      items,\n      nextCursor,\n      hasMore,\n    };\n  }),\n```\n\nAlso update the mobile hook in §6.6.4 to use infinite query.\n\n## Files\n- features/subscriptions/spec.md (§5.1 around line 3854, §6.6.4)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:13.822511-06:00","updated_at":"2025-12-16T19:44:11.202671-06:00","closed_at":"2025-12-16T19:44:11.202671-06:00","dependencies":[{"issue_id":"zine-n9v.10","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.822843-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.11","title":"Add providerChannelId format validation (YouTube: UC prefix)","description":"## Problem\nThe `subscriptions.add` mutation accepts any string for `providerChannelId` without validation. Invalid IDs would fail silently during polling.\n\n## Context\n- YouTube channel IDs have a specific format: UC prefix + 22 base64 characters (e.g., `UCBJycsmduvYEL83R_U4JriQ`)\n- Spotify show IDs are 22 alphanumeric characters (e.g., `5rgumWEx4FsqIY8e1wJNAk`)\n- Invalid IDs would be stored and polled, wasting API quota\n- Errors only surface during polling, not at subscription time\n\n## Solution\nAdd format validation to §5.1 `subscriptions.add`:\n\n```typescript\n// packages/shared/src/schemas/index.ts\n\nexport const YouTubeChannelIdSchema = z.string()\n  .regex(/^UC[a-zA-Z0-9_-]{22}$/, 'Invalid YouTube channel ID format');\n\nexport const SpotifyShowIdSchema = z.string()\n  .regex(/^[a-zA-Z0-9]{22}$/, 'Invalid Spotify show ID format');\n\nexport const ProviderChannelIdSchema = z.string().min(1);\n\n// In subscriptions router\nadd: protectedProcedure\n  .input(\n    z.object({\n      provider: ProviderSchema,\n      providerChannelId: z.string().min(1),\n      name: z.string().optional(),\n      imageUrl: z.string().url().optional(),\n    }).superRefine((data, ctx) =\u003e {\n      if (data.provider === 'YOUTUBE') {\n        const result = YouTubeChannelIdSchema.safeParse(data.providerChannelId);\n        if (!result.success) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: 'Invalid YouTube channel ID format. Expected UC + 22 characters.',\n            path: ['providerChannelId'],\n          });\n        }\n      } else if (data.provider === 'SPOTIFY') {\n        const result = SpotifyShowIdSchema.safeParse(data.providerChannelId);\n        if (!result.success) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: 'Invalid Spotify show ID format. Expected 22 alphanumeric characters.',\n            path: ['providerChannelId'],\n          });\n        }\n      }\n    })\n  )\n```\n\nNote: This is P2 priority since discovery flows will typically provide valid IDs. Validation is a defense-in-depth measure.\n\n## Files\n- features/subscriptions/spec.md (§5.1 around line 3864)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:13.895119-06:00","updated_at":"2025-12-16T20:07:02.427936-06:00","closed_at":"2025-12-16T20:07:02.427936-06:00","dependencies":[{"issue_id":"zine-n9v.11","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.895441-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.12","title":"Add rate limiting to OAuth callback endpoint","description":"## Problem\nThe OAuth `callback` endpoint (§2.2) has no rate limiting, allowing attackers to brute force the state parameter to hijack OAuth flows.\n\n## Context\n- State is a UUID (122 bits of entropy) so brute force is impractical\n- But rate limiting is still defense-in-depth\n- The endpoint does DB writes (token storage) so abuse could cause resource exhaustion\n- §7.3 references rate limiting for provider APIs but not for our own endpoints\n\n## Solution\nAdd rate limiting section §2.2.1 \"OAuth Endpoint Protection\":\n\n```typescript\n// apps/worker/src/middleware/rate-limit.ts\n\ninterface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  keyPrefix: string;\n}\n\nconst OAUTH_CALLBACK_LIMIT: RateLimitConfig = {\n  windowMs: 60 * 1000, // 1 minute window\n  maxRequests: 10,     // Max 10 attempts per minute\n  keyPrefix: 'ratelimit:oauth:callback',\n};\n\nexport async function checkRateLimit(\n  env: Env,\n  config: RateLimitConfig,\n  identifier: string\n): Promise\u003c{ allowed: boolean; remaining: number; resetAt: number }\u003e {\n  const key = `${config.keyPrefix}:${identifier}`;\n  const now = Date.now();\n  const windowStart = now - config.windowMs;\n  \n  // ... sliding window implementation similar to §3.7.4 ...\n}\n\n// In connections router\ncallback: protectedProcedure\n  .input(/* ... */)\n  .mutation(async ({ ctx, input }) =\u003e {\n    // Rate limit by user ID (authenticated) and state (unauthenticated attempts)\n    const userLimit = await checkRateLimit(ctx.env, OAUTH_CALLBACK_LIMIT, ctx.userId);\n    if (!userLimit.allowed) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: `Too many OAuth attempts. Try again in ${Math.ceil((userLimit.resetAt - Date.now()) / 1000)} seconds.`,\n      });\n    }\n    \n    // ... existing callback logic ...\n  }),\n```\n\nConsider also rate limiting the `registerState` endpoint.\n\n## Files\n- features/subscriptions/spec.md (new section §2.2.1)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:13.967991-06:00","updated_at":"2025-12-16T19:44:54.0798-06:00","closed_at":"2025-12-16T19:44:54.0798-06:00","dependencies":[{"issue_id":"zine-n9v.12","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.968307-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.13","title":"Add custom URL scheme registration for Android in app.json","description":"## Problem\nThe `app.json` configuration (§6.5.1) shows intent filters for HTTPS Universal Links but doesn't explicitly register the custom `zine://` URL scheme for Android.\n\n## Context\n- Line 4619 shows `\"scheme\": \"zine\"` in expo config which handles iOS\n- Lines 4627-4647 show Android intent filters only for HTTPS links\n- Custom schemes need explicit Android configuration\n- OAuth redirect uses `zine://oauth/callback` (line 4661)\n- Without explicit config, Android deep links may not work\n\n## Solution\nUpdate §6.5.1 app.json to include custom scheme for Android:\n\n```json\n{\n  \"expo\": {\n    \"scheme\": \"zine\",\n    \"android\": {\n      \"package\": \"app.zine.mobile\",\n      \"intentFilters\": [\n        {\n          \"action\": \"VIEW\",\n          \"autoVerify\": true,\n          \"data\": [\n            {\n              \"scheme\": \"https\",\n              \"host\": \"zine.app\",\n              \"pathPrefix\": \"/oauth/callback\"\n            }\n          ],\n          \"category\": [\"BROWSABLE\", \"DEFAULT\"]\n        },\n        {\n          \"action\": \"VIEW\",\n          \"data\": [\n            {\n              \"scheme\": \"zine\",\n              \"host\": \"oauth\",\n              \"pathPrefix\": \"/callback\"\n            }\n          ],\n          \"category\": [\"BROWSABLE\", \"DEFAULT\"]\n        }\n      ]\n    }\n  }\n}\n```\n\nNote: The `scheme` at root level handles this in Expo, but explicit intent filter ensures it works in all Android build configurations.\n\n## Files\n- features/subscriptions/spec.md (§6.5.1 around line 4627)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T19:34:14.042047-06:00","updated_at":"2025-12-16T19:41:04.367827-06:00","closed_at":"2025-12-16T19:41:04.367827-06:00","dependencies":[{"issue_id":"zine-n9v.13","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.042342-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.14","title":"Extend OAuth state expiry from 10 to 30 minutes","description":"## Problem\nThe OAuth state expiry of 10 minutes (§7.2 line 6934) may be too short for users who need to log into their Google/Spotify account or have slow connections.\n\n## Context\n- User clicks \"Connect YouTube\"\n- State registered with 10 min TTL\n- User redirected to Google\n- User needs to: log in (if not already), review permissions, click authorize\n- On slow connections or complex account situations (2FA, account selection), 10 min may not be enough\n- State expiry error is confusing to users\n\n## Solution\nIncrease TTL to 30 minutes in §7.2:\n\n```typescript\nasync function generateOAuthState(userId: string, env: Env): Promise\u003cstring\u003e {\n  const state = crypto.randomUUID();\n  await env.KV.put(`oauth:state:${state}`, userId, { \n    expirationTtl: 1800  // 30 minutes (was 600)\n  });\n  return state;\n}\n```\n\nAlso update §2.2 `registerState` endpoint comment (line 3655) and mobile code (§5.2).\n\nRationale: 30 minutes is still short enough to limit replay window but gives users reasonable time to complete OAuth flow.\n\n## Files\n- features/subscriptions/spec.md (§7.2 line 6934, §2.2 line 3655)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.11831-06:00","updated_at":"2025-12-16T20:07:03.471978-06:00","closed_at":"2025-12-16T20:07:03.471978-06:00","dependencies":[{"issue_id":"zine-n9v.14","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.118666-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.15","title":"Use tRPC utils for query invalidation instead of raw query keys","description":"## Problem\nThe optimistic update code in §6.6.4 uses raw TanStack Query keys that match tRPC's internal format. This is fragile and may break with tRPC version updates.\n\n## Context\n- Line 6042-6044 uses: `[['subscriptions', 'list'], { input: {}, type: 'query' }]`\n- This is tRPC's internal cache key format, not a public API\n- tRPC provides `utils.client` for mutations and `utils.subscriptions.list.invalidate()` for cache operations\n- Should use tRPC's utility methods instead\n\n## Solution\nUpdate §6.6.4 to use tRPC's cache utilities:\n\n```typescript\n// Instead of:\nqueryClient.setQueryData\u003cSubscription[]\u003e(\n  [['subscriptions', 'list'], { input: {}, type: 'query' }],\n  (old) =\u003e ...\n);\n\n// Use tRPC's getQueryKey helper:\nimport { getQueryKey } from '@trpc/react-query';\n\nconst queryKey = getQueryKey(trpc.subscriptions.list, {}, 'query');\nqueryClient.setQueryData\u003cSubscription[]\u003e(queryKey, (old) =\u003e ...);\n\n// Or better, use utils.setData (if available in your tRPC version):\nutils.subscriptions.list.setData({}, (old) =\u003e \n  old ? [...old, optimisticSub] : [optimisticSub]\n);\n```\n\nAlso update the hook to use the documented tRPC patterns.\n\n## Files\n- features/subscriptions/spec.md (§6.6.4 lines 6042-6051, 6072-6074)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:14.191834-06:00","updated_at":"2025-12-16T19:57:57.110637-06:00","closed_at":"2025-12-16T19:57:57.110637-06:00","dependencies":[{"issue_id":"zine-n9v.15","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.192185-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.16","title":"Add TypeScript type definitions for YouTubeVideo and SpotifyEpisode","description":"## Problem\nThe item transformation functions (§4.2) reference `YouTubeVideo` and `SpotifyEpisode` types but these aren't defined in the spec.\n\n## Context\n- Line 3239: `transformYouTubeVideo(playlistItem: youtube_v3.Schema$PlaylistItem)`\n- Line 3267: `transformSpotifyEpisode(episode: SimplifiedEpisode, ...)`\n- `youtube_v3.Schema$PlaylistItem` comes from googleapis types\n- `SimplifiedEpisode` comes from @spotify/web-api-ts-sdk\n- But §4.3 line 3318 uses `YouTubeVideo` and `SpotifyEpisode` without definition\n- Creates confusion about whether these are SDK types or custom types\n\n## Solution\nAdd a types section §4.1.1 \"Provider Item Types\":\n\n```typescript\n// packages/shared/src/types/providers.ts\n\nimport type { youtube_v3 } from 'googleapis';\nimport type { SimplifiedEpisode, Episode } from '@spotify/web-api-ts-sdk';\n\n/**\n * YouTube video as returned from playlistItems.list\n */\nexport type YouTubeVideo = youtube_v3.Schema$PlaylistItem;\n\n/**\n * Spotify episode as returned from shows.getShowEpisodes\n */\nexport type SpotifyEpisode = SimplifiedEpisode;\n\n/**\n * Union type for any provider item\n */\nexport type ProviderItem = YouTubeVideo | SpotifyEpisode;\n\n/**\n * Type guard for YouTube items\n */\nexport function isYouTubeVideo(item: ProviderItem): item is YouTubeVideo {\n  return 'snippet' in item \u0026\u0026 'contentDetails' in item;\n}\n\n/**\n * Type guard for Spotify episodes\n */\nexport function isSpotifyEpisode(item: ProviderItem): item is SpotifyEpisode {\n  return 'release_date' in item \u0026\u0026 'duration_ms' in item;\n}\n```\n\nUpdate §4.3 to import and use these types consistently.\n\n## Files\n- features/subscriptions/spec.md (new section §4.1.1, update §4.3)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:14.26559-06:00","updated_at":"2025-12-16T19:57:58.335918-06:00","closed_at":"2025-12-16T19:57:58.335918-06:00","dependencies":[{"issue_id":"zine-n9v.16","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.26591-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.17","title":"Consolidate duplicated hexToBytes/bytesToHex helper functions","description":"## Problem\nThe `hexToBytes` and `bytesToHex` helper functions are defined in both §7.1 (lines 6824-6839) and §7.6.3 (lines 7495-7507), creating code duplication.\n\n## Context\n- First definition in §7.1 \"Token Storage\" encryption example\n- Second definition in §7.6.3 \"Versioned Encryption Implementation\"\n- Identical implementations\n- Should be consolidated into a shared utility\n\n## Solution\n1. Remove the duplicate from §7.6.3\n2. Add a note in §7.1 that these utilities should be in a shared module:\n\n```typescript\n// apps/worker/src/lib/encoding.ts\n\n/**\n * Convert a hex string to Uint8Array.\n * Used for encryption key handling and ciphertext parsing.\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i \u003c hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert Uint8Array to hex string.\n * Used for encoding IVs, auth tags, and ciphertext.\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  return Array.from(bytes)\n    .map((b) =\u003e b.toString(16).padStart(2, '0'))\n    .join('');\n}\n```\n\nThen update §7.6.3 to import from this module instead of redefining.\n\n## Files\n- features/subscriptions/spec.md (§7.1 lines 6824-6839, §7.6.3 lines 7495-7507)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.338999-06:00","updated_at":"2025-12-16T20:07:04.639847-06:00","closed_at":"2025-12-16T20:07:04.639847-06:00","dependencies":[{"issue_id":"zine-n9v.17","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.339316-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.18","title":"Add sequence diagram for polling → ingestion → inbox flow","description":"## Problem\nThe spec includes a sequence diagram for OAuth (§2.2) but lacks one for the polling → ingestion → inbox flow, which is the core subscription functionality.\n\n## Context\n- §4.1 has a flow diagram but it's ASCII boxes, not a sequence diagram\n- The interaction between cron trigger, poll scheduler, provider fetcher, ingestion processor, and database is complex\n- A sequence diagram would clarify timing and responsibilities\n- Helpful for implementers to understand the full data flow\n\n## Solution\nAdd a sequence diagram in §4.1 after the flow diagram:\n\n```\n┌───────────┐     ┌───────────┐     ┌──────────┐     ┌──────────┐     ┌────┐\n│   Cron    │     │  Poll     │     │ Provider │     │ Ingestion│     │ D1 │\n│  Trigger  │     │ Scheduler │     │ Fetcher  │     │ Processor│     │    │\n└─────┬─────┘     └─────┬─────┘     └────┬─────┘     └────┬─────┘     └──┬─┘\n      │                 │                │                │              │\n      │  1. trigger     │                │                │              │\n      │────────────────\u003e│                │                │              │\n      │                 │                │                │              │\n      │                 │ 2. query due   │                │              │\n      │                 │────────────────────────────────────────────────\u003e│\n      │                 │                │                │              │\n      │                 │ 3. subscriptions                │              │\n      │                 │\u003c────────────────────────────────────────────────│\n      │                 │                │                │              │\n      │                 │ 4. for each subscription:       │              │\n      │                 │──────────────\u003e│                │              │\n      │                 │                │                │              │\n      │                 │                │ 5. get token   │              │\n      │                 │                │────────────────────────────────\u003e│\n      │                 │                │                │              │\n      │                 │                │ 6. fetch items │              │\n      │                 │                │──────────────\u003e │              │\n      │                 │                │  (YouTube/     │              │\n      │                 │                │   Spotify API) │              │\n      │                 │                │                │              │\n      │                 │                │ 7. items       │              │\n      │                 │                │\u003c────────────── │              │\n      │                 │                │                │              │\n      │                 │                │ 8. for each item:              │\n      │                 │                │───────────────\u003e│              │\n      │                 │                │                │              │\n      │                 │                │                │ 9. check seen│\n      │                 │                │                │─────────────\u003e│\n      │                 │                │                │              │\n      │                 │                │                │ 10. if new:  │\n      │                 │                │                │  insert item,│\n      │                 │                │                │  user_item,  │\n      │                 │                │                │  mark seen   │\n      │                 │                │                │─────────────\u003e│\n      │                 │                │                │              │\n      │                 │ 11. update lastPolledAt         │              │\n      │                 │────────────────────────────────────────────────\u003e│\n      │                 │                │                │              │\n```\n\n## Files\n- features/subscriptions/spec.md (§4.1 after line 3229)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.415323-06:00","updated_at":"2025-12-16T20:07:05.608162-06:00","closed_at":"2025-12-16T20:07:05.608162-06:00","dependencies":[{"issue_id":"zine-n9v.18","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.415678-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.19","title":"Add reference to local-first sync architecture in offline handling section","description":"## Problem\nThe offline handling section (§6.6) describes a custom offline queue implementation but doesn't reference the broader local-first sync architecture documented in the project.\n\n## Context\n- docs/zine-sync-local-first.md likely describes the app's sync strategy\n- §6.6 implements its own offline queue with AsyncStorage\n- May duplicate or conflict with existing sync infrastructure\n- Implementers should understand how subscriptions offline handling fits into the larger picture\n\n## Solution\nAdd a note at the beginning of §6.6:\n\n```markdown\n### 6.6 Offline Handling\n\n\u003e **Architecture Note**: This section describes offline handling specific to \n\u003e subscription mutations. For the broader local-first sync architecture used\n\u003e by Zine, see `docs/zine-sync-local-first.md`. The subscription offline queue\n\u003e described here is designed to integrate with that architecture.\n\u003e \n\u003e Key integration points:\n\u003e - Subscription list queries use the same cache/sync strategy as other data\n\u003e - Offline mutations queue independently since they require server-side OAuth\n\u003e - Sync recovery (§6.6.9) coordinates with the app's general sync mechanism\n\nMobile apps must gracefully handle network connectivity issues...\n```\n\nAlso review if the custom AsyncStorage queue could be replaced by or unified with the existing sync infrastructure.\n\n## Files\n- features/subscriptions/spec.md (§6.6 around line 5517)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.49404-06:00","updated_at":"2025-12-16T20:07:06.638032-06:00","closed_at":"2025-12-16T20:07:06.638032-06:00","dependencies":[{"issue_id":"zine-n9v.19","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.494384-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.2","title":"Add items table schema to spec (or reference existing schema)","description":"## Problem\nThe spec references a canonical `items` table throughout (§1.2 entity diagram, §4.2 transformation, §4.3 ingestion) but never defines its schema. Implementers won't know the column structure.\n\n## Context\n- §4.2 shows `transformYouTubeVideo` and `transformSpotifyEpisode` returning a `NewItem` object with fields: `id`, `contentType`, `provider`, `providerId`, `canonicalUrl`, `title`, `description`, `creator`, `creatorUrl`, `thumbnailUrl`, `durationSeconds`, `publishedAt`, `createdAt`\n- Appendix D shows provider response shapes that map to these fields\n- The table should support multiple content types (VIDEO, PODCAST, ARTICLE, POST)\n\n## Solution\nEither:\n1. Add the schema to Appendix C if it's new\n2. Add a note referencing the existing schema location in the codebase (apps/worker/src/db/schema.ts)\n\nSuggested schema if new:\n```sql\nCREATE TABLE items (\n  id TEXT PRIMARY KEY,\n  content_type TEXT NOT NULL,  -- VIDEO, PODCAST, ARTICLE, POST\n  provider TEXT NOT NULL,       -- YOUTUBE, SPOTIFY, RSS, etc.\n  provider_id TEXT NOT NULL,    -- YouTube video ID, Spotify episode ID\n  canonical_url TEXT NOT NULL,\n  title TEXT NOT NULL,\n  description TEXT,\n  creator TEXT,\n  creator_url TEXT,\n  thumbnail_url TEXT,\n  duration_seconds INTEGER,\n  published_at INTEGER,\n  created_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  UNIQUE(provider, provider_id)\n);\n```\n\n## Files\n- features/subscriptions/spec.md (Appendix C or new section §1.2.1)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T19:34:13.228527-06:00","updated_at":"2025-12-16T19:39:37.294771-06:00","closed_at":"2025-12-16T19:39:37.294771-06:00","dependencies":[{"issue_id":"zine-n9v.2","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.228859-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.20","title":"Connect notification preferences UI to backend notification creation","description":"## Problem\nThe notification settings screen (§7.7.6) shows UI for preferences but the settings are local state only - they're not connected to the backend notification creation logic.\n\n## Context\n- §7.7.6 `NotificationSettingsScreen` uses `useState` for preferences\n- Comment says \"TODO: Persist to backend or local storage\"\n- §7.7.3 `createNotification` doesn't check user preferences\n- Users expect their settings to actually affect notifications\n- Also no way to fetch existing preferences\n\n## Solution\n1. Add a `user_notification_preferences` table in §7.7.2:\n\n```sql\nCREATE TABLE user_notification_preferences (\n  user_id TEXT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,\n  connection_issues BOOLEAN NOT NULL DEFAULT TRUE,\n  subscription_errors BOOLEAN NOT NULL DEFAULT TRUE,\n  rate_limit_warnings BOOLEAN NOT NULL DEFAULT FALSE,\n  quota_status BOOLEAN NOT NULL DEFAULT TRUE,\n  push_enabled BOOLEAN NOT NULL DEFAULT FALSE,\n  updated_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000)\n);\n```\n\n2. Add tRPC endpoints in §7.7.4:\n\n```typescript\nnotificationPreferences: router({\n  get: protectedProcedure.query(async ({ ctx }) =\u003e {\n    // Return preferences or defaults\n  }),\n  \n  update: protectedProcedure\n    .input(NotificationPreferencesSchema)\n    .mutation(async ({ ctx, input }) =\u003e {\n      // Upsert preferences\n    }),\n}),\n```\n\n3. Update §7.7.3 `createNotification` to check preferences:\n\n```typescript\nasync function createNotification(db: DrizzleDB, params: CreateNotificationParams) {\n  // Check user preferences\n  const prefs = await db.query.userNotificationPreferences.findFirst({\n    where: eq(userNotificationPreferences.userId, params.userId),\n  });\n  \n  const prefKey = getPreferenceKey(params.type);\n  if (prefs \u0026\u0026 prefs[prefKey] === false) {\n    // User has disabled this notification type\n    return null;\n  }\n  \n  // ... existing creation logic ...\n}\n```\n\n## Files\n- features/subscriptions/spec.md (§7.7.2, §7.7.3, §7.7.4, §7.7.6)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:14.570134-06:00","updated_at":"2025-12-16T19:57:59.588804-06:00","closed_at":"2025-12-16T19:57:59.588804-06:00","dependencies":[{"issue_id":"zine-n9v.20","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.570457-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.21","title":"Add manual 'Sync Now' button feature to subscriptions UX","description":"## Problem\nUsers cannot manually trigger a sync for a specific subscription - they must wait for the next cron poll (up to 15+ minutes depending on adaptive interval).\n\n## Context\n- Polling intervals range from 1-24 hours (§3.3)\n- User subscribes to channel that just uploaded a video they want to see\n- No way to force immediate poll\n- Pull-to-refresh on subscription list only refetches local data, doesn't trigger server poll\n\n## Solution\nAdd a manual sync feature in §5.1:\n\n```typescript\n// tRPC endpoint\nsyncNow: protectedProcedure\n  .input(z.object({ subscriptionId: z.string() }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    const subscription = await ctx.db.query.subscriptions.findFirst({\n      where: and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!subscription) {\n      throw new TRPCError({ code: 'NOT_FOUND' });\n    }\n    \n    // Rate limit manual syncs (max 1 per 5 minutes per subscription)\n    const rateLimitKey = `manual-sync:${input.subscriptionId}`;\n    const lastSync = await ctx.env.KV.get(rateLimitKey);\n    if (lastSync \u0026\u0026 Date.now() - parseInt(lastSync) \u003c 5 * 60 * 1000) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: 'Please wait 5 minutes between manual syncs',\n      });\n    }\n    \n    // Perform sync\n    const connection = await getConnection(ctx.userId, subscription.provider, ctx.env);\n    const result = await pollSubscriptionWithRetry(subscription, connection, ctx.env);\n    \n    await ctx.env.KV.put(rateLimitKey, Date.now().toString(), { expirationTtl: 300 });\n    \n    return { \n      success: result.success, \n      itemsFound: result.itemsFound \n    };\n  }),\n```\n\nAdd UI button in §6.4 subscription detail or list item.\n\n## Files\n- features/subscriptions/spec.md (§5.1, §6.4)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.643721-06:00","updated_at":"2025-12-16T20:07:07.888045-06:00","closed_at":"2025-12-16T20:07:07.888045-06:00","dependencies":[{"issue_id":"zine-n9v.21","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.644079-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.22","title":"Correct YouTube quota budget analysis with realistic polling frequencies","description":"Updated §3.6.3 with realistic adaptive polling capacity analysis","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.716998-06:00","updated_at":"2025-12-16T20:01:37.458366-06:00","closed_at":"2025-12-16T20:01:37.458366-06:00","dependencies":[{"issue_id":"zine-n9v.22","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.717353-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.23","title":"Add decryption error handling strategy (mark EXPIRED vs throw)","description":"## Problem\nWhen token decryption fails (wrong key, corrupted data), the spec doesn't specify the error handling strategy - should we mark the connection as EXPIRED or throw?\n\n## Context\n- §7.1 decrypt function throws on failure\n- §7.6.3 DecryptionError has different codes (KEY_VERSION_NOT_FOUND, INVALID_FORMAT, DECRYPTION_FAILED)\n- During polling, if decryption fails, we can't use the token\n- But \"wrong key\" might be transient (key rotation in progress) vs permanent (data corruption)\n- User experience differs: transient = retry later, permanent = reconnect required\n\n## Solution\nAdd a section §7.1.1 \"Decryption Error Handling\":\n\n```typescript\n/**\n * Handle decryption errors when accessing tokens.\n * \n * Strategy:\n * - KEY_VERSION_NOT_FOUND: Likely key rotation issue. Log error, \n *   don't mark expired, retry on next poll. Alert ops team.\n * - INVALID_FORMAT: Data corruption. Mark connection EXPIRED, \n *   notify user to reconnect.\n * - DECRYPTION_FAILED: Wrong key or corruption. If repeated (3x), \n *   mark EXPIRED. Otherwise retry.\n */\nasync function getTokenSafely(\n  connection: ProviderConnection,\n  env: Env\n): Promise\u003c{ token: string | null; error?: DecryptionError }\u003e {\n  try {\n    const token = await decrypt(connection.accessToken, env.ENCRYPTION_KEY);\n    return { token };\n  } catch (error) {\n    if (error instanceof DecryptionError) {\n      switch (error.code) {\n        case 'KEY_VERSION_NOT_FOUND':\n          // Likely a deployment issue - log and skip, don't fail permanently\n          console.error(`[Token] Key version not found for connection ${connection.id}`);\n          // TODO: Send ops alert\n          return { token: null, error };\n          \n        case 'INVALID_FORMAT':\n          // Data corruption - connection is unrecoverable\n          await markConnectionExpired(connection, 'decryption_failed');\n          return { token: null, error };\n          \n        case 'DECRYPTION_FAILED':\n          // Track failures, expire after threshold\n          const failureCount = await incrementDecryptionFailures(connection.id, env);\n          if (failureCount \u003e= 3) {\n            await markConnectionExpired(connection, 'decryption_failed');\n          }\n          return { token: null, error };\n      }\n    }\n    throw error;\n  }\n}\n```\n\n## Files\n- features/subscriptions/spec.md (new section §7.1.1 after line 6916)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:14.797868-06:00","updated_at":"2025-12-16T19:58:00.485911-06:00","closed_at":"2025-12-16T19:58:00.485911-06:00","dependencies":[{"issue_id":"zine-n9v.23","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.798222-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.24","title":"Document D1 batch write limits and bulk ingestion strategy","description":"## Problem\nThe spec doesn't discuss D1's write limits or how to handle bulk ingestion when a subscription poll returns many new items.\n\n## Context\n- D1 has limits: 1000 rows per write, 100KB per row, transaction limits\n- A prolific YouTube channel might have 10+ new videos if user is late to subscribe\n- Initial fetch only gets latest item (§4.4), but backfill scenarios exist\n- Batch operations in §4.3 `ingestItem` are done one at a time\n\n## Solution\nAdd a section §4.3.1 \"Bulk Ingestion and D1 Limits\":\n\n```markdown\n### 4.3.1 Bulk Ingestion and D1 Limits\n\n#### D1 Write Limits (as of 2024)\n| Limit | Value |\n|-------|-------|\n| Max rows per write | 1,000 |\n| Max row size | 100 KB |\n| Max writes per transaction | 1,000 |\n| Recommended batch size | 100 rows |\n\n#### Handling Multiple New Items\n\nWhen a poll returns multiple new items (e.g., 10 new videos):\n\n```typescript\nasync function ingestItems(\n  userId: string,\n  subscriptionId: string,\n  items: ProviderItem[],\n  provider: Provider,\n  db: DrizzleDB\n): Promise\u003c{ created: number; skipped: number }\u003e {\n  // Process in batches to stay within D1 limits\n  const BATCH_SIZE = 25; // Conservative: 4 writes per item × 25 = 100 writes\n  \n  let created = 0;\n  let skipped = 0;\n  \n  for (let i = 0; i \u003c items.length; i += BATCH_SIZE) {\n    const batch = items.slice(i, i + BATCH_SIZE);\n    \n    // Process batch in a single transaction\n    await db.transaction(async (tx) =\u003e {\n      for (const item of batch) {\n        const result = await ingestItem(userId, subscriptionId, item, provider, tx);\n        if (result.created) created++;\n        else skipped++;\n      }\n    });\n  }\n  \n  return { created, skipped };\n}\n```\n\n#### Initial Subscription: Single Item Only\n\nAs specified in §4.4, initial subscription fetch intentionally returns only the \nlatest item to avoid bulk ingestion complexity. This design decision:\n- Keeps initial subscription fast\n- Avoids quota spikes\n- Prevents inbox overwhelming\n\nFor backfill scenarios (future feature), implement a separate background job \nwith aggressive rate limiting.\n```\n\n## Files\n- features/subscriptions/spec.md (new section §4.3.1 after line 3356)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:14.880432-06:00","updated_at":"2025-12-16T19:58:01.507836-06:00","closed_at":"2025-12-16T19:58:01.507836-06:00","dependencies":[{"issue_id":"zine-n9v.24","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.880761-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.25","title":"Add React Error Boundary examples for mobile components","description":"## Problem\nThe mobile components in §6.6 don't show React Error Boundary usage. Unhandled errors in subscription UI could crash the entire app.\n\n## Context\n- OAuth callbacks can fail in various ways\n- Network errors during subscription operations\n- Malformed data from API responses\n- Without error boundaries, these crash the whole app\n- React Native apps should be resilient\n\n## Solution\nAdd error boundary examples in §6.5 and §6.6:\n\n```typescript\n// apps/mobile/components/error-boundary.tsx\n\nimport { Component, ErrorInfo, ReactNode } from 'react';\nimport { View, Text, Pressable } from 'react-native';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) =\u003e void;\n  resetKeys?: unknown[]; // Re-render children when these change\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nexport class ErrorBoundary extends Component\u003cProps, State\u003e {\n  state: State = { hasError: false, error: null };\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('[ErrorBoundary]', error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n    // TODO: Report to error tracking service\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (this.state.hasError \u0026\u0026 this.props.resetKeys) {\n      const hasKeyChanged = this.props.resetKeys.some(\n        (key, i) =\u003e key !== prevProps.resetKeys?.[i]\n      );\n      if (hasKeyChanged) {\n        this.setState({ hasError: false, error: null });\n      }\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        \u003cView className=\"flex-1 items-center justify-center p-6\"\u003e\n          \u003cText className=\"text-xl mb-2\"\u003eSomething went wrong\u003c/Text\u003e\n          \u003cText className=\"text-gray-500 mb-4 text-center\"\u003e\n            {this.state.error?.message || 'An unexpected error occurred'}\n          \u003c/Text\u003e\n          \u003cPressable\n            onPress={() =\u003e this.setState({ hasError: false, error: null })}\n            className=\"bg-blue-500 px-6 py-3 rounded-lg\"\n          \u003e\n            \u003cText className=\"text-white font-medium\"\u003eTry Again\u003c/Text\u003e\n          \u003c/Pressable\u003e\n        \u003c/View\u003e\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage in subscription screens:\n\u003cErrorBoundary \n  onError={(e) =\u003e trackError('subscription_screen', e)}\n  resetKeys={[subscriptionId]}\n\u003e\n  \u003cSubscriptionDetail id={subscriptionId} /\u003e\n\u003c/ErrorBoundary\u003e\n```\n\nAdd this pattern around OAuth screens, subscription list, and notification components.\n\n## Files\n- features/subscriptions/spec.md (§6.5, §6.6)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T19:34:14.962042-06:00","updated_at":"2025-12-16T20:01:38.706117-06:00","closed_at":"2025-12-16T20:01:38.706117-06:00","dependencies":[{"issue_id":"zine-n9v.25","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:14.962381-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.3","title":"Add user_items table schema to spec (or reference existing schema)","description":"## Problem\nThe `user_items` table is a critical junction table between users and items (storing INBOX/BOOKMARKED/ARCHIVED state) but its schema is never defined in the spec.\n\n## Context\n- §1.2 shows `user_items` in the entity relationship: `users (N) user_items (N) items`\n- §4.3 ingestion code creates user_items with `state: 'INBOX'`\n- §5.3 unsubscribe behavior deletes `user_items` with `state='INBOX'`\n- The table is central to the inbox-first flow described in §1 Key Principles\n\n## Solution\nAdd the schema to Appendix C or reference existing schema:\n\n```sql\nCREATE TABLE user_items (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  item_id TEXT NOT NULL REFERENCES items(id),\n  state TEXT NOT NULL DEFAULT 'INBOX',  -- INBOX, BOOKMARKED, ARCHIVED\n  ingested_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  bookmarked_at INTEGER,\n  archived_at INTEGER,\n  updated_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000),\n  UNIQUE(user_id, item_id)\n);\n\nCREATE INDEX idx_user_items_inbox ON user_items(user_id, state);\nCREATE INDEX idx_user_items_item ON user_items(item_id);\n```\n\n## Files\n- features/subscriptions/spec.md (Appendix C)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T19:34:13.303513-06:00","updated_at":"2025-12-16T19:39:37.937897-06:00","closed_at":"2025-12-16T19:39:37.937897-06:00","dependencies":[{"issue_id":"zine-n9v.3","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.303843-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.4","title":"Clarify timestamp convention: milliseconds vs seconds across all tables","description":"## Problem\nThe spec inconsistently uses milliseconds vs seconds for timestamps, which could cause bugs during implementation.\n\n## Context\n- SQL defaults use `unixepoch() * 1000` (milliseconds): lines 9421, 9441, 9452\n- §3.2 polling logic: `lastPolledAt \u003c now - (pollIntervalSeconds * 1000)` - explicitly converts\n- §3.4 token expiry: `now + refreshed.expiresIn * 1000` - explicitly converts\n- But `poll_interval_seconds` column stores seconds (line 9438), requiring conversion\n- `token_expires_at` stores milliseconds (line 9420)\n\n## Solution\nAdd a convention note in §1.2 after the table definitions:\n\n```markdown\n### 1.2.1 Timestamp Convention\n\nAll timestamp columns in the database store **Unix timestamps in milliseconds** (not seconds).\n\n| Column Type | Storage | Example |\n|-------------|---------|---------|\n| `*_at` columns | Milliseconds | `1702747200000` |\n| `*_seconds` columns | Seconds | `3600` |\n\nWhen working with external APIs:\n- JavaScript `Date.now()` returns milliseconds (use directly)\n- Provider API responses often use ISO 8601 strings (parse with `new Date().getTime()`)\n- OAuth `expires_in` is in seconds (multiply by 1000 before storing)\n```\n\n## Files\n- features/subscriptions/spec.md (new section §1.2.1)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:13.379647-06:00","updated_at":"2025-12-16T19:42:01.765492-06:00","closed_at":"2025-12-16T19:42:01.765492-06:00","dependencies":[{"issue_id":"zine-n9v.4","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.379981-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.5","title":"Add concurrent token refresh handling with locking mechanism","description":"## Problem\nMultiple cron jobs or parallel polling workers could attempt to refresh the same expired OAuth token simultaneously, leading to race conditions where one refresh invalidates another's token.\n\n## Context\n- §3.4 `getValidToken()` checks expiry and refreshes if needed\n- Multiple subscriptions for the same user could be polled concurrently\n- Spotify rotates refresh tokens on each use - if two workers refresh simultaneously, one will have an invalid refresh token\n- No locking mechanism is described\n\n## Solution\nAdd a section §3.4.1 \"Concurrent Token Refresh\" with a distributed locking strategy using KV:\n\n```typescript\n// apps/worker/src/lib/tokens.ts\n\nconst REFRESH_LOCK_TTL = 30; // seconds\n\nasync function getValidTokenWithLock(\n  connection: ProviderConnection,\n  env: Env\n): Promise\u003cstring\u003e {\n  const now = Date.now();\n  const bufferMs = 5 * 60 * 1000;\n  \n  // Return existing token if still valid\n  if (connection.tokenExpiresAt - bufferMs \u003e now) {\n    return decrypt(connection.accessToken, env.ENCRYPTION_KEY);\n  }\n  \n  // Try to acquire refresh lock\n  const lockKey = `token:refresh:${connection.id}`;\n  const lockAcquired = await tryAcquireLock(env.KV, lockKey, REFRESH_LOCK_TTL);\n  \n  if (!lockAcquired) {\n    // Another worker is refreshing - wait and retry\n    await sleep(2000);\n    // Re-fetch connection to get updated token\n    const updated = await getConnection(connection.id, env);\n    if (updated \u0026\u0026 updated.tokenExpiresAt - bufferMs \u003e now) {\n      return decrypt(updated.accessToken, env.ENCRYPTION_KEY);\n    }\n    throw new Error('Token refresh in progress by another worker');\n  }\n  \n  try {\n    const refreshed = await refreshToken(connection, env);\n    await persistTokens(connection.id, refreshed, env);\n    return refreshed.accessToken;\n  } finally {\n    await releaseLock(env.KV, lockKey);\n  }\n}\n\nasync function tryAcquireLock(kv: KVNamespace, key: string, ttl: number): Promise\u003cboolean\u003e {\n  const existing = await kv.get(key);\n  if (existing) return false;\n  \n  // Use put with expiration - not perfectly atomic but good enough for this use case\n  await kv.put(key, Date.now().toString(), { expirationTtl: ttl });\n  return true;\n}\n```\n\n## Files\n- features/subscriptions/spec.md (new section §3.4.1 after line 1176)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T19:34:13.453285-06:00","updated_at":"2025-12-16T19:40:08.830606-06:00","closed_at":"2025-12-16T19:40:08.830606-06:00","dependencies":[{"issue_id":"zine-n9v.5","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.453649-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.6","title":"Add cron job collision handling (mutex/distributed lock)","description":"## Problem\nThe 15-minute cron interval (§3.2) could lead to overlapping executions if a batch takes longer than 15 minutes to complete, causing duplicate processing.\n\n## Context\n- Cron trigger runs every 15 minutes (line 2925)\n- Batch size is 50 subscriptions\n- Each subscription requires API calls that may be rate-limited\n- Cloudflare Workers have a 30-second CPU time limit, but cron handlers can run longer with `ctx.waitUntil()`\n- No mechanism prevents the next cron from starting while previous is still running\n\n## Solution\nAdd a section §3.2.1 \"Cron Job Collision Prevention\":\n\n```typescript\n// apps/worker/src/jobs/poll-subscriptions.ts\n\nconst POLL_LOCK_KEY = 'cron:poll-subscriptions:lock';\nconst POLL_LOCK_TTL = 900; // 15 minutes (matches cron interval)\n\nexport async function pollSubscriptions(env: Env) {\n  // Check for existing execution\n  const existingLock = await env.KV.get(POLL_LOCK_KEY);\n  if (existingLock) {\n    const lockTime = parseInt(existingLock, 10);\n    const elapsed = Date.now() - lockTime;\n    \n    // If lock is recent, skip this execution\n    if (elapsed \u003c POLL_LOCK_TTL * 1000) {\n      console.log(`[Poll] Skipping - previous execution still running (${Math.round(elapsed/1000)}s elapsed)`);\n      return;\n    }\n    // Stale lock - previous execution may have crashed\n    console.warn(`[Poll] Stale lock detected (${Math.round(elapsed/1000)}s old), proceeding`);\n  }\n  \n  // Acquire lock\n  await env.KV.put(POLL_LOCK_KEY, Date.now().toString(), { \n    expirationTtl: POLL_LOCK_TTL \n  });\n  \n  try {\n    // ... existing polling logic ...\n  } finally {\n    // Release lock on completion\n    await env.KV.delete(POLL_LOCK_KEY);\n  }\n}\n```\n\nAlso mention that the batch size (50) was chosen to typically complete within 10 minutes, leaving buffer before next cron.\n\n## Files\n- features/subscriptions/spec.md (new section §3.2.1 after line 2969)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:13.523751-06:00","updated_at":"2025-12-16T19:42:45.623491-06:00","closed_at":"2025-12-16T19:42:45.623491-06:00","dependencies":[{"issue_id":"zine-n9v.6","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.524056-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.7","title":"Fix Web Crypto migration: handle 16-byte to 12-byte IV format change","description":"## Problem\nThe spec notes a format change between Node.js crypto and Web Crypto API (§7.1 note around line 6920) but the migration function in §7.6.4 doesn't handle decrypting legacy tokens encrypted with the old format.\n\n## Context\n- Old format (Node.js): `iv:authTag:ciphertext` with 16-byte IV\n- New format (Web Crypto): `iv:ciphertext` with 12-byte IV (auth tag appended to ciphertext)\n- §7.6.3 `parseVersionedCiphertext` handles versioned (`v1:...`) and legacy (no version prefix) formats\n- But the legacy format parsing assumes the NEW Web Crypto format, not the OLD Node.js format\n- Existing tokens encrypted with Node.js would fail to decrypt\n\n## Solution\nUpdate §7.6.3 `parseVersionedCiphertext` to detect and handle both legacy formats:\n\n```typescript\nfunction parseVersionedCiphertext(encrypted: string, env: Env): ParsedCiphertext {\n  // New versioned format: v{n}:{iv}:{authTag}:{ciphertext}\n  if (encrypted.startsWith('v')) {\n    // ... existing versioned handling ...\n  }\n  \n  // Legacy format detection\n  const parts = encrypted.split(':');\n  \n  // Old Node.js format: {iv}:{authTag}:{ciphertext} (3 parts, 16-byte IV)\n  if (parts.length === 3) {\n    const iv = hexToBytes(parts[0]);\n    \n    if (iv.length === 16) {\n      // Old Node.js format with 16-byte IV\n      return {\n        version: 0, // Special version for legacy Node.js format\n        iv,\n        authTag: hexToBytes(parts[1]),\n        ciphertext: hexToBytes(parts[2]),\n        format: 'nodejs'\n      };\n    }\n    \n    // New Web Crypto legacy format with 12-byte IV\n    if (iv.length === 12) {\n      return {\n        version: 1,\n        iv,\n        authTag: hexToBytes(parts[1]),\n        ciphertext: hexToBytes(parts[2]),\n        format: 'webcrypto'\n      };\n    }\n  }\n  \n  // New Web Crypto format: {iv}:{ciphertext} (2 parts)\n  if (parts.length === 2) {\n    // ... existing handling ...\n  }\n  \n  throw new DecryptionError('Invalid ciphertext format', 'INVALID_FORMAT');\n}\n```\n\nThen update the decrypt function to use appropriate algorithm parameters based on format.\n\n## Files\n- features/subscriptions/spec.md (§7.6.3 around line 7413)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:13.59684-06:00","updated_at":"2025-12-16T19:57:56.2399-06:00","closed_at":"2025-12-16T19:57:56.2399-06:00","dependencies":[{"issue_id":"zine-n9v.7","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.597161-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.8","title":"Add transaction boundaries to ingestion pipeline (§4.3)","description":"## Problem\nThe ingestion pipeline (§4.3) performs multiple database operations that should be atomic but aren't wrapped in a transaction. Partial failures could leave orphaned or inconsistent records.\n\n## Context\nThe `ingestItem` function (lines 3289-3356) does:\n1. Check `provider_items_seen` (read)\n2. Find or create `items` (read/write)\n3. Create `user_items` (write)\n4. Create `subscription_items` (write)\n5. Create `provider_items_seen` (write)\n\nIf step 4 fails after step 3 succeeds:\n- User sees item in inbox\n- But no record linking it to subscription\n- `provider_items_seen` not created → could be re-ingested\n\n## Solution\nUpdate §4.3 to wrap operations in a transaction. D1 supports transactions via the batch API:\n\n```typescript\nasync function ingestItem(\n  userId: string,\n  subscriptionId: string,\n  rawItem: YouTubeVideo | SpotifyEpisode,\n  provider: Provider,\n  db: DrizzleDB\n): Promise\u003c{ created: boolean; userItemId: string }\u003e {\n  const providerId = rawItem.id;\n  \n  // 1. Check idempotency (read - outside transaction is fine)\n  const seen = await db.query.providerItemsSeen.findFirst({...});\n  if (seen) {\n    return { created: false, userItemId: seen.userItemId };\n  }\n  \n  // 2-5. Atomic writes using transaction\n  return await db.transaction(async (tx) =\u003e {\n    // Find or create canonical item\n    let item = await tx.query.items.findFirst({...});\n    if (!item) {\n      const transformed = transformItem(rawItem, provider);\n      [item] = await tx.insert(items).values(transformed).returning();\n    }\n    \n    // Create user_item\n    const userItemId = ulid();\n    await tx.insert(userItems).values({\n      id: userItemId,\n      userId,\n      itemId: item.id,\n      state: 'INBOX',\n      ingestedAt: Date.now(),\n    });\n    \n    // Create subscription_item\n    await tx.insert(subscriptionItems).values({...});\n    \n    // Mark as seen (idempotency)\n    await tx.insert(providerItemsSeen).values({\n      id: ulid(),\n      userId,\n      provider,\n      providerItemId: providerId,\n      userItemId,\n      firstSeenAt: Date.now(),\n    });\n    \n    return { created: true, userItemId };\n  });\n}\n```\n\nNote: D1's transaction support may have limits - add a note about checking current D1 transaction capabilities.\n\n## Files\n- features/subscriptions/spec.md (§4.3 around line 3289)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T19:34:13.668451-06:00","updated_at":"2025-12-16T19:40:41.970397-06:00","closed_at":"2025-12-16T19:40:41.970397-06:00","dependencies":[{"issue_id":"zine-n9v.8","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.668763-06:00","created_by":"daemon"}]}
{"id":"zine-n9v.9","title":"Add race condition handling for canonical item creation","description":"## Problem\nWhen two users subscribe to the same channel simultaneously, the `findOrCreateCanonicalItem` logic could race, potentially creating duplicate canonical items or failing on unique constraint.\n\n## Context\n- §4.3 line 3312 does `findFirst` then `insert` if not found\n- Two workers polling different users' subscriptions to the same channel at the same time\n- Both could find no existing item, both try to insert → one fails with unique constraint violation\n- The `items` table has `UNIQUE(provider, provider_id)` but error handling isn't shown\n\n## Solution\nAdd a section §4.2.1 \"Canonical Item Upsert\" with proper conflict handling:\n\n```typescript\n/**\n * Find or create a canonical item using upsert pattern.\n * Handles race conditions from concurrent ingestion.\n */\nasync function findOrCreateCanonicalItem(\n  provider: Provider,\n  providerId: string,\n  transformFn: () =\u003e NewItem,\n  db: DrizzleDB\n): Promise\u003cItem\u003e {\n  // First, try to find existing\n  const existing = await db.query.items.findFirst({\n    where: and(\n      eq(items.provider, provider),\n      eq(items.providerId, providerId)\n    ),\n  });\n  \n  if (existing) {\n    return existing;\n  }\n  \n  // Not found - try to insert with conflict handling\n  try {\n    const newItem = transformFn();\n    const [created] = await db\n      .insert(items)\n      .values(newItem)\n      .onConflictDoNothing({ target: [items.provider, items.providerId] })\n      .returning();\n    \n    if (created) {\n      return created;\n    }\n    \n    // Conflict occurred - another worker created it, fetch it\n    const raceWinner = await db.query.items.findFirst({\n      where: and(\n        eq(items.provider, provider),\n        eq(items.providerId, providerId)\n      ),\n    });\n    \n    if (!raceWinner) {\n      throw new Error(`Item disappeared after conflict: ${provider}/${providerId}`);\n    }\n    \n    return raceWinner;\n  } catch (error) {\n    // Handle any other constraint violations\n    if (isUniqueConstraintError(error)) {\n      // Race condition - fetch the winner\n      const existing = await db.query.items.findFirst({...});\n      if (existing) return existing;\n    }\n    throw error;\n  }\n}\n```\n\n## Files\n- features/subscriptions/spec.md (new section §4.2.1 after line 3284)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T19:34:13.746935-06:00","updated_at":"2025-12-16T19:43:18.9321-06:00","closed_at":"2025-12-16T19:43:18.9321-06:00","dependencies":[{"issue_id":"zine-n9v.9","depends_on_id":"zine-n9v","type":"parent-child","created_at":"2025-12-16T19:34:13.747298-06:00","created_by":"daemon"}]}
{"id":"zine-rfy","title":"Subscriptions Feature Implementation","description":"Implement the full subscriptions feature allowing users to subscribe to YouTube channels and Spotify podcasts, with automatic polling for new content that lands in their inbox. Based on features/subscriptions/spec.md.\n\n## Phases\n- **Phase 1 (Week 1-2)**: Foundation - Database schema, types, encryption, OAuth flow\n- **Phase 2 (Week 3-4)**: Core Features - tRPC endpoints, provider SDKs, polling, ingestion\n- **Phase 3 (Week 5-6)**: Mobile UI - Connection screens, subscription management, deep linking\n- **Phase 4 (Week 7-8)**: Polish - Adaptive polling, health monitoring, notifications, error boundaries\n\n## Key Files\n- `apps/worker/src/db/schema.ts` - Database schema additions\n- `apps/worker/src/trpc/routers/` - New routers (connections, subscriptions)\n- `apps/worker/src/lib/` - OAuth, encryption, polling utilities\n- `apps/mobile/app/` - New screens for connections and subscriptions\n- `packages/shared/src/types/domain.ts` - New enums and types\n\n## Dependencies\n- googleapis npm package for YouTube API\n- @spotify/web-api-ts-sdk for Spotify API\n- Cloudflare KV for OAuth state and rate limiting\n- Existing auth infrastructure (Clerk)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-16T20:41:30.677079-06:00","updated_at":"2025-12-16T20:41:30.677079-06:00"}
{"id":"zine-rfy.1","title":"Phase 1.1: Add subscription tables to database schema","description":"## Task\nAdd the new subscription-related tables to the database schema following the spec in §1.2.\n\n## Tables to Add\n\n### `provider_connections`\nStores OAuth credentials for connected providers (YouTube, Spotify).\n- `id` (TEXT, ULID, PK)\n- `user_id` (TEXT, FK to users)\n- `provider` (TEXT: YOUTUBE | SPOTIFY)\n- `provider_user_id` (TEXT)\n- `access_token` (TEXT, encrypted)\n- `refresh_token` (TEXT, encrypted)\n- `token_expires_at` (INTEGER, milliseconds)\n- `scopes` (TEXT)\n- `connected_at` (INTEGER, milliseconds)\n- `last_refreshed_at` (INTEGER)\n- `status` (TEXT: ACTIVE | EXPIRED | REVOKED)\n\n**Unique constraint**: `(user_id, provider)`\n\n### `subscriptions`\nUser's subscription to a specific channel/show.\n- `id` (TEXT, ULID, PK)\n- `user_id` (TEXT, FK)\n- `provider` (TEXT)\n- `provider_channel_id` (TEXT)\n- `name`, `description`, `image_url`, `external_url` (TEXT)\n- `total_items`, `last_published_at`, `last_polled_at` (INTEGER)\n- `poll_interval_seconds` (INTEGER, default 3600)\n- `status` (TEXT: ACTIVE | PAUSED | DISCONNECTED | UNSUBSCRIBED)\n- `created_at`, `updated_at` (INTEGER)\n\n**Unique constraint**: `(user_id, provider, provider_channel_id)`\n**Indexes**: `(status, last_polled_at)`, `(user_id, status)`\n\n### `subscription_items`\nLinks items to the subscription that discovered them.\n- `id`, `subscription_id`, `item_id`, `provider_item_id` (TEXT)\n- `published_at`, `fetched_at` (INTEGER)\n\n**Unique constraint**: `(subscription_id, provider_item_id)`\n\n## Notes\n- All timestamps in milliseconds (use `unixepoch() * 1000` for defaults)\n- Update existing `provider_items_seen` to add `user_item_id` column if needed\n- Run `npx drizzle-kit generate:sqlite` after schema changes\n\n## Spec Reference\nfeatures/subscriptions/spec.md §1.2","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:30.74007-06:00","updated_at":"2025-12-16T20:57:46.355674-06:00","closed_at":"2025-12-16T20:57:46.355674-06:00","dependencies":[{"issue_id":"zine-rfy.1","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:30.740392-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.10","title":"Phase 2.5: Implement ingestion pipeline with idempotency","description":"## Task\nImplement the ingestion pipeline with idempotency guarantees.\n\n## Flow\n\n```\nPoll → Fetch Items → [For Each Item] → Check Seen → Transform → Ingest → Mark Seen\n```\n\n## Main Function\n\n```typescript\nasync function ingestItem(\n  userId: string,\n  subscriptionId: string,\n  rawItem: YouTubeVideo | SpotifyEpisode,\n  provider: Provider,\n  db: DrizzleDB\n): Promise\u003c{ created: boolean; userItemId?: string }\u003e\n```\n\n## Steps\n\n1. **Idempotency Check** (provider_items_seen)\n   ```typescript\n   const seen = await db.query.providerItemsSeen.findFirst({\n     where: and(\n       eq(providerItemsSeen.userId, userId),\n       eq(providerItemsSeen.provider, provider),\n       eq(providerItemsSeen.providerItemId, rawItem.id)\n     )\n   });\n   if (seen) return { created: false };\n   ```\n\n2. **Transform** - Convert provider item to canonical Item\n\n3. **Transaction** - Atomic writes using D1 transaction:\n   - Find or create canonical `items` record (with conflict handling)\n   - Create `user_items` with state='INBOX'\n   - Create `subscription_items` link\n   - Create `provider_items_seen` (idempotency marker)\n\n## Race Condition Handling\n\nFor canonical item creation:\n```typescript\nconst [created] = await tx\n  .insert(items)\n  .values(newItem)\n  .onConflictDoNothing({ target: [items.provider, items.providerId] })\n  .returning();\n\nif (!created) {\n  // Race condition - fetch existing\n  const existing = await tx.query.items.findFirst({...});\n}\n```\n\n## Batch Ingestion\nProcess items in batches of 25 to stay within D1 limits.\n\n## Spec Reference\nfeatures/subscriptions/spec.md §4.3, §4.3.1","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.30955-06:00","updated_at":"2025-12-16T21:05:51.068647-06:00","closed_at":"2025-12-16T21:05:51.068647-06:00","dependencies":[{"issue_id":"zine-rfy.10","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.309875-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.11","title":"Phase 2.6: Implement cron-based polling scheduler","description":"## Task\nImplement cron-based polling scheduler for subscriptions.\n\n## Cron Configuration\n\nAdd to `wrangler.toml`:\n```toml\n[triggers]\ncrons = [\"*/15 * * * *\"]  # Every 15 minutes\n```\n\n## Polling Logic\n\n### `apps/worker/src/jobs/poll-subscriptions.ts`\n\n```typescript\nexport async function pollSubscriptions(env: Env) {\n  // 1. Collision prevention\n  const lockKey = 'cron:poll-subscriptions:lock';\n  const existingLock = await env.KV.get(lockKey);\n  if (existingLock) {\n    const elapsed = Date.now() - parseInt(existingLock);\n    if (elapsed \u003c 900_000) return; // Skip if \u003c 15 min\n  }\n  await env.KV.put(lockKey, Date.now().toString(), { expirationTtl: 900 });\n  \n  try {\n    // 2. Query due subscriptions\n    const dueSubscriptions = await getDueSubscriptions(env.db);\n    \n    // 3. Process in batches of 50\n    for (const batch of chunk(dueSubscriptions, 50)) {\n      await Promise.all(batch.map(sub =\u003e pollSubscription(sub, env)));\n    }\n  } finally {\n    await env.KV.delete(lockKey);\n  }\n}\n```\n\n### Query Due Subscriptions\n```typescript\nasync function getDueSubscriptions(db: DrizzleDB) {\n  const now = Date.now();\n  return db.query.subscriptions.findMany({\n    where: and(\n      eq(subscriptions.status, 'ACTIVE'),\n      or(\n        isNull(subscriptions.lastPolledAt),\n        sql`${subscriptions.lastPolledAt} + (${subscriptions.pollIntervalSeconds} * 1000) \u003c ${now}`\n      )\n    ),\n    limit: 200, // Safety limit\n  });\n}\n```\n\n### Poll Single Subscription\n```typescript\nasync function pollSubscription(subscription: Subscription, env: Env) {\n  const connection = await getConnection(subscription.userId, subscription.provider, env);\n  if (!connection || connection.status !== 'ACTIVE') {\n    await markSubscriptionDisconnected(subscription.id, env.db);\n    return;\n  }\n  \n  const accessToken = await getValidTokenWithLock(connection, env);\n  const items = await fetchNewItems(subscription, accessToken, env);\n  \n  for (const item of items) {\n    await ingestItem(subscription.userId, subscription.id, item, subscription.provider, env.db);\n  }\n  \n  await updateLastPolled(subscription.id, env.db);\n}\n```\n\n## Worker Entry Point\n```typescript\nexport default {\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    ctx.waitUntil(pollSubscriptions(env));\n  },\n  // ... fetch handler for HTTP\n};\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §3.2, §3.2.1","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.373844-06:00","updated_at":"2025-12-16T20:43:09.837655-06:00","dependencies":[{"issue_id":"zine-rfy.11","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.374136-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.12","title":"Phase 2.7: Add syncNow manual sync endpoint","description":"## Task\nAdd manual \"Sync Now\" endpoint for on-demand subscription polling.\n\n## Endpoint\n\n### `subscriptions.syncNow`\n\n```typescript\nsyncNow: protectedProcedure\n  .input(z.object({ subscriptionId: z.string() }))\n  .mutation(async ({ ctx, input }) =\u003e {\n    // 1. Verify ownership\n    const subscription = await ctx.db.query.subscriptions.findFirst({\n      where: and(\n        eq(subscriptions.id, input.subscriptionId),\n        eq(subscriptions.userId, ctx.userId),\n        eq(subscriptions.status, 'ACTIVE')\n      ),\n    });\n    \n    if (!subscription) {\n      throw new TRPCError({ code: 'NOT_FOUND' });\n    }\n    \n    // 2. Rate limit (max 1 per 5 minutes per subscription)\n    const rateLimitKey = `manual-sync:${input.subscriptionId}`;\n    const lastSync = await ctx.env.KV.get(rateLimitKey);\n    if (lastSync \u0026\u0026 Date.now() - parseInt(lastSync) \u003c 5 * 60 * 1000) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: 'Please wait 5 minutes between manual syncs',\n      });\n    }\n    \n    // 3. Perform sync\n    const connection = await getConnection(ctx.userId, subscription.provider, ctx.env);\n    const result = await pollSubscriptionWithRetry(subscription, connection, ctx.env);\n    \n    // 4. Update rate limit\n    await ctx.env.KV.put(rateLimitKey, Date.now().toString(), { expirationTtl: 300 });\n    \n    return { \n      success: result.success, \n      itemsFound: result.itemsFound,\n      itemsIngested: result.itemsIngested,\n    };\n  }),\n```\n\n## Mobile Integration\nAdd \"Sync Now\" button to subscription detail/list screens.\n\n## Spec Reference\nfeatures/subscriptions/spec.md §5.1","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.436324-06:00","updated_at":"2025-12-16T20:43:16.396898-06:00","dependencies":[{"issue_id":"zine-rfy.12","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.436638-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.13","title":"Phase 3.1: Implement mobile PKCE OAuth utilities","description":"## Task\nImplement PKCE OAuth utilities for mobile app.\n\n## Why Client-Side PKCE\nPKCE protects against authorization code interception. The verifier MUST be generated on the client - server-generated PKCE defeats the security purpose.\n\n## Files to Create\n\n### `apps/mobile/lib/pkce.ts`\n\n```typescript\nimport * as Crypto from 'expo-crypto';\n\n/**\n * Generate cryptographically random code verifier (43-128 chars)\n */\nexport async function generateCodeVerifier(): Promise\u003cstring\u003e {\n  const randomBytes = await Crypto.getRandomBytesAsync(32);\n  return base64UrlEncode(randomBytes);\n}\n\n/**\n * Generate code challenge from verifier (SHA256, base64url encoded)\n */\nexport async function generateCodeChallenge(verifier: string): Promise\u003cstring\u003e {\n  const hash = await Crypto.digestStringAsync(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    verifier,\n    { encoding: Crypto.CryptoEncoding.BASE64 }\n  );\n  return base64ToBase64Url(hash);\n}\n\nfunction base64UrlEncode(bytes: Uint8Array): string {\n  return btoa(String.fromCharCode(...bytes))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '');\n}\n```\n\n### `apps/mobile/lib/oauth.ts`\n\n```typescript\nimport * as WebBrowser from 'expo-web-browser';\nimport * as Linking from 'expo-linking';\n\nexport async function initiateOAuthFlow(provider: 'YOUTUBE' | 'SPOTIFY') {\n  // 1. Generate PKCE\n  const codeVerifier = await generateCodeVerifier();\n  const codeChallenge = await generateCodeChallenge(codeVerifier);\n  const state = crypto.randomUUID();\n  \n  // 2. Register state with server\n  await trpc.connections.registerState.mutate({ provider, state });\n  \n  // 3. Build auth URL\n  const authUrl = buildAuthUrl(provider, {\n    codeChallenge,\n    state,\n    redirectUri: Linking.createURL('oauth/callback'),\n  });\n  \n  // 4. Open browser\n  const result = await WebBrowser.openAuthSessionAsync(authUrl, redirectUri);\n  \n  // 5. Handle result\n  if (result.type === 'success') {\n    const { code, state: returnedState } = parseRedirectUrl(result.url);\n    \n    // 6. Exchange code for tokens\n    await trpc.connections.callback.mutate({\n      provider,\n      code,\n      state: returnedState,\n      codeVerifier,\n    });\n  }\n}\n```\n\n## Auth URLs\n- YouTube: `https://accounts.google.com/o/oauth2/v2/auth`\n- Spotify: `https://accounts.spotify.com/authorize`\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.2, §6.3","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.498433-06:00","updated_at":"2025-12-16T20:43:26.128322-06:00","dependencies":[{"issue_id":"zine-rfy.13","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.498734-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.14","title":"Phase 3.2: Create provider connection screens (YouTube, Spotify)","description":"## Task\nCreate provider connection screens for YouTube and Spotify OAuth.\n\n## Screens\n\n### `apps/mobile/app/(tabs)/connections.tsx`\n\nMain connections management screen:\n- List connected providers with status\n- \"Connect\" buttons for disconnected providers\n- \"Disconnect\" option for connected providers\n- Connection health indicators\n\n```typescript\nexport default function ConnectionsScreen() {\n  const { data: connections } = trpc.connections.list.useQuery();\n  \n  return (\n    \u003cScrollView\u003e\n      \u003cProviderConnectionCard\n        provider=\"YOUTUBE\"\n        connection={connections?.find(c =\u003e c.provider === 'YOUTUBE')}\n        onConnect={() =\u003e initiateOAuthFlow('YOUTUBE')}\n        onDisconnect={() =\u003e handleDisconnect('YOUTUBE')}\n      /\u003e\n      \u003cProviderConnectionCard\n        provider=\"SPOTIFY\"\n        connection={connections?.find(c =\u003e c.provider === 'SPOTIFY')}\n        onConnect={() =\u003e initiateOAuthFlow('SPOTIFY')}\n        onDisconnect={() =\u003e handleDisconnect('SPOTIFY')}\n      /\u003e\n    \u003c/ScrollView\u003e\n  );\n}\n```\n\n### `apps/mobile/components/provider-connection-card.tsx`\n\nReusable card component:\n- Provider logo and name\n- Connection status (Connected/Disconnected/Expired)\n- Connected timestamp\n- Scopes granted\n- Action button (Connect/Reconnect/Disconnect)\n\n```typescript\ninterface Props {\n  provider: 'YOUTUBE' | 'SPOTIFY';\n  connection?: ProviderConnection;\n  onConnect: () =\u003e void;\n  onDisconnect: () =\u003e void;\n}\n\nexport function ProviderConnectionCard({ provider, connection, onConnect, onDisconnect }: Props) {\n  const isConnected = connection?.status === 'ACTIVE';\n  const isExpired = connection?.status === 'EXPIRED';\n  \n  return (\n    \u003cView className=\"p-4 rounded-lg border\"\u003e\n      \u003cView className=\"flex-row items-center\"\u003e\n        \u003cProviderLogo provider={provider} /\u003e\n        \u003cText className=\"ml-3 font-semibold\"\u003e{provider}\u003c/Text\u003e\n        \u003cStatusBadge status={connection?.status} /\u003e\n      \u003c/View\u003e\n      \n      {isConnected \u0026\u0026 (\n        \u003cText className=\"text-gray-500 text-sm mt-2\"\u003e\n          Connected {formatRelative(connection.connectedAt)}\n        \u003c/Text\u003e\n      )}\n      \n      \u003cPressable\n        onPress={isConnected ? onDisconnect : onConnect}\n        className={isConnected ? \"bg-red-500\" : \"bg-blue-500\"}\n      \u003e\n        \u003cText\u003e{isExpired ? 'Reconnect' : isConnected ? 'Disconnect' : 'Connect'}\u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.1, §6.2","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.561841-06:00","updated_at":"2025-12-16T20:43:34.794727-06:00","dependencies":[{"issue_id":"zine-rfy.14","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.562163-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.15","title":"Phase 3.3: Create subscription management screens","description":"## Task\nCreate subscription management screens.\n\n## Screens\n\n### `apps/mobile/app/(tabs)/subscriptions.tsx`\n\nList all user subscriptions:\n- Grouped by provider\n- Shows subscription status, last updated\n- Pull-to-refresh\n- Search/filter\n- Add subscription FAB\n\n```typescript\nexport default function SubscriptionsScreen() {\n  const { data, isLoading, refetch } = trpc.subscriptions.list.useQuery();\n  \n  return (\n    \u003cView className=\"flex-1\"\u003e\n      \u003cFlatList\n        data={data?.items}\n        renderItem={({ item }) =\u003e (\n          \u003cSubscriptionListItem\n            subscription={item}\n            onPress={() =\u003e router.push(`/subscription/${item.id}`)}\n          /\u003e\n        )}\n        refreshControl={\u003cRefreshControl refreshing={isLoading} onRefresh={refetch} /\u003e}\n        ListEmptyComponent={\u003cEmptySubscriptions /\u003e}\n      /\u003e\n      \u003cFAB icon=\"plus\" onPress={() =\u003e router.push('/discover')} /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### `apps/mobile/components/subscription-list.tsx`\n\nReusable list item:\n```typescript\ninterface Props {\n  subscription: Subscription;\n  onPress: () =\u003e void;\n}\n\nexport function SubscriptionListItem({ subscription, onPress }: Props) {\n  return (\n    \u003cPressable onPress={onPress} className=\"flex-row p-4 border-b\"\u003e\n      \u003cImage source={{ uri: subscription.imageUrl }} className=\"w-12 h-12 rounded\" /\u003e\n      \u003cView className=\"ml-3 flex-1\"\u003e\n        \u003cText className=\"font-semibold\"\u003e{subscription.name}\u003c/Text\u003e\n        \u003cText className=\"text-gray-500 text-sm\"\u003e\n          {subscription.provider} • {formatStatus(subscription.status)}\n        \u003c/Text\u003e\n      \u003c/View\u003e\n      \u003cProviderIcon provider={subscription.provider} /\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Subscription Detail Screen\n- Full metadata\n- Sync Now button\n- Pause/Resume toggle\n- Unsubscribe (with confirmation)\n- Recent items from this subscription\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.4","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.622098-06:00","updated_at":"2025-12-16T20:43:41.3666-06:00","dependencies":[{"issue_id":"zine-rfy.15","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.62242-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.16","title":"Phase 3.4: Implement channel/show discovery and search","description":"## Task\nImplement channel/show discovery and search functionality.\n\n## Server-Side Search Endpoints\n\n### `subscriptions.searchChannels`\n```typescript\nsearchChannels: protectedProcedure\n  .input(z.object({\n    provider: ProviderSchema,\n    query: z.string().min(2).max(100),\n    limit: z.number().min(1).max(20).default(10),\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    const connection = await requireConnection(ctx.userId, input.provider, ctx.env);\n    \n    if (input.provider === 'YOUTUBE') {\n      // Note: search.list costs 100 quota units - use sparingly!\n      return searchYouTubeChannels(connection, input.query, input.limit, ctx.env);\n    } else {\n      return searchSpotifyShows(connection, input.query, input.limit, ctx.env);\n    }\n  }),\n```\n\n## Mobile Discovery Screen\n\n### `apps/mobile/app/discover.tsx`\n\n```typescript\nexport default function DiscoverScreen() {\n  const [provider, setProvider] = useState\u003c'YOUTUBE' | 'SPOTIFY'\u003e('YOUTUBE');\n  const [searchQuery, setSearchQuery] = useState('');\n  const debouncedQuery = useDebounce(searchQuery, 300);\n  \n  const { data: results, isLoading } = trpc.subscriptions.searchChannels.useQuery(\n    { provider, query: debouncedQuery },\n    { enabled: debouncedQuery.length \u003e= 2 }\n  );\n  \n  return (\n    \u003cView className=\"flex-1\"\u003e\n      \u003cProviderTabs selected={provider} onSelect={setProvider} /\u003e\n      \u003cSearchInput value={searchQuery} onChangeText={setSearchQuery} /\u003e\n      \n      \u003cFlatList\n        data={results}\n        renderItem={({ item }) =\u003e (\n          \u003cDiscoveryResultItem\n            channel={item}\n            onSubscribe={() =\u003e handleSubscribe(item)}\n          /\u003e\n        )}\n        ListEmptyComponent={\n          debouncedQuery ? \u003cNoResults /\u003e : \u003cSearchPrompt /\u003e\n        }\n      /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n### `apps/mobile/hooks/use-channel-search.ts`\n\nCustom hook with debouncing and caching:\n```typescript\nexport function useChannelSearch(provider: Provider, query: string) {\n  const debouncedQuery = useDebounce(query, 300);\n  \n  return trpc.subscriptions.searchChannels.useQuery(\n    { provider, query: debouncedQuery },\n    {\n      enabled: debouncedQuery.length \u003e= 2,\n      staleTime: 5 * 60 * 1000, // Cache for 5 minutes\n      cacheTime: 30 * 60 * 1000,\n    }\n  );\n}\n```\n\n## Quota Consideration\nYouTube search costs 100 units/request. Consider:\n- Minimum query length (2+ chars)\n- Debouncing (300ms)\n- Client-side result caching\n- Daily search limit per user\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.3","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.685554-06:00","updated_at":"2025-12-16T20:43:55.816751-06:00","dependencies":[{"issue_id":"zine-rfy.16","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.685882-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.17","title":"Phase 3.5: Configure deep linking for OAuth callbacks","description":"## Task\nConfigure deep linking for OAuth callbacks in the mobile app.\n\n## app.json Configuration\n\n```json\n{\n  \"expo\": {\n    \"scheme\": \"zine\",\n    \"ios\": {\n      \"bundleIdentifier\": \"app.zine.mobile\",\n      \"associatedDomains\": [\"applinks:zine.app\"]\n    },\n    \"android\": {\n      \"package\": \"app.zine.mobile\",\n      \"intentFilters\": [\n        {\n          \"action\": \"VIEW\",\n          \"autoVerify\": true,\n          \"data\": [\n            {\n              \"scheme\": \"https\",\n              \"host\": \"zine.app\",\n              \"pathPrefix\": \"/oauth/callback\"\n            }\n          ],\n          \"category\": [\"BROWSABLE\", \"DEFAULT\"]\n        },\n        {\n          \"action\": \"VIEW\",\n          \"data\": [\n            {\n              \"scheme\": \"zine\",\n              \"host\": \"oauth\",\n              \"pathPrefix\": \"/callback\"\n            }\n          ],\n          \"category\": [\"BROWSABLE\", \"DEFAULT\"]\n        }\n      ]\n    }\n  }\n}\n```\n\n## URL Schemes\n- Custom: `zine://oauth/callback?code=...\u0026state=...`\n- Universal (HTTPS): `https://zine.app/oauth/callback?code=...\u0026state=...`\n\n## Deep Link Handler\n\n### `apps/mobile/app/_layout.tsx`\n\n```typescript\nimport * as Linking from 'expo-linking';\nimport { useEffect } from 'react';\n\nexport default function RootLayout() {\n  useEffect(() =\u003e {\n    // Handle deep links when app is already open\n    const subscription = Linking.addEventListener('url', handleDeepLink);\n    \n    // Handle deep link that opened the app\n    Linking.getInitialURL().then(url =\u003e {\n      if (url) handleDeepLink({ url });\n    });\n    \n    return () =\u003e subscription.remove();\n  }, []);\n  \n  const handleDeepLink = async ({ url }: { url: string }) =\u003e {\n    const parsed = Linking.parse(url);\n    \n    if (parsed.path === 'oauth/callback') {\n      const { code, state, error } = parsed.queryParams;\n      \n      if (error) {\n        // Handle OAuth error (user denied, etc.)\n        showError(error);\n        return;\n      }\n      \n      // The OAuth flow will complete via WebBrowser.openAuthSessionAsync\n      // This handler is backup for edge cases\n    }\n  };\n  \n  return \u003cSlot /\u003e;\n}\n```\n\n## OAuth Redirect URI\nSet in Google/Spotify OAuth app settings:\n- Development: `zine://oauth/callback`\n- Production: `https://zine.app/oauth/callback`\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.5","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.748698-06:00","updated_at":"2025-12-16T20:44:05.046255-06:00","dependencies":[{"issue_id":"zine-rfy.17","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.749007-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.18","title":"Phase 3.6: Add subscription items to inbox display","description":"## Task\nUpdate inbox display to show subscription-sourced items.\n\n## Changes to Inbox\n\n### Visual Indicators\n- Show subscription source for items from subscriptions\n- Provider icon (YouTube/Spotify)\n- \"From: Channel Name\" subtitle\n\n### `apps/mobile/app/(tabs)/inbox.tsx`\n\nUpdate item rendering:\n```typescript\nfunction InboxItem({ userItem }: { userItem: UserItemWithDetails }) {\n  const { item, subscriptionSource } = userItem;\n  \n  return (\n    \u003cPressable className=\"flex-row p-4 border-b\"\u003e\n      \u003cImage source={{ uri: item.thumbnailUrl }} className=\"w-20 h-12 rounded\" /\u003e\n      \u003cView className=\"ml-3 flex-1\"\u003e\n        \u003cText className=\"font-semibold\" numberOfLines={2}\u003e{item.title}\u003c/Text\u003e\n        \u003cView className=\"flex-row items-center mt-1\"\u003e\n          \u003cProviderIcon provider={item.provider} size={14} /\u003e\n          \u003cText className=\"text-gray-500 text-sm ml-1\"\u003e\n            {subscriptionSource?.name || item.creator}\n          \u003c/Text\u003e\n        \u003c/View\u003e\n        {item.duration \u0026\u0026 (\n          \u003cText className=\"text-gray-400 text-xs\"\u003e{formatDuration(item.duration)}\u003c/Text\u003e\n        )}\n      \u003c/View\u003e\n    \u003c/Pressable\u003e\n  );\n}\n```\n\n### Updated Hook\n\n### `apps/mobile/hooks/use-items.ts`\n\n```typescript\nexport function useInboxItems() {\n  return trpc.items.list.useQuery({\n    state: 'INBOX',\n    includeSubscriptionSource: true, // New flag\n  });\n}\n```\n\n### Backend Changes\n\nUpdate items.list to optionally include subscription source:\n```typescript\nlist: protectedProcedure\n  .input(z.object({\n    state: UserItemStateSchema,\n    includeSubscriptionSource: z.boolean().default(false),\n    // ... pagination\n  }))\n  .query(async ({ ctx, input }) =\u003e {\n    // Join with subscription_items and subscriptions if requested\n  }),\n```\n\n## Empty State\nWhen inbox is empty but user has subscriptions:\n\"No new items yet. Your subscriptions will appear here when new content is published.\"\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.6","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.813044-06:00","updated_at":"2025-12-16T20:44:13.674028-06:00","dependencies":[{"issue_id":"zine-rfy.18","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.813359-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.19","title":"Phase 4.1: Implement adaptive polling intervals","description":"## Task\nImplement adaptive polling intervals based on channel activity.\n\n## Algorithm\n\nAdjust poll frequency based on:\n1. **Channel posting frequency** - Prolific channels poll more often\n2. **Time since last new item** - Stale channels poll less\n3. **Time of day** - Reduce polling during off-peak hours (optional)\n\n### `apps/worker/src/lib/adaptive-polling.ts`\n\n```typescript\ninterface AdaptiveConfig {\n  minIntervalSeconds: number;  // 3600 (1 hour)\n  maxIntervalSeconds: number;  // 86400 (24 hours)\n  defaultIntervalSeconds: number; // 14400 (4 hours)\n}\n\nexport function calculateNextPollInterval(\n  subscription: Subscription,\n  recentItemTimestamps: number[],\n  config: AdaptiveConfig = DEFAULT_CONFIG\n): number {\n  // 1. Calculate average posting frequency\n  const avgPostingInterval = calculateAverageInterval(recentItemTimestamps);\n  \n  // 2. Time since last new item\n  const timeSinceLastItem = Date.now() - subscription.lastPublishedAt;\n  \n  // 3. Base interval on posting frequency\n  let interval: number;\n  \n  if (avgPostingInterval === null) {\n    // New subscription or no history - use default\n    interval = config.defaultIntervalSeconds;\n  } else if (avgPostingInterval \u003c 3600 * 6) {\n    // Posts multiple times per day - poll hourly\n    interval = config.minIntervalSeconds;\n  } else if (avgPostingInterval \u003c 3600 * 24) {\n    // Posts daily - poll every 4 hours\n    interval = 3600 * 4;\n  } else if (avgPostingInterval \u003c 3600 * 24 * 7) {\n    // Posts weekly - poll every 12 hours\n    interval = 3600 * 12;\n  } else {\n    // Posts rarely - poll daily\n    interval = config.maxIntervalSeconds;\n  }\n  \n  // 4. Decay: if no new content for 2x the expected interval, slow down\n  const expectedNextPost = (subscription.lastPublishedAt || 0) + avgPostingInterval;\n  if (Date.now() \u003e expectedNextPost * 2) {\n    interval = Math.min(interval * 1.5, config.maxIntervalSeconds);\n  }\n  \n  return Math.floor(interval);\n}\n```\n\n## Integration\n\nUpdate after each poll:\n```typescript\nasync function pollSubscription(subscription, env) {\n  // ... fetch items ...\n  \n  const recentTimestamps = items.map(i =\u003e i.publishedAt);\n  const newInterval = calculateNextPollInterval(subscription, recentTimestamps);\n  \n  await db.update(subscriptions)\n    .set({ pollIntervalSeconds: newInterval, lastPolledAt: Date.now() })\n    .where(eq(subscriptions.id, subscription.id));\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §3.3","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.876564-06:00","updated_at":"2025-12-16T20:44:24.677048-06:00","dependencies":[{"issue_id":"zine-rfy.19","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.876892-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.2","title":"Phase 1.2: Add subscription enums and types to shared package","description":"## Task\nAdd new TypeScript enums, types, and Zod schemas for the subscriptions feature.\n\n## Enums to Add (domain.ts)\n\n```typescript\nexport enum ProviderConnectionStatus {\n  ACTIVE = 'ACTIVE',\n  EXPIRED = 'EXPIRED',\n  REVOKED = 'REVOKED',\n}\n\nexport enum SubscriptionStatus {\n  ACTIVE = 'ACTIVE',\n  PAUSED = 'PAUSED',\n  DISCONNECTED = 'DISCONNECTED',\n  UNSUBSCRIBED = 'UNSUBSCRIBED',\n}\n```\n\nAdd corresponding type guards: `isProviderConnectionStatus()`, `isSubscriptionStatus()`\n\n## Interfaces to Add\n\n```typescript\nexport interface ProviderConnection {\n  id: string;\n  userId: string;\n  provider: Provider;\n  providerUserId: string;\n  status: ProviderConnectionStatus;\n  scopes: string;\n  connectedAt: string;\n  lastRefreshedAt?: string;\n}\n\nexport interface Subscription {\n  id: string;\n  userId: string;\n  provider: Provider;\n  providerChannelId: string;\n  name: string;\n  description?: string;\n  imageUrl?: string;\n  externalUrl?: string;\n  status: SubscriptionStatus;\n  lastPolledAt?: number;\n  pollIntervalSeconds: number;\n  createdAt: string;\n  updatedAt: string;\n}\n```\n\n## Zod Schemas to Add (schemas/index.ts)\n\n```typescript\nexport const YouTubeChannelIdSchema = z.string()\n  .regex(/^UC[a-zA-Z0-9_-]{22}$/, 'Invalid YouTube channel ID');\n\nexport const SpotifyShowIdSchema = z.string()\n  .regex(/^[a-zA-Z0-9]{22}$/, 'Invalid Spotify show ID');\n\nexport const ProviderConnectionStatusSchema = z.nativeEnum(ProviderConnectionStatus);\nexport const SubscriptionStatusSchema = z.nativeEnum(SubscriptionStatus);\n```\n\n## Export Updates (index.ts)\nExport all new types, enums, and schemas.\n\n## Spec Reference\nfeatures/subscriptions/spec.md §1.4, §1.5","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:30.804861-06:00","updated_at":"2025-12-16T20:57:48.439279-06:00","closed_at":"2025-12-16T20:57:48.439279-06:00","dependencies":[{"issue_id":"zine-rfy.2","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:30.805162-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.20","title":"Phase 4.2: Add connection health monitoring and recovery","description":"## Task\nAdd connection health monitoring and automatic recovery.\n\n## Health Check Job\n\n### `apps/worker/src/jobs/health-check.ts`\n\nRun every hour to check connection health:\n```typescript\nexport async function checkConnectionHealth(env: Env) {\n  const connections = await env.db.query.providerConnections.findMany({\n    where: eq(providerConnections.status, 'ACTIVE'),\n  });\n  \n  for (const connection of connections) {\n    const health = await checkSingleConnection(connection, env);\n    \n    if (!health.healthy) {\n      await handleUnhealthyConnection(connection, health.reason, env);\n    }\n  }\n}\n\nasync function checkSingleConnection(connection, env) {\n  try {\n    // Try to refresh token (validates credentials)\n    const token = await getValidTokenWithLock(connection, env);\n    \n    // Make lightweight API call to verify access\n    if (connection.provider === 'YOUTUBE') {\n      await verifyYouTubeAccess(token, env);\n    } else {\n      await verifySpotifyAccess(token, env);\n    }\n    \n    return { healthy: true };\n  } catch (error) {\n    return { healthy: false, reason: categorizeError(error) };\n  }\n}\n```\n\n## Error Categories\n\n```typescript\ntype ConnectionError = \n  | 'token_expired'      // Needs refresh (normal)\n  | 'token_revoked'      // User revoked access\n  | 'refresh_failed'     // Refresh token invalid\n  | 'api_error'          // Temporary API issue\n  | 'quota_exceeded';    // YouTube quota hit\n\nfunction categorizeError(error: unknown): ConnectionError {\n  // Parse error response codes\n}\n```\n\n## Recovery Actions\n\n```typescript\nasync function handleUnhealthyConnection(connection, reason, env) {\n  switch (reason) {\n    case 'token_revoked':\n    case 'refresh_failed':\n      // Mark as EXPIRED, notify user to reconnect\n      await markConnectionExpired(connection.id, env.db);\n      await createNotification(connection.userId, {\n        type: 'connection_expired',\n        provider: connection.provider,\n      });\n      break;\n      \n    case 'quota_exceeded':\n      // Pause YouTube subscriptions temporarily\n      await pauseProviderSubscriptions(connection.userId, 'YOUTUBE', env.db);\n      break;\n      \n    case 'api_error':\n      // Log and retry on next health check\n      console.warn(`API error for connection ${connection.id}`);\n      break;\n  }\n}\n```\n\n## Wrangler Config\n```toml\n[triggers]\ncrons = [\"*/15 * * * *\", \"0 * * * *\"]  # Poll every 15min, health check hourly\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §7.4, §7.5","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:31.942005-06:00","updated_at":"2025-12-16T20:44:35.483467-06:00","dependencies":[{"issue_id":"zine-rfy.20","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.942338-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.21","title":"Phase 4.3: Implement user notifications system","description":"## Task\nImplement user notifications system for subscription events.\n\n## Notification Types\n\n```typescript\ntype NotificationType =\n  | 'connection_expired'    // OAuth token needs refresh\n  | 'subscription_error'    // Polling failed repeatedly\n  | 'rate_limit_warning'    // Approaching rate limits\n  | 'quota_warning';        // YouTube quota running low\n```\n\n## Database\n\nAdd `user_notification_preferences` table:\n```sql\nCREATE TABLE user_notification_preferences (\n  user_id TEXT PRIMARY KEY REFERENCES users(id),\n  connection_issues BOOLEAN DEFAULT TRUE,\n  subscription_errors BOOLEAN DEFAULT TRUE,\n  rate_limit_warnings BOOLEAN DEFAULT FALSE,\n  quota_status BOOLEAN DEFAULT TRUE,\n  push_enabled BOOLEAN DEFAULT FALSE,\n  updated_at INTEGER DEFAULT (unixepoch() * 1000)\n);\n```\n\nAdd `notifications` table:\n```sql\nCREATE TABLE notifications (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id),\n  type TEXT NOT NULL,\n  title TEXT NOT NULL,\n  body TEXT,\n  data TEXT,  -- JSON payload\n  read_at INTEGER,\n  created_at INTEGER DEFAULT (unixepoch() * 1000)\n);\n```\n\n## Backend\n\n### `apps/worker/src/lib/notifications.ts`\n\n```typescript\nexport async function createNotification(\n  db: DrizzleDB,\n  params: {\n    userId: string;\n    type: NotificationType;\n    title: string;\n    body?: string;\n    data?: Record\u003cstring, unknown\u003e;\n  }\n) {\n  // Check user preferences\n  const prefs = await db.query.userNotificationPreferences.findFirst({\n    where: eq(userNotificationPreferences.userId, params.userId),\n  });\n  \n  const prefKey = getPreferenceKey(params.type);\n  if (prefs \u0026\u0026 prefs[prefKey] === false) {\n    return null; // User disabled this notification type\n  }\n  \n  const notification = await db.insert(notifications).values({\n    id: ulid(),\n    ...params,\n    data: params.data ? JSON.stringify(params.data) : null,\n  }).returning();\n  \n  // TODO: Push notification if enabled\n  \n  return notification;\n}\n```\n\n## Mobile\n\n### `apps/mobile/components/notification-banner.tsx`\n\nIn-app notification banner for connection issues:\n```typescript\nexport function ConnectionIssueBanner() {\n  const { data: connections } = trpc.connections.list.useQuery();\n  const expiredConnections = connections?.filter(c =\u003e c.status === 'EXPIRED');\n  \n  if (!expiredConnections?.length) return null;\n  \n  return (\n    \u003cView className=\"bg-yellow-100 p-3 flex-row items-center\"\u003e\n      \u003cAlertIcon className=\"text-yellow-600\" /\u003e\n      \u003cText className=\"ml-2 flex-1\"\u003e\n        {expiredConnections.length} connection(s) need attention\n      \u003c/Text\u003e\n      \u003cPressable onPress={() =\u003e router.push('/connections')}\u003e\n        \u003cText className=\"text-blue-600\"\u003eFix\u003c/Text\u003e\n      \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §7.7","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T20:41:32.004018-06:00","updated_at":"2025-12-16T20:44:49.829947-06:00","dependencies":[{"issue_id":"zine-rfy.21","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.004347-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.22","title":"Phase 4.4: Add React Error Boundaries for subscription screens","description":"## Task\nAdd React Error Boundaries for subscription-related screens.\n\n## Error Boundary Component\n\n### `apps/mobile/components/error-boundary.tsx`\n\n```typescript\nimport { Component, ErrorInfo, ReactNode } from 'react';\nimport { View, Text, Pressable } from 'react-native';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) =\u003e void;\n  resetKeys?: unknown[]; // Re-render children when these change\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nexport class ErrorBoundary extends Component\u003cProps, State\u003e {\n  state: State = { hasError: false, error: null };\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('[ErrorBoundary]', error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n    // TODO: Report to error tracking service (Sentry, etc.)\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    // Reset error state when resetKeys change\n    if (this.state.hasError \u0026\u0026 this.props.resetKeys) {\n      const hasKeyChanged = this.props.resetKeys.some(\n        (key, i) =\u003e key !== prevProps.resetKeys?.[i]\n      );\n      if (hasKeyChanged) {\n        this.setState({ hasError: false, error: null });\n      }\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        \u003cView className=\"flex-1 items-center justify-center p-6\"\u003e\n          \u003cText className=\"text-xl mb-2\"\u003eSomething went wrong\u003c/Text\u003e\n          \u003cText className=\"text-gray-500 mb-4 text-center\"\u003e\n            {this.state.error?.message || 'An unexpected error occurred'}\n          \u003c/Text\u003e\n          \u003cPressable\n            onPress={() =\u003e this.setState({ hasError: false, error: null })}\n            className=\"bg-blue-500 px-6 py-3 rounded-lg\"\n          \u003e\n            \u003cText className=\"text-white font-medium\"\u003eTry Again\u003c/Text\u003e\n          \u003c/Pressable\u003e\n        \u003c/View\u003e\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n## Usage in Screens\n\nWrap subscription-related screens:\n```typescript\n// In subscriptions list\n\u003cErrorBoundary \n  onError={(e) =\u003e trackError('subscriptions_list', e)}\n  resetKeys={[userId]}\n\u003e\n  \u003cSubscriptionsList /\u003e\n\u003c/ErrorBoundary\u003e\n\n// In OAuth flow\n\u003cErrorBoundary\n  fallback={\u003cOAuthErrorFallback /\u003e}\n  onError={(e) =\u003e trackError('oauth_flow', e)}\n\u003e\n  \u003cOAuthScreen provider={provider} /\u003e\n\u003c/ErrorBoundary\u003e\n\n// In subscription detail\n\u003cErrorBoundary resetKeys={[subscriptionId]}\u003e\n  \u003cSubscriptionDetail id={subscriptionId} /\u003e\n\u003c/ErrorBoundary\u003e\n```\n\n## Query Error Handling\n\nAlso handle tRPC query errors gracefully:\n```typescript\nfunction SubscriptionsList() {\n  const { data, error, refetch } = trpc.subscriptions.list.useQuery();\n  \n  if (error) {\n    return (\n      \u003cView className=\"flex-1 items-center justify-center\"\u003e\n        \u003cText\u003eFailed to load subscriptions\u003c/Text\u003e\n        \u003cPressable onPress={() =\u003e refetch()}\u003e\n          \u003cText className=\"text-blue-600\"\u003eRetry\u003c/Text\u003e\n        \u003c/Pressable\u003e\n      \u003c/View\u003e\n    );\n  }\n  \n  // ...\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.7","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T20:41:32.066784-06:00","updated_at":"2025-12-16T20:45:00.768847-06:00","dependencies":[{"issue_id":"zine-rfy.22","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.067118-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.23","title":"Phase 4.5: Implement offline handling with action queue","description":"## Task\nImplement offline handling with action queue for subscription mutations.\n\n## Offline Queue\n\n### `apps/mobile/lib/offline-queue.ts`\n\n```typescript\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-community/netinfo';\n\ninterface QueuedAction {\n  id: string;\n  type: 'subscribe' | 'unsubscribe' | 'pause' | 'resume';\n  payload: Record\u003cstring, unknown\u003e;\n  createdAt: number;\n  retryCount: number;\n}\n\nconst QUEUE_KEY = 'offline_action_queue';\n\nexport class OfflineQueue {\n  private static instance: OfflineQueue;\n  \n  static getInstance() {\n    if (!this.instance) this.instance = new OfflineQueue();\n    return this.instance;\n  }\n  \n  async enqueue(action: Omit\u003cQueuedAction, 'id' | 'createdAt' | 'retryCount'\u003e) {\n    const queue = await this.getQueue();\n    queue.push({\n      ...action,\n      id: crypto.randomUUID(),\n      createdAt: Date.now(),\n      retryCount: 0,\n    });\n    await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(queue));\n  }\n  \n  async getQueue(): Promise\u003cQueuedAction[]\u003e {\n    const raw = await AsyncStorage.getItem(QUEUE_KEY);\n    return raw ? JSON.parse(raw) : [];\n  }\n  \n  async processQueue() {\n    const isOnline = await NetInfo.fetch().then(s =\u003e s.isConnected);\n    if (!isOnline) return;\n    \n    const queue = await this.getQueue();\n    const remaining: QueuedAction[] = [];\n    \n    for (const action of queue) {\n      try {\n        await this.executeAction(action);\n      } catch (error) {\n        if (action.retryCount \u003c 3) {\n          remaining.push({ ...action, retryCount: action.retryCount + 1 });\n        }\n        // Drop after 3 retries\n      }\n    }\n    \n    await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(remaining));\n  }\n  \n  private async executeAction(action: QueuedAction) {\n    switch (action.type) {\n      case 'subscribe':\n        await trpc.subscriptions.add.mutate(action.payload);\n        break;\n      case 'unsubscribe':\n        await trpc.subscriptions.remove.mutate(action.payload);\n        break;\n      // ... etc\n    }\n  }\n}\n```\n\n## Hook Integration\n\n### `apps/mobile/hooks/use-offline-mutations.ts`\n\n```typescript\nexport function useSubscriptionMutation() {\n  const utils = trpc.useUtils();\n  const queue = OfflineQueue.getInstance();\n  \n  const subscribe = async (params: SubscribeParams) =\u003e {\n    const isOnline = await NetInfo.fetch().then(s =\u003e s.isConnected);\n    \n    if (isOnline) {\n      // Online: execute immediately\n      await trpc.subscriptions.add.mutate(params);\n    } else {\n      // Offline: queue and show optimistic UI\n      await queue.enqueue({ type: 'subscribe', payload: params });\n      // Update local cache optimistically\n      utils.subscriptions.list.setData(undefined, (old) =\u003e [\n        ...(old || []),\n        { ...params, id: `temp-${Date.now()}`, status: 'PENDING' },\n      ]);\n    }\n  };\n  \n  return { subscribe };\n}\n```\n\n## Network Listener\n\nProcess queue when coming back online:\n```typescript\nuseEffect(() =\u003e {\n  const unsubscribe = NetInfo.addEventListener(state =\u003e {\n    if (state.isConnected) {\n      OfflineQueue.getInstance().processQueue();\n    }\n  });\n  return unsubscribe;\n}, []);\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §6.6","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T20:41:32.128728-06:00","updated_at":"2025-12-16T20:45:12.226053-06:00","dependencies":[{"issue_id":"zine-rfy.23","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.129074-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.24","title":"Testing: Unit tests for encryption, transformation, idempotency","description":"## Task\nWrite unit tests for encryption, transformation, and idempotency logic.\n\n## Test Files\n\n### `apps/worker/src/lib/encryption.test.ts`\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { encrypt, decrypt, DecryptionError } from './encryption';\n\ndescribe('encryption', () =\u003e {\n  const TEST_KEY = '0'.repeat(64); // 32 bytes as hex\n  \n  it('encrypts and decrypts round-trip', async () =\u003e {\n    const plaintext = 'secret-oauth-token-12345';\n    const encrypted = await encrypt(plaintext, TEST_KEY);\n    const decrypted = await decrypt(encrypted, TEST_KEY);\n    expect(decrypted).toBe(plaintext);\n  });\n  \n  it('produces versioned format', async () =\u003e {\n    const encrypted = await encrypt('test', TEST_KEY);\n    expect(encrypted).toMatch(/^v1:[a-f0-9]+:[a-f0-9]+$/);\n  });\n  \n  it('produces different ciphertext for same plaintext (random IV)', async () =\u003e {\n    const e1 = await encrypt('same', TEST_KEY);\n    const e2 = await encrypt('same', TEST_KEY);\n    expect(e1).not.toBe(e2);\n  });\n  \n  it('throws DecryptionError for invalid format', async () =\u003e {\n    await expect(decrypt('invalid', TEST_KEY)).rejects.toThrow(DecryptionError);\n  });\n  \n  it('throws DecryptionError for wrong key', async () =\u003e {\n    const encrypted = await encrypt('test', TEST_KEY);\n    const wrongKey = '1'.repeat(64);\n    await expect(decrypt(encrypted, wrongKey)).rejects.toThrow(DecryptionError);\n  });\n});\n```\n\n### `apps/worker/src/lib/transform.test.ts`\n\n```typescript\ndescribe('transformYouTubeVideo', () =\u003e {\n  it('transforms playlist item to canonical Item', () =\u003e {\n    const playlistItem = mockYouTubePlaylistItem();\n    const item = transformYouTubeVideo(playlistItem);\n    \n    expect(item.contentType).toBe('VIDEO');\n    expect(item.provider).toBe('YOUTUBE');\n    expect(item.providerId).toBe(playlistItem.contentDetails.videoId);\n    expect(item.title).toBe(playlistItem.snippet.title);\n  });\n});\n\ndescribe('transformSpotifyEpisode', () =\u003e {\n  it('transforms episode to canonical Item', () =\u003e {\n    const episode = mockSpotifyEpisode();\n    const show = mockSpotifyShow();\n    const item = transformSpotifyEpisode(episode, show);\n    \n    expect(item.contentType).toBe('PODCAST');\n    expect(item.provider).toBe('SPOTIFY');\n    expect(item.duration).toBe(Math.floor(episode.duration_ms / 1000));\n  });\n});\n```\n\n### `apps/worker/src/ingestion/index.test.ts`\n\n```typescript\ndescribe('ingestItem', () =\u003e {\n  it('creates new user_item for unseen item', async () =\u003e {\n    const result = await ingestItem(userId, subscriptionId, mockVideo, 'YOUTUBE', db);\n    expect(result.created).toBe(true);\n    expect(result.userItemId).toBeDefined();\n  });\n  \n  it('skips already-seen items (idempotency)', async () =\u003e {\n    // First ingestion\n    await ingestItem(userId, subscriptionId, mockVideo, 'YOUTUBE', db);\n    // Second ingestion of same item\n    const result = await ingestItem(userId, subscriptionId, mockVideo, 'YOUTUBE', db);\n    expect(result.created).toBe(false);\n  });\n  \n  it('handles race condition for canonical item creation', async () =\u003e {\n    // Simulate concurrent ingestion\n    const [r1, r2] = await Promise.all([\n      ingestItem(user1, sub1, mockVideo, 'YOUTUBE', db),\n      ingestItem(user2, sub2, mockVideo, 'YOUTUBE', db),\n    ]);\n    \n    // Both should succeed, using same canonical item\n    expect(r1.created).toBe(true);\n    expect(r2.created).toBe(true);\n    \n    // Should be same canonical item\n    const items = await db.query.items.findMany({\n      where: eq(items.providerId, mockVideo.id)\n    });\n    expect(items).toHaveLength(1);\n  });\n});\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §8 (Testing)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:32.195745-06:00","updated_at":"2025-12-16T20:45:26.453234-06:00","dependencies":[{"issue_id":"zine-rfy.24","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.196078-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.25","title":"Testing: Integration tests for OAuth flow and tRPC endpoints","description":"## Task\nWrite integration tests for OAuth flow and tRPC endpoints.\n\n## Test Files\n\n### `apps/worker/src/trpc/routers/connections.test.ts`\n\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createTestContext } from '../test-utils';\n\ndescribe('connections router', () =\u003e {\n  let ctx: TestContext;\n  \n  beforeEach(async () =\u003e {\n    ctx = await createTestContext();\n  });\n  \n  describe('registerState', () =\u003e {\n    it('stores state in KV', async () =\u003e {\n      const state = crypto.randomUUID();\n      await ctx.caller.connections.registerState({ provider: 'YOUTUBE', state });\n      \n      const stored = await ctx.env.KV.get(`oauth:state:${state}`);\n      expect(stored).toBe(ctx.userId);\n    });\n    \n    it('rate limits excessive requests', async () =\u003e {\n      for (let i = 0; i \u003c 5; i++) {\n        await ctx.caller.connections.registerState({\n          provider: 'YOUTUBE',\n          state: crypto.randomUUID(),\n        });\n      }\n      \n      await expect(\n        ctx.caller.connections.registerState({\n          provider: 'YOUTUBE',\n          state: crypto.randomUUID(),\n        })\n      ).rejects.toThrow('TOO_MANY_REQUESTS');\n    });\n  });\n  \n  describe('callback', () =\u003e {\n    it('exchanges code for tokens and stores encrypted', async () =\u003e {\n      // Setup: register state, mock token exchange\n      const state = crypto.randomUUID();\n      await ctx.env.KV.put(`oauth:state:${state}`, ctx.userId, { expirationTtl: 1800 });\n      \n      mockFetch('https://oauth2.googleapis.com/token', {\n        access_token: 'test-access',\n        refresh_token: 'test-refresh',\n        expires_in: 3600,\n        scope: 'youtube.readonly',\n      });\n      \n      await ctx.caller.connections.callback({\n        provider: 'YOUTUBE',\n        code: 'auth-code',\n        state,\n        codeVerifier: 'a'.repeat(43),\n      });\n      \n      // Verify connection created\n      const connection = await ctx.db.query.providerConnections.findFirst({\n        where: eq(providerConnections.userId, ctx.userId),\n      });\n      expect(connection).toBeDefined();\n      expect(connection!.status).toBe('ACTIVE');\n      expect(connection!.accessToken).not.toBe('test-access'); // Should be encrypted\n    });\n  });\n});\n```\n\n### `apps/worker/src/trpc/routers/subscriptions.test.ts`\n\n```typescript\ndescribe('subscriptions router', () =\u003e {\n  describe('add', () =\u003e {\n    it('creates subscription for connected user', async () =\u003e {\n      // Setup: create active connection\n      await createTestConnection(ctx, 'YOUTUBE');\n      \n      const result = await ctx.caller.subscriptions.add({\n        provider: 'YOUTUBE',\n        providerChannelId: 'UCBJycsmduvYEL83R_U4JriQ',\n        name: 'Test Channel',\n      });\n      \n      expect(result.id).toBeDefined();\n      expect(result.status).toBe('ACTIVE');\n    });\n    \n    it('validates YouTube channel ID format', async () =\u003e {\n      await createTestConnection(ctx, 'YOUTUBE');\n      \n      await expect(\n        ctx.caller.subscriptions.add({\n          provider: 'YOUTUBE',\n          providerChannelId: 'invalid-id',\n        })\n      ).rejects.toThrow('Invalid YouTube channel ID');\n    });\n    \n    it('requires active provider connection', async () =\u003e {\n      // No connection created\n      await expect(\n        ctx.caller.subscriptions.add({\n          provider: 'YOUTUBE',\n          providerChannelId: 'UCBJycsmduvYEL83R_U4JriQ',\n        })\n      ).rejects.toThrow('PRECONDITION_FAILED');\n    });\n  });\n  \n  describe('list', () =\u003e {\n    it('returns paginated subscriptions', async () =\u003e {\n      // Create 60 subscriptions\n      await createTestSubscriptions(ctx, 60);\n      \n      const page1 = await ctx.caller.subscriptions.list({ limit: 50 });\n      expect(page1.items).toHaveLength(50);\n      expect(page1.hasMore).toBe(true);\n      \n      const page2 = await ctx.caller.subscriptions.list({\n        limit: 50,\n        cursor: page1.nextCursor,\n      });\n      expect(page2.items).toHaveLength(10);\n      expect(page2.hasMore).toBe(false);\n    });\n  });\n});\n```\n\n## Test Utilities\n\nCreate shared test utilities:\n```typescript\n// apps/worker/src/trpc/test-utils.ts\nexport async function createTestContext() { /* ... */ }\nexport async function createTestConnection(ctx, provider) { /* ... */ }\nexport async function createTestSubscriptions(ctx, count) { /* ... */ }\nexport function mockFetch(url, response) { /* ... */ }\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §8 (Testing)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:32.261275-06:00","updated_at":"2025-12-16T20:45:42.091541-06:00","dependencies":[{"issue_id":"zine-rfy.25","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:32.261573-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.3","title":"Phase 1.3: Implement AES-256-GCM token encryption utilities","description":"## Task\nImplement AES-256-GCM encryption for OAuth tokens using Web Crypto API (Cloudflare Workers compatible).\n\n## Functions to Implement\n\n### `encrypt(plaintext: string, key: string): Promise\u003cstring\u003e`\n- Generate random 12-byte IV\n- Import key using Web Crypto `importKey`\n- Encrypt with AES-256-GCM\n- Return format: `v1:{iv}:{ciphertext}` (hex encoded)\n\n### `decrypt(ciphertext: string, key: string): Promise\u003cstring\u003e`\n- Parse versioned format\n- Handle legacy formats (migration support)\n- Return decrypted plaintext\n\n### `DecryptionError` class\nCustom error with codes: `KEY_VERSION_NOT_FOUND`, `INVALID_FORMAT`, `DECRYPTION_FAILED`\n\n## Helper Functions\n```typescript\nfunction hexToBytes(hex: string): Uint8Array\nfunction bytesToHex(bytes: Uint8Array): string\nfunction parseVersionedCiphertext(encrypted: string): ParsedCiphertext\n```\n\n## Key Requirements\n- ENCRYPTION_KEY env var: 64 hex chars (32 bytes)\n- Support key rotation via versioned format\n- Handle decryption errors gracefully (mark connection EXPIRED vs retry)\n\n## Decryption Error Handling Strategy\n- `KEY_VERSION_NOT_FOUND`: Log, skip, retry on next poll\n- `INVALID_FORMAT`: Mark connection EXPIRED\n- `DECRYPTION_FAILED`: Track failures, expire after 3 consecutive failures\n\n## Spec Reference\nfeatures/subscriptions/spec.md §7.1, §7.6","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:30.86891-06:00","updated_at":"2025-12-16T20:57:49.944883-06:00","closed_at":"2025-12-16T20:57:49.944883-06:00","dependencies":[{"issue_id":"zine-rfy.3","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:30.869217-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.4","title":"Phase 1.4: Implement OAuth flow - state registration and token exchange","description":"## Task\nImplement the OAuth flow for YouTube and Spotify provider connections.\n\n## Files to Create/Modify\n\n### `apps/worker/src/lib/oauth.ts`\n\n```typescript\n// Token exchange with PKCE support\nasync function exchangeCodeForTokens(\n  provider: Provider,\n  code: string,\n  codeVerifier: string,\n  env: Env\n): Promise\u003cTokenResponse\u003e\n\n// Get provider user ID for storage\nasync function getProviderUserId(\n  provider: Provider,\n  accessToken: string\n): Promise\u003cstring\u003e\n```\n\n### `apps/worker/src/trpc/routers/connections.ts`\n\n**Endpoints:**\n\n1. `registerState` - Store OAuth state in KV (30 min TTL)\n   - Input: `{ provider, state: uuid }`\n   - Stores: `oauth:state:{state}` → `userId`\n\n2. `callback` - Exchange code for tokens\n   - Input: `{ provider, code, state, codeVerifier }`\n   - Validates state, exchanges tokens, encrypts, stores in DB\n   - Uses `onConflictDoUpdate` for reconnection\n\n3. `list` - Get user's provider connections\n   - Returns connections without tokens (status, scopes, connectedAt)\n\n4. `disconnect` - Remove a provider connection\n   - Marks subscriptions as DISCONNECTED\n   - Optionally deletes connection record\n\n## OAuth URLs\n- YouTube: `https://oauth2.googleapis.com/token`\n- Spotify: `https://accounts.spotify.com/api/token`\n\n## Environment Variables Needed\n- `YOUTUBE_CLIENT_ID`, `YOUTUBE_CLIENT_SECRET`\n- `SPOTIFY_CLIENT_ID`, `SPOTIFY_CLIENT_SECRET`\n- `OAUTH_REDIRECT_URI`\n- `ENCRYPTION_KEY`\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.2","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:30.934224-06:00","updated_at":"2025-12-16T21:02:41.889224-06:00","closed_at":"2025-12-16T21:02:41.889224-06:00","dependencies":[{"issue_id":"zine-rfy.4","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:30.934549-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.5","title":"Phase 1.5: Add OAuth rate limiting middleware","description":"## Task\nAdd rate limiting to OAuth endpoints for defense-in-depth protection.\n\n## Rate Limits\n\n| Endpoint        | Window   | Max Requests | Key    |\n|-----------------|----------|--------------|--------|\n| `registerState` | 1 minute | 5            | userId |\n| `callback`      | 1 minute | 10           | userId |\n| `disconnect`    | 1 minute | 3            | userId |\n\n## Implementation\n\n### `apps/worker/src/middleware/rate-limit.ts`\n\n```typescript\ninterface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  keyPrefix: string;\n}\n\nexport async function checkRateLimit(\n  env: Env,\n  config: RateLimitConfig,\n  identifier: string\n): Promise\u003c{ allowed: boolean; remaining: number; resetMs: number }\u003e\n```\n\nUse KV with sliding window counter:\n- Key: `{prefix}:{identifier}`\n- Value: `{ count: number, windowStart: number }`\n- TTL: `windowMs / 1000 + 10` seconds\n\n### Integration\nApply rate limiting in tRPC procedures before business logic:\n```typescript\nconst rateLimit = await checkRateLimit(ctx.env, OAUTH_LIMITS.callback, ctx.userId);\nif (!rateLimit.allowed) {\n  throw new TRPCError({ code: 'TOO_MANY_REQUESTS', ... });\n}\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.2.1","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T20:41:30.999218-06:00","updated_at":"2025-12-16T20:42:13.93183-06:00","dependencies":[{"issue_id":"zine-rfy.5","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:30.999586-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.6","title":"Phase 2.1: Implement subscriptions tRPC router (list, add, remove, pause, resume)","description":"## Task\nImplement the subscriptions tRPC router with CRUD operations and pagination.\n\n## Endpoints\n\n### `list` - List user's subscriptions\n- Input: `{ provider?, status?, limit?, cursor? }`\n- Returns: `{ items: Subscription[], nextCursor, hasMore }`\n- Supports cursor-based pagination (default limit: 50, max: 100)\n\n### `add` - Subscribe to a channel/show\n- Input: `{ provider, providerChannelId, name?, imageUrl? }`\n- Validates channel ID format (YouTubeChannelIdSchema / SpotifyShowIdSchema)\n- Checks provider connection exists and is ACTIVE\n- Returns created subscription\n- Triggers initial fetch of latest item (single item only)\n\n### `remove` - Unsubscribe\n- Input: `{ subscriptionId, deleteItems? }`\n- Sets status to UNSUBSCRIBED (soft delete)\n- If `deleteItems`: removes INBOX items from that subscription\n\n### `pause` - Pause polling\n- Input: `{ subscriptionId }`\n- Sets status to PAUSED\n\n### `resume` - Resume polling\n- Input: `{ subscriptionId }`\n- Sets status to ACTIVE\n- Optionally triggers immediate poll\n\n### `get` - Get subscription details\n- Input: `{ subscriptionId }`\n- Returns subscription with recent items count\n\n## Schema Validation\nUse provider-specific channel ID schemas:\n```typescript\n.superRefine((data, ctx) =\u003e {\n  if (data.provider === 'YOUTUBE') {\n    YouTubeChannelIdSchema.parse(data.providerChannelId);\n  } else if (data.provider === 'SPOTIFY') {\n    SpotifyShowIdSchema.parse(data.providerChannelId);\n  }\n})\n```\n\n## Router Integration\nAdd to main router in `apps/worker/src/trpc/router.ts`\n\n## Spec Reference\nfeatures/subscriptions/spec.md §5.1, §5.2, §5.3","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.059421-06:00","updated_at":"2025-12-16T21:05:50.037656-06:00","closed_at":"2025-12-16T21:05:50.037656-06:00","dependencies":[{"issue_id":"zine-rfy.6","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.059732-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.7","title":"Phase 2.2: Implement YouTube provider fetcher with quota tracking","description":"## Task\nImplement YouTube provider fetcher with quota tracking and rate limiting.\n\n## Functions to Implement\n\n### `createYouTubeClient(accessToken: string, env: Env)`\nCreate googleapis YouTube client with user's OAuth token.\n\n### `fetchYouTubeChannelVideos(youtube, channelId, since?)`\n1. Get channel's uploads playlist ID via `channels.list`\n2. Fetch recent items via `playlistItems.list`\n3. Filter by `publishedAt` if `since` provided\n4. Return transformed items\n\n### `getYouTubeChannelInfo(youtube, channelId)`\nFetch channel metadata (name, description, thumbnail).\n\n## Quota Tracking\n\nYouTube API has a 10,000 unit daily quota. Track usage in KV:\n```typescript\nconst QUOTA_KEY = 'youtube:quota:{date}';\n\nasync function trackQuotaUsage(env: Env, units: number): Promise\u003cvoid\u003e\nasync function getQuotaRemaining(env: Env): Promise\u003cnumber\u003e\nasync function checkQuotaAvailable(env: Env, required: number): Promise\u003cboolean\u003e\n```\n\n**Quota costs:**\n- `channels.list`: 1 unit\n- `playlistItems.list`: 1 unit\n- `search.list`: 100 units (avoid!)\n\n## Graceful Degradation\nWhen quota is low (\u003c 1000 units):\n- Skip non-essential fetches\n- Increase poll intervals\n- Log warnings\n\n## Provider Item Types\n```typescript\ntype YouTubeVideo = youtube_v3.Schema$PlaylistItem;\n\nfunction transformYouTubeVideo(item: YouTubeVideo): NewItem\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.3, §3.5, §3.6, §4.2","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.120604-06:00","updated_at":"2025-12-16T21:02:43.626527-06:00","closed_at":"2025-12-16T21:02:43.626527-06:00","dependencies":[{"issue_id":"zine-rfy.7","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.120925-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.8","title":"Phase 2.3: Implement Spotify provider fetcher with rate limiting","description":"## Task\nImplement Spotify provider fetcher with rate limiting.\n\n## Functions to Implement\n\n### `createSpotifyClient(accessToken: string, env: Env)`\nCreate @spotify/web-api-ts-sdk client with user's OAuth token.\n```typescript\nimport { SpotifyApi, AccessToken } from '@spotify/web-api-ts-sdk';\n\nfunction createUserSpotifyClient(accessToken: string, env: Env): SpotifyApi {\n  const token: AccessToken = {\n    access_token: accessToken,\n    token_type: 'Bearer',\n    expires_in: 3600,\n    refresh_token: '', // We handle refresh externally\n  };\n  return SpotifyApi.withAccessToken(env.SPOTIFY_CLIENT_ID, token);\n}\n```\n\n### `fetchSpotifyShowEpisodes(spotify, showId, since?)`\n1. Call `spotify.shows.getShowEpisodes(showId, 'US', limit)`\n2. Filter by `release_date` if `since` provided\n3. Return transformed items\n\n### `getSpotifyShowInfo(spotify, showId)`\nFetch show metadata (name, description, images).\n\n## Rate Limiting\n\nSpotify has soft 180 req/min limit. Implement sliding window:\n```typescript\nasync function checkSpotifyRateLimit(env: Env): Promise\u003cboolean\u003e\nasync function trackSpotifyRequest(env: Env): Promise\u003cvoid\u003e\n```\n\nUse KV key: `spotify:ratelimit:{minute}`\n\n## Retry Logic\nOn 429 response:\n1. Read `Retry-After` header\n2. Wait specified duration\n3. Retry once\n4. If still 429, skip and log\n\n## Provider Item Types\n```typescript\ntype SpotifyEpisode = SimplifiedEpisode;\n\nfunction transformSpotifyEpisode(episode: SpotifyEpisode, show: SimplifiedShow): NewItem\n```\n\n## Spec Reference\nfeatures/subscriptions/spec.md §2.4, §3.7, §4.2","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.184282-06:00","updated_at":"2025-12-16T21:02:44.516321-06:00","closed_at":"2025-12-16T21:02:44.516321-06:00","dependencies":[{"issue_id":"zine-rfy.8","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.184597-06:00","created_by":"daemon"}]}
{"id":"zine-rfy.9","title":"Phase 2.4: Implement token refresh with distributed locking","description":"## Task\nImplement token refresh with distributed locking to prevent race conditions.\n\n## Problem\nMultiple cron jobs polling different subscriptions for the same user could try to refresh the same expired token simultaneously. Spotify rotates refresh tokens, so concurrent refreshes cause one to fail.\n\n## Solution: Distributed Lock with KV\n\n### `apps/worker/src/lib/tokens.ts`\n\n```typescript\nconst REFRESH_LOCK_TTL = 30; // seconds\n\nasync function getValidTokenWithLock(\n  connection: ProviderConnection,\n  env: Env\n): Promise\u003cstring\u003e {\n  const now = Date.now();\n  const bufferMs = 5 * 60 * 1000; // Refresh 5 min before expiry\n  \n  // Return existing if still valid\n  if (connection.tokenExpiresAt - bufferMs \u003e now) {\n    return decrypt(connection.accessToken, env.ENCRYPTION_KEY);\n  }\n  \n  // Try to acquire lock\n  const lockKey = `token:refresh:${connection.id}`;\n  const lockAcquired = await tryAcquireLock(env.KV, lockKey, REFRESH_LOCK_TTL);\n  \n  if (!lockAcquired) {\n    // Another worker is refreshing - wait and retry\n    await sleep(2000);\n    const updated = await getConnection(connection.id, env);\n    if (updated \u0026\u0026 updated.tokenExpiresAt - bufferMs \u003e now) {\n      return decrypt(updated.accessToken, env.ENCRYPTION_KEY);\n    }\n    throw new Error('Token refresh in progress');\n  }\n  \n  try {\n    const refreshed = await refreshToken(connection, env);\n    await persistTokens(connection.id, refreshed, env);\n    return refreshed.accessToken;\n  } finally {\n    await releaseLock(env.KV, lockKey);\n  }\n}\n```\n\n### Lock Helpers\n```typescript\nasync function tryAcquireLock(kv, key, ttl): Promise\u003cboolean\u003e\nasync function releaseLock(kv, key): Promise\u003cvoid\u003e\n```\n\n## Token Refresh by Provider\n- YouTube: Standard OAuth refresh\n- Spotify: May return new refresh_token (must persist rotation)\n\n## Spec Reference\nfeatures/subscriptions/spec.md §3.4, §3.4.1","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T20:41:31.247214-06:00","updated_at":"2025-12-16T21:02:45.979751-06:00","closed_at":"2025-12-16T21:02:45.979751-06:00","dependencies":[{"issue_id":"zine-rfy.9","depends_on_id":"zine-rfy","type":"parent-child","created_at":"2025-12-16T20:41:31.247512-06:00","created_by":"daemon"}]}
